
/**
 * <p>Creates a new ZIP OutputStream filtering the underlying stream.</p>
 * 
 * @param out the outputstream to zip
 */
public ZipOutputStream(OutputStream out);

/**
 * <p>Creates a new ZIP OutputStream writing to a File. Will use random
 * access if possible.</p>
 * 
 * @param file the file to zip to
 * 
 * @throws IOException on error
 */
public ZipOutputStream(File file) throws IOException;

/**
 * <p>This method indicates whether this archive is writing to a seekable
 * stream (i.e., to a random access file).</p>
 * 
 * <p>For seekable streams, you don’t need to calculate the CRC or
 * uncompressed size for {@link #STORED} entries before invoking
 * {@link #putNextEntry}.</p>
 * 
 * @return true if seekable
 */
public boolean isSeekable();

/**
 * <p>The encoding to use for filenames and the file comment.</p>
 * 
 * <p>For a list of possible values see <a
 * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">
 * http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.
 * Defaults to the platform’s default character encoding.</p>
 * 
 * @param encoding the encoding value
 */
public void setEncoding(final String encoding);

/**
 * <p>The encoding to use for filenames and the file comment.</p>
 * 
 * @return null if using the platform’s default character encoding
 */
public String getEncoding();

/**
 * <p>Whether to set the language encoding flag if the file name encoding
 * is UTF-8.</p>
 * 
 * <p>Defaults to true.</p>
 * 
 * @param b boolean
 */
public void setUseLanguageEncodingFlag(boolean b);

/**
 * <p>Whether to create Unicode Extra Fields.</p>
 * 
 * <p>Defaults to NEVER.</p>
 * 
 * @param b boolean
 */
public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b);

/**
 * <p>Whether to fall back to UTF and the language encoding flag if the
 * file name cannot be encoded using the specified encoding.</p>
 * 
 * <p>Defaults to false.</p>
 * 
 * @param b boolean
 */
public void setFallbackToUTF8(boolean b);

/**
 * <p>Whether Zip64 extensions will be used.</p>
 * 
 * <p>When setting the mode to {@link Zip64Mode#Never Never},
 * {@link #putNextEntry}, {@link #closeEntry}, {@link #finish} or
 * {@link #close} may throw a {@link Zip64RequiredException} if the entry’s
 * size or the total size of the archive exceeds 4GB or there are more than
 * 65 536 entries inside the archive. Any archive created in this mode will
 * be readable by implementations that don’t support Zip64.</p>
 * 
 * <p>When setting the mode to {@link Zip64Mode#Always Always}, Zip64
 * extensions will be used for all entries. Any archive created in this
 * mode may be unreadable by implementations that don’t support Zip64 even
 * if all its contents would be.</p>
 * 
 * <p>When setting the mode to {@link Zip64Mode#AsNeeded AsNeeded}, Zip64
 * extensions will transparently be used for those entries that require
 * them. This mode can only be used if the uncompressed size of the
 * {@link ZipEntry} is known when calling {@link #putNextEntry} or the
 * archive is written to a seekable output (i.e. you have used the
 * {@link #ZipOutputStream(java.io.File) File-arg constructor}) – this mode
 * is not valid when the output stream is not seekable and the uncompressed
 * size is unknown when {@link #putNextEntry} is called.</p>
 * 
 * <p>If no entry inside the resulting archive requires Zip64 extensions
 * then {@link Zip64Mode#Never Never} will create the smallest archive.
 * {@link Zip64Mode#AsNeeded AsNeeded} will create a slightly bigger archive
 * if the uncompressed size of any entry has initially been unknown and
 * create an archive identical to {@link Zip64Mode#Never Never} otherwise.
 * {@link Zip64Mode#Always Always} will create an archive that is at least
 * 24 bytes per entry bigger than the one {@link Zip64Mode#Never Never} would
 * create.</p>
 * 
 * <p>Defaults to {@link Zip64Mode#AsNeeded AsNeeded} unless
 * {@link #putNextEntry} is called with an entry of unknown size and data
 * is written to a non-seekable stream – in this case the default is
 * {@link Zip64Mode#Never Never}.</p>
 * 
 * @param mode Zip64Mode
 */
public void setUseZip64(Zip64Mode mode);

/**
 * <p>Finishes writing the contents of the ZIP output stream without closing
 * the underlying stream. Use this method when applying multiple filters in
 * succession to the same output stream.</p>
 * 
 * @throws ZipException if a ZIP file error has occurred
 * @throws IOException if an I/O exception has occurred
 * @throws Zip64RequiredException if the archive’s size exceeds 4 GByte
 *     or there are more than 65 535 entries inside the archive and
 *     {@link #setUseZip64} is {@link Zip64Mode#Never}
 */
public void finish() throws IOException;

/**
 * <p>Writes all necessary data for this entry.</p>
 * 
 * @throws IOException on error
 * @throws Zip64RequiredException if the entry’s uncompressed or compressed
 *     size exceeds 4 GByte and {@link #setUseZip64} is
 *     {@link Zip64Mode#Never}
 */
public void closeEntry() throws IOException;

/**
 * <p>Begins writing a new ZIP file entry and positions the stream to the
 * start of the entry data. Closes the current entry if still active. The
 * default compression method will be used if no compression method was
 * specified for the entry, and the current time will be used if the entry
 * has no set modification time.</p>
 * 
 * @param archiveEntry the ZIP entry to be written
 * 
 * @throws ZipException if a ZIP format error has occurred
 * @throws IOException if an I/O error has occurred
 * @throws Zip64RequiredException if the entry’s uncompressed or compressed
 *     size is known to exceed 4 GByte and {@link #setUseZip64} is
 *     {@link Zip64Mode#Never}
 */
public void putNextEntry(ZipEntry archiveEntry) throws IOException;

/**
 * <p>Set the file comment.</p>
 * 
 * @param comment the comment
 */
public void setComment(String comment);

/**
 * <p>Sets the compression level for subsequent entries.</p>
 * 
 * <p>Default is Deflater.DEFAULT_COMPRESSION.</p>
 * 
 * @param level the compression level
 * 
 * @throws IllegalArgumentException if an invalid compression level is
 *      specified
 */
public void setLevel(int level);

/**
 * <p>Sets the default compression method for subsequent entries.</p>
 * 
 * <p>Default is DEFLATED.</p>
 * 
 * @param method an <code>int</code> from java.util.zip.ZipEntry
 */
public void setMethod(int method);

/**
 * <p>Whether this stream is able to write the given entry.</p>
 * 
 * <p>May return false if it is set up to use encryption or a compression
 * method that hasn’t been implemented yet.</p>
 * 
 * @param ae ZipEntry
 * @return boolean
 */
public boolean canWriteEntryData(ZipEntry ae);

/**
 * <p>Writes bytes to ZIP entry.</p>
 * 
 * @param b the byte array to write
 * @param offset the start position to write from
 * @param length the number of bytes to write
 * @throws IOException on error
 */
public void write(byte[] b, int offset, int length) throws IOException;

/**
 * <p>Closes this output stream and releases any system resources associated
 * with the stream.</p>
 * 
 * @throws IOException if an I/O error occurs
 * @throws Zip64RequiredException if the archive’s size exceeds 4 GByte or
 *     there are more than 65 535 entries inside the archive and
 *     {@link #setUseZip64} is {@link Zip64Mode#Never}
 */
public void close() throws IOException;

/**
 * <p>Flushes this output stream and forces any buffered output bytes
 * to be written out to the stream.</p>
 * 
 * @throws IOException if an I/O error occurs
 */
public void flush() throws IOException;

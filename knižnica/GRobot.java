
 /////////////////////////////////////////////////////////////////////////////
 // This source code is part of the graphical framework called “Programovací
 // rámec GRobot”. (The name is Slovak like the vast majority of own
 // identifiers used in this project.) The name translated to English means
 // “The GRobot Framework.”
 // 
 // Copyright © 2010 – 2022 by Roman Horváth
 // 
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
 // the Free Software Foundation, either version 3 of the License, or
 // (at your option) any later version.
 // 
 // This program is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 // GNU General Public License for more details.
 // 
 // You should have received a copy of the GNU General Public License
 // along with this program (look for the file named license.txt). If not,
 // see ⟨http://www.gnu.org/licenses/⟩ or
 // ⟨https://www.gnu.org/licenses/gpl-3.0.txt⟩.
 // 
 // In case of any questions or requests, please, contact the author
 // Roman Horváth by e-mail: roman.horvath@truni.sk
 // or horvath.roman.sk@gmail.com.
 // 

package knižnica;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Paint;
import java.awt.Polygon;
import java.awt.RadialGradientPaint;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.TexturePaint;

import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import java.awt.font.TextLayout;
import java.awt.font.TextAttribute;

import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;
import java.awt.geom.FlatteningPathIterator;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;

import java.awt.image.BufferedImage;

import java.io.IOException;

import java.util.Collections;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;

import javax.swing.JTextField;
import javax.swing.SwingUtilities;

import static java.lang.Math.abs;
// import static java.lang.Math.atan;
import static java.lang.Math.atan2;
import static java.lang.Math.cos;
import static java.lang.Math.hypot;
import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.lang.Math.PI;
import static java.lang.Math.pow;
import static java.lang.Math.sin;
import static java.lang.Math.sqrt;
import static java.lang.Math.toDegrees;
import static java.lang.Math.toRadians;


// <!-- Prvý riadok v nasledujúcom JavaDoc komentári je vysvetlivka -->
// <!-- figurujúca v tabuľke so zoznamom tried a zároveň značka pre -->
// <!-- RoboDoc filter. Každá zmena v tomto riadku musí byť zároveň -->
// <!-- vnesená do generátora dokumentácie RoboDoc.                 -->

/**
 * <p>Ústredná trieda definujúca všetky metódy grafického robota (ktoré reprezentujú jeho funkcionalitu) a viaceré konštanty, ktoré sú pri práci s programovacím rámcom s výhodou využiteľné.</p><h2>Úvod</h2>
 * <!--
 * TODO:
 * 
 * Premiestniť do samostatnej kapitoly, prepracovať/vymyslieť novú
 * dokumentáciu pre túto triedu.
 * 
 * Pravdepodobne sa premenuje „Dokumentácia…“ na „Programovanie v Jave
 * s pomocou…“
 * Potom treba pridať aj úvodné slovo o tom, čo všetko programovanie v Jave
 * môže znamenať (o vyznavačoch „surového“ programovania – bez všelijakých
 * pomocných prvkov) a o tom, aký prístup volí tento programovací rámec
 * (angl. framework – pozri aj: GRobot/__TODO__.java)…
 * 
 * Kedysi som zvolil názov robota Vegas…
 * 
 *     Vegas — nízka, plochá, úrodná pôda a zvyčajne na brehu rieky (úrodné
 *         lúky).
 *     Vega (α Lyr / α Lyrae / Alfa Lyrae) je najjasnejšia hviezda v súhvezdí
 *         Lýra a piata najjasnejšia hviezda na nočnej oblohe.
 * 
 * Zatiaľ som ho ešte nepoužil…
 * -->
 * <p>Táto dokumentácia je podporným materiálom na vyučovanie predmetov
 * programovania v Jave s podporou <em>programovacieho rámca GRobot.</em>
 * Obsahuje úplný opis všetkých tried a metód vrátane príkladov použitia.
 * (Materiál môže byť priebežne aktualizovaný, preto odporúčame sledovať
 * tieto stránky.)<!-- Novšie verzie rámca budú publikované na <a
 * href="https://pdf.truni.sk/katedry/kmi/pracovnici?horvath"
 * target="_blank">stránkach autora</a> (buď samostatne, alebo v rámci <a
 * href="https://pdf.truni.sk/horvath/softver?generator"
 * target="_blank">generátora projektov</a> pre <a
 * href="https://www.bluej.org/" target="_blank">BlueJ,</a> ktorý spomíname
 * neskôr).--></p>
 * 
 * <p>Od 12. 3. 2019 je zdrojový kód programovacieho rámca GRobot umiestenný
 * na serveroch <a href="https://github.com/" target="_blank">GitHub.</a>
 * <a href="https://github.com/raubirius/GRobot" target="_blank">Jeho
 * projekt</a> je v nepravidelných intervaloch aktualizovaný. Môže nastať
 * prípad, kedy sa aktuálna verzia tejto dokumentácie presunie na niektorú
 * pridruženú službu repozitára. V tom prípade by sa táto informácia objavila
 * v opise repozitára. Aktuálna verzia <a
 * href="https://pdf.truni.sk/horvath/download?installs-winter-2018/GRobot.jar"
 * target="_blank">balíčka JAR</a> (t. j. binárna verzia rámca), môže svoje
 * umiestnenie tiež zmeniť. Aj o tejto skutočnosti sa pokúsime podať
 * informáciu na vhodnom umiestnení (on-line).</p>
 * 
 * <p>Programovací rámec má uľahčiť vstup do problematiky programovania.
 * Programovanie je široká oblasť. Vstup do tejto problematiky s použitím
 * „čistého“ jazyka Java považujeme za náročný, preto vznikol tento
 * rámec. Aby bol tento nástroj použiteľný, bolo nevyhnutné vypracovanie
 * kompletnej dokumentácie, ktorú ponúkame na týchto stránkach.</p>
 * 
 * <p>Grafický robot je skonštruovaný do sveta s dvomi {@linkplain Plátno
 * plátnami}, na ktoré môže kresliť. Funkcionalitu robota zabezpečuje najmä
 * ústredná trieda {@code currGRobot}. Okrem nej je rámci definovaných
 * asi päťdesiat ďalších tried, ktoré podporujú fungovanie robotov,
 * {@linkplain Svet sveta}, oboch {@linkplain Plátno plátien} a ďalších
 * prvkov, akými sú napríklad {@linkplain Obrázok obrázky}, {@linkplain Zvuk
 * zvuky}, {@linkplain Farba farby}, {@linkplain Zoznam zoznamy}, {@linkplain 
 * ObsluhaUdalostí udalosti}, {@linkplain Súbor súbory} a podobne…
 * Tieto triedy vznikli prirodzeným vývojom a ich účelom je zjednodušenie
 * používania celého rámca.</p>
 * 
 * <h2>Programovanie robota</h2>
 * 
 * <p>Nasledujúci príklad ukazuje ako naprogramovať robot tak, aby nakreslil
 * trojuholník (rovnostranný):</p>
 * 
 * <pre CLASS="example">
	{@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; {@code num3}; ++i)
	{
		{@link #dopredu(double) dopredu}({@code num50.0});
		{@link #doprava(double) doprava}({@code num120.0});
	}
	</pre>
 * 
 * <p><image>trojuholnik.png<alt/>Rovnostranný trojuholník nakreslený
 * robotom.</image>Výsledok kreslenia trojuholníka.</p>
 * 
 * <p>Príklad tri razy zopakuje dvojicu príkazov na pohyb robota o 50 bodov
 * dopredu a otočenie o 120° doprava. Tým dostaneme trojuholník. (<small>Na
 * zamyslenie: prečo sa otáčame o 120°? Keď príklad chceme prepracovať tak,
 * aby sa ním dal nakresliť ľubovoľný pravidelný n-uholník, musíme poznať
 * odpoveď na túto otázku… Predtým, než sa pozriete na riešenie, skúste
 * porozmýšľať…</small>)</p>
 * 
 * <p>Príklad sme prepracovali tak, aby kreslil ľubovoľný pravidelný
 * n-uholník so želanou dĺžkou strany. Zaviedli sme dve pomocné premenné,
 * ktorých hodnoty stačí zmeniť:</p>
 * 
 * <pre CLASS="example">
	{@code typeint} početUhlov = {@code num3};
	{@code typedouble} dĺžkaStrany = {@code num50.0};

	{@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; početUhlov; ++i)
	{
		{@link #dopredu(double) dopredu}(dĺžkaStrany);
		{@link #doprava(double) doprava}({@code num360.0} / početUhlov);
	}
	</pre>
 * 
 * <p>(<small>Teraz, keď ste uvideli riešenie, poznáte odpoveď na vyššie
 * spomenutú otázku? Pri odpovedaní na otázku, prečo sa na nakreslenie
 * trojuholníka otáčame práve o 120° môžeme zaujať najmenej dva rôzne postoje.
 * <b>Prvý postoj:</b> Keď sa na problém pozrieme z nadhľadu – z pohľadu
 * celkového pohybu robota a spýtame sa: koľko ráz sa musím otočiť, aby som
 * nakreslil trojuholník? Odpoveď znie dva razy. Kvôli zjednodušeniu výpočtov
 * zaveďme predpoklad, že robot musí skončiť otočený rovnakým smerom ako
 * začínal. Keď sa potom sa spýtame: koľko ráz sa musí pri kreslení
 * trojuholníka robot otočiť, aby skončil obrátený tým istým smerom ako
 * začínal? Odpoveď znie tri, čo je rovnaký počet ako počet uhlov
 * trojuholníka. V prípade, že kreslíme rovnostranný trojuholník, je miera
 * otočenia sa v každom rohu rovnomerná, pretože všetky tri uhly sú rovnaké.
 * Na otočenie sa okolo svojej osi o jednu otáčku, sa musí robot otočiť
 * o 360°. Keď toto otočenie rovnomerne rozdelíme na tri diely, dostávame
 * výsledok pootočenia sa v jednom rohu – 120°. Podobná úvaha platí pre každý
 * pravidelný n-uholník. <b>Druhý postoj:</b> Keď sa na problém pozrieme
 * detailnejšie len v kľúčovom bode pohybu robota – v rohu a zapojíme
 * poznatky z geometrie, ktoré hovoria, že súčet všetkých uhlov
 * v trojuholníku musí byť 180°. Keďže kreslíme rovnostranný trojuholník, sú
 * všetky tri uhly rovnaké, to znamená 60°. Ibaže pozor, hovoríme o vnútorných
 * uhloch trojuholníka. Musíme si uvedomiť, že robot je po nakreslení strany
 * otočený „von“ z trojuholníka. Je obrátený v smere kreslenia prvej strany
 * a na to, aby sa otočil do smeru kreslenia druhej strany, musí opísať
 * „vedľajší“ uhol vnútorného uhla (t. j. doplnok k priamemu uhlu – 180°), čo
 * je 120°.</small>)</p>
 * 
 * <!-- TODO – opraviť, aktualizovať, zvážiť premiestnenie
 * do samostatných kapitol -->
 * 
 * <p>Všetky príklady v rámci tejto dokumentácie je nevyhnutné umiestniť do
 * triedy. Vhodná je napríklad nasledujúca schéma:</p>
 * 
 * <p class="remark"><b>Poznámka:</b> Rovnakú schému generuje aj šablóna
 * „Hlavná trieda aplikácie“ v slovenskom preklade softvéru <a
 * href="https://www.bluej.org/" target="_blank">BlueJ</a> a tak isto aj
 * <a href="https://pdf.truni.sk/horvath/softver?generator"
 * target="_blank">generátor projektov</a> od autora programovacieho rámca
 * {@code currGRobot}, ktorý nájdete na <a
 * href="https://pdf.truni.sk/katedry/kmi/pracovnici?horvath"
 * target="_blank">jeho stránkach.</a> Spomínaný <a
 * href="https://pdf.truni.sk/horvath/softver?generator"
 * target="_blank">generátor projektov</a> uľahčuje študentom vytvorenie
 * nového projektu <a href="https://www.bluej.org/" target="_blank">BlueJ</a>
 * a nasledujúci import programovacieho rámca {@code currGRobot} do projektu,
 * ktorý by inak museli vykonávať ručne.</p>
 * 
 * <pre CLASS="example">
	{@code kwdimport} knižnica.{@code currGRobot};
	{@code note«importy ostatných tried, ktoré sú v projekte použité»}

	{@code kwdpublic} {@code typeclass} {@code note«názov triedy»} {@code kwdextends} {@code currGRobot}
	{
		{@code kwdprivate} {@code note«názov triedy»}()
		{
			{@code note«sem vložte kód príkladu»}
		}

		{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
		{
			{@code kwdnew} {@code note«názov triedy»}();
		}
	}
	</pre>
 * 
 * <p>Za <span CLASS="note">«názov triedy»</span> treba doplniť vhodný názov –
 * mal by vystihovať podstatu (toho, čo trieda robí). Na miesto <span
 * CLASS="note">«sem vložte kód príkladu»</span> treba vložiť príklad…
 * Vyššie uvedený príklad s kreslením trojuholníka vyzerá v schéme triedy
 * takto:</p>
 * 
 * <pre CLASS="example">
	{@code kwdimport} knižnica.{@code currGRobot};

	{@code kwdpublic} {@code typeclass} Trojuholník {@code kwdextends} {@code currGRobot}
	{
		{@code kwdprivate} Trojuholník()
		{
	<div CLASS="red_block">        {@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; {@code num3}; ++i)
			{
				{@link #dopredu(double) dopredu}({@code num50.0});
				{@link #doprava(double) doprava}({@code num120.0});
			}
	</div>    }

		{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
		{
			{@code kwdnew} Trojuholník();
		}
	}
	</pre>
 * 
 * <p>V niektorých prípadoch treba medzi importované triedy zaradiť aj
 * použité triedy Javy. Napríklad v príklade opisu metódy
 * {@link #náter(Paint) náter}, v ktorom sú použité triedy
 * Javy {@link java.awt.RadialGradientPaint},
 * {@link java.awt.MultipleGradientPaint.CycleMethod},
 * {@link java.awt.MultipleGradientPaint.ColorSpaceType},
 * {@link java.awt.geom.Point2D} a {@link java.awt.geom.AffineTransform},
 * preto ich treba importovať, o čom informuje aj upozornenie uvedené
 * v rámci opisu metódy {@link #náter(Paint) náter}. Väčšinou sa podobné
 * upozornenie nachádza v blízkosti príkladov, ktoré sa nespoliehajú len
 * na funkcionalitu programovacieho rámca, ale v niektorých prípadoch sa
 * mohlo stať, že na to dokumentácia explicitne neupozorňuje.</p>
 * 
 * <h2>Metódy a konštruktory</h2>
 * 
 * <p>Funkčné prvky tried môžeme rozdeliť do dvoch základných kategórií:</p>
 * 
 * <ul>
 * <li>metódy</li>
 * <li>a konštruktory.</li>
 * </ul>
 * 
 * <p>Metódy sa starajú o fungovanie objektu počas jeho bytia, konštruktory
 * spolupracujú pri vytváraní nového objektu. Konštruktor je vlastne
 * špeciálnou odrodou metódy, ktorá nesmie mať určený žiadny návratový typ
 * a musí sa volať rovnako ako trieda. Podľa toho ich ľahko rozlíšime.
 * Nasledujúci príklad definuje jednoduchú triedu {@code Šípka}
 * s konštruktorom a metódou:</p>
 * 
 * <table><tr><td>
 * <pre CLASS="example">
	{@code kwdimport} knižnica.{@code currGRobot};

	{@code kwdpublic} {@code typeclass} {@code currŠípka} {@code kwdextends} {@code currGRobot}
	{
		{@code kwdpublic} {@code currŠípka}()
		{
			definujVlastnéKreslenie();
		}

		{@code kwdprivate} {@code typevoid} definujVlastnéKreslenie()
		{
			{@link #vlastnýTvar(KreslenieTvaru) vlastnýTvar}({@code kwdnew} {@link KreslenieTvaru KreslenieTvaru}()
			{
				{@code kwdpublic} {@code typevoid} {@link KreslenieTvaru#kresli(GRobot) kresli}({@code currGRobot} r)
				{
					r.{@link #zdvihniPero() zdvihniPero}();
					r.{@link #posuňVľavo(double) posuňVľavo}({@code num0.5} * r.{@link #veľkosť() veľkosť}());
					r.{@link #dozadu(double) dozadu}(r.{@link #veľkosť() veľkosť}());
					r.{@link #položPero() položPero}();
					r.{@link #doprava(double) doprava}({@code num15});
					r.{@link #dopredu(double) dopredu}({@code num2} * r.{@link #veľkosť() veľkosť}());
					r.{@link #doprava(double) doprava}({@code num150});
					r.{@link #dopredu(double) dopredu}({@code num2} * r.{@link #veľkosť() veľkosť}());
					{@code comm// Prípadné ďalšie príkazy…}
				}
			});
		}
	}
	</pre>
 * </td><td><image>tvarSipky.png<alt/>Vlastný tvar robota s ilustračnou
 * kružnicou znázorňujúcou jeho veľkosť.</image>Vlastný tvar robota
 * z príkladu vľavo po zväčšení robota na veľkosť 100<br /><small>(šedá
 * kružnica je len ilustračná)</small>.</td></tr></table>
 * 
 * <p><a name="getter.setter.alias"><!--   --></a>
 * Okrem tohto rozdelenia, môžeme metódy rozdeliť do ďalších kategórií
 * podľa účelu. Z programátorského fyzického hľadiska (z pohľadu jazyka
 * Java) medzi nimi rozdiel nie je, ale z programátorského
 * logického<sup>[1]</sup> hľadiska (z pohľadu programátora) ten rozdiel
 * (prinajmenšom pre každého skúsenejšieho programátora) vidno. Jasne sa
 * rysujú najmä dva druhy metód – takzvané „gettery“ a „settery,“ čo je
 * nepreložiteľný názov vyplývajúci z účelu metód. Getter (z anglického
 * „get“ – vziať) číta hodnotu vlastnosti a setter (z anglického „set“ –
 * nastaviť) ju, naopak, zapisuje. Jednou z hlavných myšlienok objektovo
 * orientovaného programovania vždy bolo mať súkromné vlastnosti a verejné
 * metódy, ktoré s nimi pracujú. Z toho sa vyvinuli gettery a settery, ktoré
 * síce nenašli pevné zakotvenie priamo v jazyku Java, ale programátori ich
 * odlišujú od „klasických“ metód. Našiel sa aj zaužívaný spôsob vyjadrenia
 * tejto skutočnosti v programe – najjednoduchší možný – v názve metódy.
 * Gettery začínajú anglickým „get“ a settery „set“… Takto by vyzeral
 * jednoduchý príklad triedy {@code Osoba} s vlastnosťou {@code vek}
 * a prislúchajúcim getterom a setterom:</p>
 * 
 * <p><small>[1] – termín „logický“ je v počítačovej terminológii často
 * používaný ako opak „fyzického“; logický môže znamenať všeobecný,
 * nekonkrétny, patriaci do určitej množiny, vytvorený pre určité potreby…
 * naopak fyzický znamená kokrétny, pevný, stanovený…; logický a fyzický
 * v tomto prípade znamená akoby „pomyselný“ a „skutočný,“ pričom i ten
 * pomyselný má v tomto prípade veľký význam, pretože dáva veciam určitý
 * zmysel, kategorizuje ich, rozdeľuje…</small></p>
 * 
 * <pre CLASS="example">
	{@code kwdpublic} {@code typeclass} Osoba
	{
		{@code kwdprivate} {@code typeint} vek;

		{@code kwdpublic} {@code typeint} getVek()
		{
			{@code kwdreturn} vek;
		}

		{@code kwdpublic} {@code typevoid} setVek({@code typeint} vek)
		{
			{@code kwdif} (vek &lt; {@code num0}) {@code kwdthrow} {@code kwdnew} {@link GRobotException#GRobotException(String, String) GRobotException}(
				{@code srg"Vek nesmie byť záporný!"}, {@code srg"negativeAge"});
			{@code valthis}.vek = vek;
		}
	}
	</pre>
 * 
 * <p>V slovenskom názve anglické slovká get a set nevyzerajú príliš dobre,
 * preto sme sa rozhodli ich v rámci projektu programovacieho rámca
 * grafického robota zamlčať. Namiesto toho používame v rámci dokumentácie
 * ikonu <a class="getter"></a> na getter a <a class="setter"></a> na setter.
 * Funkčnosť metód sa tým, samozrejme, nemení, ibaže bez explicitného
 * uvedenia „get“ a „set“ v názve ich nie je možné na prvý pohľad (podľa
 * názvu) rozoznať, preto sa to usilujeme kompenzovať aspoň v dokumentácii
 * s pomocou ikon. Jestvujú vlastnosti, ktoré nemajú žiadny setter. Z toho
 * vyplýva, že sú určené len na čítanie. Výskyt opačného typu vlastností
 * (len na zápis) je v praxi veľmi zriedkavý. Obvykle by každá vlastnosť
 * mala mať možnosť čítania hodnoty. V tomto rámci sa vlastnosti určené len
 * na zápis nevyskytujú.</p>
 * 
 * <p>Trieda {@code currGRobot} a všetky triedy tohto balíčka obsahujú
 * definície veľkého množstvo takzvaných <a class="alias"></a> aliasov.
 * Aliasy sú presne tým, čo slovo „alias“ vyjadruje – prezývkami. Potreba
 * ich vzniku vyplynula z častých (často zbytočných) drobných omylov (kvázi
 * „preklepov“) začínajúcich programátorov pri používaní robota (resp.
 * jazykov akým je Logo). Tie súviseli s nejednoznačnosťou (slovenského)
 * jazyka, v ktorom jestvuje množstvo synoným (v slovenčine sú to napríklad:
 * dopredu, vpred, dozadu, vzad a podobne). Časom bolo jasné, že na všetko
 * nebude možné vytvoriť alias, preto po dosiahnutí určitej úrovne nasýtenia
 * už ďalšie aliasy (v súvislosti s riešením synoným) nevznikali.</p>
 * 
 * <!--(Avšak tie, ktoré boli definované dovtedy už v robote zostali.)-->
 * 
 * <p>Alias vo väčšine prípadov iba volá originálnu metódu (resp. kopíruje
 * správanie originálnej triedy, keďže aliasom môže byť i celá trieda).
 * Z technického pohľadu to mierne zvyšuje režijné náklady na činnosť
 * programu, preto i skúsenejším programátorom odporúčame používať vždy
 * originálne metódy, nie aliasy. Rovnako, v súvislosti s aliasmi tried,
 * originálne triedy a ich použitie v rôznych kontextoch je podrobnejšie
 * testované. Aj preto odporúčame používať originály.</p>
 * 
 * <p>Každý slovenský identifikátor s diakritikou má tiež definovaný alias
 * bez diakritiky, aby bolo rámec možné používať aj bez používania
 * diakritiky (z historických dôvodov). Je však nevyhnutné byť pri používaní
 * alebo nepoužívaní diakritiky jednotnotný: inak povedané, buď používať
 * diakritiku dôsledne, alebo vôbec. Kritické sú prípady priradenia inštancie
 * s diakritikou do premennej typu bez diakritiky. Nasledujúci riadok kódu
 * nie je preložiteľný:</p>
 * 
 * <pre CLASS="example">
	{@link PolozkaPonuky PolozkaPonuky} položka = {@code kwdnew} {@link PoložkaPonuky#PoložkaPonuky(String) PoložkaPonuky}({@code srg"Položka"});
	</pre>
 * 
 * <p>Rovnako nie je použiteľný žiadny identifikátor s čiastočne použitou
 * diakritikou (napríklad {@code Priehľadnost} alebo {@code Priehladnosť}).
 * O problémoch s diakritikou v krátkosti informujeme aj
 * v <a href="index.html">úvodnom slove.</a></p>
 * 
 * <!-- TODO – presunúť do samostatnej kapitoly -->
 * 
 * <h2>História</h2>
 * 
 * <p>Tento programovací rámec (angl. framework) vznikol postupným vývojom
 * a rozširovaním malého projektu, ktorý sa spočiatku volal
 * {@code Korytnačka}, medzitým chvíľu niesol beta označenie {@code Želva}
 * (táto verzia nebola nikdy publikovaná), potom bol premenovaný na Skupinu
 * tried grafického robota, potom na Knižnicu grafického robota, ktorá bola
 * nakoniec pretransformovaná na tento programovací rámec.</p>
 * 
 * <p>Ako mohol názov pôvodnej triedy ({@code Korytnačka}) zasväteným
 * našepkať, počiatky tohto projektu čerpali inšpiráciu aj z filozofie
 * programovacieho jazyka <a
 * href="https://en.wikipedia.org/wiki/Logo_(programming_language)"
 * target="_blank">Logo</a> a jeho pokračovateľov… <a
 * href="https://en.wikipedia.org/wiki/Logo_(programming_language)"
 * target="_blank">Logo</a> je programovací jazyk používaný vo výučbe. Keďže
 * originál jazyka je určený pre anglicky hovoriace deti a študentov, vzniká
 * po svete množstvo jazykových mutácií. Spomeňme dve najdôležitejšie
 * v slovenskom jazyku: <a href="http://comlogo.input.sk/"
 * target="_blank">Comenius Logo</a> a úspešného pokračovateľa <a
 * href="http://imagine.input.sk/" target="_blank">Imagine</a>. Vo svete <a
 * href="https://en.wikipedia.org/wiki/Logo_(programming_language)"
 * target="_blank">Loga</a> ide o programovanie kresliacej korytnačky, takže
 * učiaci sa môže hneď vidieť výsledky svojho úsilia. Z toho je odvodený
 * termín „korytnačia grafika.“ Svet grafického robota sa usiluje tieto
 * princípy poskytnúť pre začínajúcich (i pokročilých) programujúcich
 * v programovacom jazyku Java. Pozrime sa na stručnú históriu vývoja
 * trošku podrobnejšie.</p>
 * 
 * <p>Začalo sa to vývojom triedy {@code Korytnačka} niekedy v auguste roku
 * 2010. Prvé verzie triedy {@code Korytnačka} (približne do verzie 4.0)
 * boli významnou mierou inšpirované triedou {@code Turtle} autora Alfreda
 * Herma (<small>Odkaz: Alfred Hermes, Turtle class, 6a, 14.12.2003,
 * English</small>), ktorá je súčasťou balíka <a
 * href="https://www.bluej.org/" target="_blank">BlueJ</a>. Boli jej
 * rozšírením a dá sa povedať, že s ňou boli spätne kompatibilné.</p>
 * 
 * <p>Ďalšie verzie sa od pôvodnej idey značne odchýlili, preto nebola
 * deklarovaná spätná kompatibilita s pôvodnou triedou {@code Turtle}, ani
 * prvými verziami korytnačky. Takže môžeme povedať, že približne od verzie
 * 4.0, ktorá vznikala niekedy koncom zimného semestra akademického roka
 * 2010/2011, sa začal vývoj samostatnej triedy {@code Korytnačka}, ktorá už
 * nebola postavená na jadre pôvodnej triedy {@code Turtle}.</p>
 * 
 * <p>Na stránkach univerzity v Princetone (<small><b>Zdroj:</b> <a
 * href="https://introcs.cs.princeton.edu/java/stdlib/"
 * target="_blank">https://introcs.cs.princeton.edu/java/stdlib/</a></small>)
 * <!-- Starší odkaz: http://www.cs.princeton.edu/introcs/stdlib/ -->
 * sme našli našli knižnicu pre študentov pozostávajúcu zo 17 tried. Z nich
 * nás zaujala trieda {@code Draw}, v ktorej sme našli cenné poznatky
 * o práci s grafikou v Jave. S využitím týchto informácií sme začali
 * budovať novú sériu korytnačiek (beta verzia nového radu bola vyvíjaná
 * pod pracovným názvom {@code Želva} a bola už postavená na triedach
 * s príponou 2D – napríklad {@link Graphics2D Graphics2D}…). Postupne
 * pribúdali nové a nové vnorené triedy (niekedy nazývané aj zahniezdené
 * triedy, angl. <a
 * href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html"
 * target="_blank">nested classes</a>) a do stavu s funkčnou lúkou, oblohou,
 * súbormi, udalosťami, automatickým časovačom a tak ďalej, sa trieda
 * postupne prepracovávala od verzie 5.0 vyššie.</p>
 * 
 * <p>Priebežne prechádzala výraznými úpravami, nie všetky čiastkové verzie
 * boli publikované. Od verzie 6.9 boli k dispozícii aliasy všetkých metód
 * a vlastností aj bez diakritiky. Táto verzia však nikdy neopustila
 * súkromie prostredia svojho vzniku. Priniesla množstvo novej
 * funkcionality, ďalšie vnorené triedy, nové metódy, zavrhla niektoré
 * staršie koncepty, iné ponechala… Tým sa spätná kompatibilita opäť
 * výrazne porušila.</p>
 * 
 * <p>Verzia korytnačky 7.0 už trieda „neuniesla“ svoje meno a na jej báze
 * vznikol nový projekt. Keďže študenti (neznalí histórie Loga) mali veľa
 * otázok v súvislosti s pomenovaním a fungovaním takto pomenovanej triedy
 * ({@code Korytnačka} – ako to, že kreslí – učíte nás, že názvy majú byť
 * výstižné…) a i samotná postupne sa rozrastajúca korytnačka sa od
 * pôvodného konceptu pridŕžajúceho sa logovskej jednoduchosti značne
 * odchýlila, rozhodli sme sa, že zmena názvu a založenie nového projektu
 * novému konceptu iba prospeje.</p>
 * 
 * <p>Testovanie prvej beta verzie triedy {@code Robot} 0.6 sa začalo
 * koncom augusta 2011 – rok po začatí vývoja pôvodnej korytnačky. Koncom
 * septembra, po rozsiahlych úpravách a revíziách, prekročila verzia číslo
 * 0.8 (pričom sme sa rozhodli, že verzia 1.0 bude priradená až prvej úplnej
 * a riadne otestovanej verzii triedy {@code Robot}; vo verzii 0.8 stále
 * chýbala definícia jednej triedy). V januári 2013 bola ústredná trieda
 * premenovaná na {@code currGRobot}. Keďže nešlo o výraznú zmenu názvu,
 * číslovanie verzií bolo ponechané. Dôvody a dôsledky sú uvedené v <a
 * href="zoznam-zmien.html">zozname zmien</a> (pri čísle verzie 1.33)…</p>
 * 
 * <p>Ďalší z významných zlomov nastal na sklonku roka 2015. Knižnica bola
 * rozdelená na viacero samostatných súborov a presunutá do balíčka s názvom
 * <code>knižnica</code>. Tým sa pôvodná knižnica priblížila ku korektnému
 * prístupu tvorby programovacích rámcov (angl. framework) v jazyku Java.
 * Tým sa však transformácia neskončila a významný prerod zaznamenala až
 * v roku 2018, kedy boli všetky pôvodné aj novšie vnorené triedy (okrem
 * jednej – {@link Spojnica Spojnica}) presunuté na vyššiu úroveň v zmysle
 * ich transformácie na samostatné triedy balíčka (aj keď v rámci balíčka
 * zostali stále úzko prepojené) a knižnica (vtedy vo verzii 1.85) bola
 * premenovaná na programovací rámec s číslom verzie 2.0.</p>
 * 
 * <p>Transformácia bola dlho odkladaná, pretože po pôvodnom (počiatočnom)
 * rozhodnutí umiestniť „všetko do jediného súboru“ bolo veľmi komplikované
 * hľadať cestu späť. Preto pôvodná knižnica veľmi dlho zotrvávala v jednom
 * súbore. S nárastom jej objemu počas jej vývoja narastal aj počet
 * vnútorných prepojení, ktoré o to viac odďaľovali jej rozdelenie. Autor
 * dokonca zvažoval zanechať po určitom čase túto vývojovú líniu
 * <em>projektu GRobot</em> a začať vývoj úplne novej verzie umiestnenej
 * v balíčku a rozdelenej do samostatných súborov úplne od začiatku. Lenže
 * časová náročnosť takéhoto opätovného napísania celého rámca (v tom čase
 * zvaného knižnicou) tento postup nedovolila. Preto sa vývoj novej línie
 * nezačal a namiesto toho boli niektoré zmeny a kroky súvisiace s ďalším
 * vylepšovaním programovacieho rámca vykonané priamo v tejto línii.</p>
 * 
 * <p> </p>
 * 
 * <p class="remark"><b>Poznámka:</b> Na úplnosť dodajme, že pôvodný spôsob
 * umiestnenia celej skupiny tried do jedného súboru malo jedno rýdzo
 * pragmatické odôvodnenie. V tom čase autor úplne zavrhoval distribúciu
 * predchodcov tohto rámca vo forme .jar balíčka a tiež nejestvoval
 * <a href="https://pdf.truni.sk/horvath/softver?generator"
 * target="_blank">generátor projektov.</a> Študenti si museli vytvárať
 * projekty sami a do každého nového projektu museli skopírovať celý obsah
 * skupiny tried (v tom čase ešte korytnačky). Vzhľadom na prvé systematicky
 * sa opakujúce skúsenosti získané ešte počas používania predchádzajúcej
 * pomôcky (ktorou bola trieda {@code Konzola} – jej účelom bolo predovšetkým
 * zjednodušiť čítanie hodnôt zo štandardného vstupu, ktorým je predvolene
 * klávesnica, a jej funkcionalitu GRobot absorboval s miernou transformáciou
 * k svojim potrebám) bolo najjednoduchším riešením poskytnúť jediný
 * nezbalený súbor na prevzatie, ktorý študenti jednoducho a priamo (bez
 * rozbaľovania, bez komplikácií) umiestnili do priečinka s novým projektom.
 * Z hľadiska princípov tvorby softvéru je tento dôvod určite absurdný, lenže
 * tento softvér bol pôvodne primárne tvorený na účely výučby a tomuto cieľu
 * podliehalo všetko, čo s projektom súviselo.</p>
 * 
 * <p> </p>
 * 
 * <!-- TODO – presunúť do samostatnej kapitoly, zvážiť najlepší spôsob
 * zhromaždenia všetkých zdrojov na jednom mieste… -->
 * 
 * <h2>Ďalšia odporúčaná študijná literatúra</h2>
 * 
 * <table class="references">
 * 
 * <tr><td>1.</td><td><small>Keogh, James</small>: <em>Java bez předchozích
 * znalostí – průvodce pro samouky.</em> 1. vyd. Brno : Computer Press,
 * 2005. ISBN 80-251-0839-2.</td></tr>
 * 
 * <tr><td>2.</td><td><small>Kalaš, Ivan a kol.</small>: <em>Informatika
 * pre stredné školy.</em> Bratislava : SPN, 2001.
 * ISBN 80-08-01518-7.</td></tr>
 * 
 * <tr><td>3.</td><td><small>Zajacová, Katarína</small>: <em>Základy
 * programovania.</em> Trnava : 2010. [online]. Dostupné na: <a
 * href="http://cec.truni.sk/zajacova/2010_ZP_Java/index.html" target="_blank"
 * >http://cec.truni.sk/zajacova/2010_ZP_Java/index.html</a>. Citované: 2010 –
 * 2012.</td></tr>
 * 
 * <tr><td>4.</td><td><small>Hudeková, Dominika</small>: <em>Zbierka úloh
 * v Jave.</em> Trnava : 2012. [online]. Dostupné na: <a
 * href="http://cec.truni.sk/hudekova/2012_ZU_Java/index.html" target="_blank"
 * >http://cec.truni.sk/hudekova/2012_ZU_Java/index.html</a>. Citované: 2012 –
 * 2014.</td></tr>
 * 
 * <tr><td>5.</td><td><small>Hudeková, Dominika – Novák, Lukáš</small>:
 * <em>Java – programovací jazyk pre pokročilých programátorov + Java ako
 * prvý programovací jazyk.</em> Trnava : 2014. [online]. Dostupné na: <a
 * href="http://cec.truni.sk/hudekova/2014_EU_Java/" target="_blank"
 * >http://cec.truni.sk/hudekova/2014_EU_Java/</a>. Citované: 2014 –
 * 2016.</td></tr>
 * 
 * </table>
 * 
 * <h2>Študijná literatúra v anglickom jazyku</h2>
 * 
 * <table class="references">
 * 
 * <tr><td>1.</td><td><small>Barnes, J. David – Kölling, Michael</small>:
 * <em>Objects First with Java: A Practical Introduction Using BlueJ:
 * International Edition.</em> 5/E. Canterbury, Kent : University of Kent,
 * 2012. ISBN 978-013-283554-1.</td></tr>
 * 
 * <tr><td>2.</td><td><em>The Java Tutorials (Learning the Java
 * Language).</em> Oracle, 1995, 2015. [online]. Dostupné na:
 * <a target="_blank" href="https://docs.oracle.com/javase/tutorial/"
 * >https://docs.oracle.com/javase/tutorial/</a>. Citované: 2015 –
 * 2016.</td></tr>
 * 
 * <tr><td>3.</td><td><em>Java Platform Standard Edition 8
 * Documentation.</em> Oracle. [online]. Dostupné na:
 * <a target="_blank" href="https://docs.oracle.com/javase/8/docs/"
 * >https://docs.oracle.com/javase/8/docs/</a>. Citované: 2014 –
 * 2016.</td></tr>
 * 
 * </table>
 * 
 * <p><b>Od verzie 1.0 vyššie je pravidelne aktualizovaný
 * <a href="zoznam-zmien.html">zoznam zmien</a>.</b></p>
 */
public class GRobot implements Poloha, Smer, Rozmer, Farebnosť, Priehľadnosť,
	Konštanty
{
/*
Toto bolo presunuté na úvodnú stránku:

 * 
 * @version CURRENT_VERSION</dd>
<dt><b>Úplný názov publikácie:</b></dt>
  <dd class="O-publikacii">Dokumentácia programovacieho rámca GRobot
 * @author MAIN_DEVELOPER_TITLED</dd>
<dt><b>ISBN:</b></dt>
  <dd class="O-publikacii">ISBN ???-??-????-???-?</dd>
<dt><b>Vydanie:</b></dt>
  <dd class="O-publikacii">tretie, prepracované</dd>

(Je to tu ponechané na archivačné účely.)


	Poznámky:

		– Pri prechode robota na novú verziu Javy pozri:
			public Zoznam(Typ... prvky)
			com.sun.awt.AWTUtilities.setWindowOpaque(aWindow, false);

		– Pri rozširovaní dokumentácie treba dbať na výskyt nasledujúcich
		  dvoch znakov v príkladoch použitia: „ < “ (relačný operátor menší
		  než) „ - “ (rozdeľovník v úlohe operátora odčítania).

			– Prvý znak síce väčšinou (ak je sprava oddelený medzerou) HTML
			  vie zvládnuť, ale je lepšie a bezpečnejšie ho nahradiť entitou
			  &lt;.
			– Výskyt druhého znaku je kritický v úlohe operátora odčítania,
			  kedy zvykne byť oddelený medzerami z oboch strán. Vtedy je
			  lepšie ho nahradiť kódom: &#45;.

		– Treba skontrolovať všetky príklady v rámci dokumentácie a dopracovať
		  čo najviac ďalších príkladov.

		– funkcionalita vo vývoji by mala:
		throw new java.lang.UnsupportedOperationException
			("Táto operácia nie je v súčasnosti implementovaná.");
	*/

	// Počúvadlá udalostí robotov
	/*packagePrivate*/ final static Vector<GRobot> počúvajúciKlávesnicu =
		new Vector<>();
	/*packagePrivate*/ final static Vector<GRobot> počúvajúciMyš =
		new Vector<>();
	/*packagePrivate*/ final static Vector<GRobot> počúvajúciVstupnýRiadok =
		new Vector<>();
	/*packagePrivate*/ final static Vector<GRobot> počúvajúciRozhranie =
		new Vector<>();
	/*packagePrivate*/ final static Vector<GRobot> počúvajúciSystém =
		new Vector<>();
	/*packagePrivate*/ final static Vector<GRobot> počúvajúciSúbory =
		new Vector<>();


	// --------------------------- //
	//  *** Vlastnosti robota ***  //
	// --------------------------- //

		// Meno a registrácia robota

			// Meno tohto robota
			/*packagePrivate*/ String menoRobota = null;

			// Mená všetkých robotov
			/*packagePrivate*/ final static TreeMap<String, GRobot>
				menáRobotov = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);

			// Zamietnuté: Zvážiť definovanie metódy na vyhľadanie mena
			// podľa inštancie robota.
			// 
			// private static String nájdiMeno(GRobot r)
			// {
			// 	for (Map.Entry<String, GRobot>
			// 		záznam : menáRobotov.entrySet())
			// 	{
			// 		if (r == záznam.getValue())
			// 			return záznam.getKey();
			// 	}
			// 	return null;
			// }
			// 
			// Záver: To by bol riadny nezmysel, veď predsa každý robot
			// si svoje meno pamätá a na požiadanie ho vráti. Význam by
			// mala opačná metóda – na vyhľadanie vrátenie inštancie
			// robota podľa mena. Takáto metóda bola nakoniec definovaná
			// v triede Svet, keďže musela byť statická a dávalo väčší
			// zmysel jej umiestnenie v triede Svet, než v triede GRobot.
			// 
			// Jej použitie:
			// 
			//     GRobot r = dajRobot("meno robota");
			// 

			// Registrácia robota v systéme konfigurácie
			/*packagePrivate*/ boolean jeRegistrovaný = false;
				// Tento atribút je priamo používaný svetom…


		// Hrúbka čiary (polomer pera)

			// Predvolená hrúbka čiary
			private final static double predvolenýPolomerPera = 0.5;

			// Aktuálna hrúbka čiary
			/*packagePrivate*/ double polomerPera;

			// Čiara prevedená na Stroke
			/*packagePrivate*/ Stroke čiara;

		// Farby a nátery

			// Predvolená farba robota…
			private final static Farba predvolenáFarbaRobota = čierna;

			// Aktuálna farba robota, výplní, predvoleného tvaru…
			/*packagePrivate*/ Farba farbaRobota;

			// Cieľová farba prechodu (výplní vytváraných robotom) alebo
			// konca čiary kreslenej robotom…
			private Farba cieľováFarba = null;

			// Alternatívna výplň všetkého, čo robot kreslí…
			private Paint náter = null;

			// Príznak použitia kruhového náteru…
			private boolean použiKruhovýNáter = false;

		// Písmo

			// Predvolený typ písma
			private final static Písmo predvolenéPísmo =
				new Písmo("Helvetica", Písmo.PLAIN, 16.0);

			// Aktuálny typ písma
			/*packagePrivate*/ Písmo aktuálnePísmo;

		// Domov

			// Domovská pozícia a smer
			private double domaX = 0;
			private double domaY = 0;
			private double uholDoma = 90;

			// Zmena farby po návrate domov
			private Farba farbaDoma = null;

			// Zmena alebo zachovanie cieľovej farby po návrate domov
			private Farba cieľováFarbaDoma = null;

			// Zrušenie cieľovej farby po návrate domov
			private boolean zrušCieľovúFarbuDoma = false;

			// Zmena hrúbky pera po návrate domov
			private Double polomerPeraDoma = null;

			// Stav pera po návrate domov
			private Boolean peroPoloženéDoma = null;

			// Stav viditeľnosti po návrate domov
			private Boolean viditeľnýDoma = null;

			// Zmena veľkosti po návrate domov
			private Double veľkosťDoma = null;

			// Zmena pomeru po návrate domov
			private Double pomerDoma = null;

			// Zmena priehľadnosti robota po návrate domov
			private Float priehľadnosťDoma = null;

			// Zmena písma robota po návrate domov
			private Písmo písmoDoma = null;

			// Zmena pootočenia tvaru robota po návrate domov
			private Double pootočenieTvaruDoma = 0.0;

		// Aktuálny stav (základné vlastnosti)

			// Aktuálna poloha a smer
			/*packagePrivate*/ double aktuálneX;
			/*packagePrivate*/ double aktuálneY;
			/*packagePrivate*/ double aktuálnyUhol;

			// Posledná poloha a smer
			private double poslednéX;
			private double poslednéY;
			private double poslednýUhol;

			// Predvolený uhol otáčania bezparametrických príkazov vpravo/vľavo
			private double uholOtáčania = 45.0;

			// Aktuálne pootočenie tvaru
			private double pootočenieTvaru = 0.0;

			// Aktuálny stav pera
			/*packagePrivate*/ boolean peroPoložené = true;

			// Aktuálny stav viditeľnosti
			/*packagePrivate*/ boolean viditeľný = true;

		// Ohraničenie

			// Aktuálny spôsob ohraničenia
			private int aktuálneOhraničenie = ŽIADNE;

			// Záloha spôsobu ohraničenia
			private int zálohovanéOhraničenie = ŽIADNE;

			// Aktuálne hranice
			private double ľaváHranica = 0.0;
			private double dolnáHranica = 0.0;
			private double praváHranica = 0.0;
			private double hornáHranica = 0.0;

			// Záloha spôsobu ohraničenia počas jeho riešenia
			private int zálohaOhraničenia = ŽIADNE;

			// Záloha polohy a uhla na účely riešenia ohraničenia
			private double zálohaUhla = 90.0;
			// private double zálohaX = 0.0, zálohaY = 0.0;

			// Stav zachytávajúci zdrojovú a cieľovú polohu robota
			// a dotknutej hranice počas riešenia ohraničenia
			private final Bod[] stavMimoHraníc = new Bod[]
				{new Bod(), new Bod(), new Bod(), new Bod()};

			// Posunuté cieľové súradnice v rámci procesu riešenia ohraničenia
			private double novýCieľX = 0.0, novýCieľY = 0.0;

		// Veľkosť a kolízna oblasť

			// Veľkosť robota
			/*packagePrivate*/ double veľkosť = 10.0;

			// Hodnota „pôvodnej veľkosti“ (v skutočnosti „naposledy
			// zapamätanej veľkosti“) podľa ktorej sa prepočítava aktuálna
			// mierka robota. Tento atribút je menovateľom mierky. Aktuálna
			// veľkosť (atribút vyššie) je čitateľom mierky.
			private double pôvodnáVeľkosť = 10.0;

			// Číslo určujúce „pomer rozmerov niektorých tvarov (napr. elipsy
			// a obdĺžnika) generovaných robotom“ (je to číslo, ktoré má
			// vplyv len na tie metódy generovania dotknutých tvarov (t. j.
			// napr. elipsy a obdĺžnika), ktoré neprijímajú žiadny argument).
			private double pomerVeľkosti = 1.0;

			// Hodnota „pôvodného pomeru veľkosti robota“ (v skutočnosti
			// „naposledy zapamätaného pomeru veľkosti robota“) podľa ktorého
			// sa prepočítava aktuálna mierka pomeru veľkosti robota. Tento
			// atribút je menovateľom mierky pomeru a aktuálny pomer veľkosti
			// (atribút vyššie) je čitateľom tejto mierky.
			private double pôvodnýPomer = 1.0;

			// Horizontálne a vertikálne zaoblenie rohov štvorcov
			// a obdĺžnikov.
			private double zaoblenieX = 0.0;
			private double zaoblenieY = 0.0;

			// Oblasť na detekciu kolízií
			private Oblasť kolíznaOblasť = null;

		// Aktivita

			/*packagePrivate*/ static boolean aspoňJedenAktívny;

			private boolean aktívny = false;
			private double otáčanieTvaru = 0.0;
			private Double gyroskop = null;
			private double rýchlosť = 0.0;
			private double rýchlosťPosunu = 0.0;
			private double uhlováRýchlosť = 0.0;
			private double maximálnaRýchlosť = 0.0;
			private double maximálnaRýchlosťPosunu = 0.0;
			private double maximálnaUhlováRýchlosť = 0.0;
			private double zrýchlenie = 0.0;
			private double zrýchleniePosunu = 0.0;
			private double uhlovéZrýchlenie = 0.0;
			private int trvanieAktivity = 0;
			private int trvaniePasivity = 0;

			private boolean cieľAktívny = false;
			private boolean zastavVCieli = false;
			private boolean zastavPoSpomalení = false;
			private boolean zastavPoSpomaleníPosunu = false;
			private double cieľX = 0.0;
			private double cieľY = 0.0;

		// Pôsobisko

			private final static Farba farbaPôsobiska =
				new Farba(0, 0, 100, 40);
			private double minimálneX;
			private double minimálneY;
			private double maximálneX;
			private double maximálneY;
			/*packagePrivate*/ boolean kresliPôsobisko = false;

		// Vlastný tvar

			// Vyplnenosť základného tvaru
			private boolean vyplnený = false;

			// Obrázok
			private Image vlastnýTvarObrázok = null;

			// Kreslenie cez rozhranie
			private KreslenieTvaru vlastnýTvarKreslenie = null;

			// Príznak, že robot je v procese kreslenia vlastného tvaru
			// (metódy domov() menia svoju funkciu)
			private boolean kreslímVlastnýTvar = false;

			// Toto je statická inštancia vlastného tvaru používaná pri
			// prekrytí metódy robota kresliTvar()
			private final static KreslenieTvaru použiPrekrytúMetóduKresli =
				(r -> r.kresliTvar());

		// Úprava textu

			@SuppressWarnings("serial")
			/*packagePrivate*/ class UpravText extends JTextField
			{
				// Parametre polohy a veľkosti textového poľa
				private int x, y, šírka, výška;

				// Pomocný príznak
				private int polohaKurzora = 0;

				// Previaže textové pole s obsluhou udalostí
				private final KeyListener klávesStlačený = new KeyListener()
				{
					public void keyPressed(KeyEvent e)
					{
						// Umiestnenie týchto príkazov do reakcie
						// keyTyped nefungovalo v macOS (predtým OS X a Mac OS)
						if (e.getKeyChar() == KeyEvent.VK_ENTER)
						{
							ukončiÚpravu(SPÔSOB_ENTER);
						}
						else if (e.getKeyChar() == KeyEvent.VK_ESCAPE)
						{
							ukončiÚpravu(SPÔSOB_ESCAPE);
						}
						else if (e.getKeyChar() == KeyEvent.VK_TAB)
						{
							if (e.isShiftDown())
								ukončiÚpravu(SPÔSOB_SHIFT_TAB);
							else
								ukončiÚpravu(SPÔSOB_TAB);
						}
					}

					public void keyReleased(KeyEvent e) {}
					public void keyTyped(KeyEvent e) {}
				};

				private final FocusListener fokusZmenený = new FocusListener()
				{
					public void focusGained(FocusEvent e)
					{
						setCaretPosition(polohaKurzora);
					}

					public void focusLost(FocusEvent e)
					{
						if (isVisible()) ukončiÚpravu(SPÔSOB_DEAKTIVÁCIA);
					}
				};


				/*packagePrivate*/ void umiestni(
					int x1, int y1, int šírka1, int výška1)
				{
					int x0 = x1 + x;
					int y0 = y1 + y;

					setBounds(x0, y0, šírka, výška);
				}


				public UpravText()
				{
					super(10);

					x = y = 0;
					šírka = 100;
					výška = 10;

					setOpaque(false);
					setBorder(null);
					setBackground(null);

					setFocusTraversalKeysEnabled(false);

					addKeyListener(klávesStlačený);
					addFocusListener(fokusZmenený);
					setVisible(false);

					Svet.hlavnýPanel.add(this, 0);
				}

				public boolean začniÚpravu(String text,
					double šírkaPrvku, boolean žiadajZhodu)
				{
					// System.out.println("Text: " + text + ", šírka: " + šírkaPrvku + ", žiadaj zhodu: " + žiadajZhodu);

					if (isVisible()) return false;
					if (žiadajZhodu && !text.equals(getText())) return false;

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					setForeground(farbaRobota);
					setFont(aktuálnePísmo);
					FontMetrics rozmery = getFontMetrics(aktuálnePísmo);

					if (šírkaPrvku < 0)
						šírka = rozmery.stringWidth(text);
					else
						šírka = (int)šírkaPrvku;

					výška = rozmery.getHeight();
					double poklesTextu = ((rozmery.getDescent() * 3) / 2);

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						x = (int)prepočítanéX;
						y = (int)(prepočítanéY -
							poklesTextu - ((rozmery.getAscent() * 4) / 6));
						setHorizontalAlignment(JTextField.LEFT);
					}
					else
					{
						x = (int)(prepočítanéX - (šírka / 2.0));
						y = (int)(prepočítanéY /*+ poklesTextu*/
							// - (rozmery.getAscent() / 2)
							- ((rozmery.getAscent() * 4) / 6)
							);
						setHorizontalAlignment(JTextField.CENTER);
					}

					if (!text.equals(getText()))
					{
						setText(text);
						if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
							polohaKurzora = getText().length();
						else
							polohaKurzora = getText().length() / 2;
					}

					setVisible(true);
					Svet.hlavnýPanel.doLayout();

					SwingUtilities.invokeLater(() -> requestFocus());
					return true;
				}

				public boolean ukončiÚpravu(int spôsob)
				{
					if (!isVisible()) return false;
					polohaKurzora = getCaretPosition();
					ukončenieÚpravyTextu(getText(), spôsob);
					ukoncenieUpravyTextu(getText(), spôsob);
					setVisible(false);
					return true;
				}
			}

			private UpravText upravText[] = new UpravText[8];


		// Spojnice

			/**
			 * <p>Táto trieda slúži na uchovávanie a prístup k vlastnostiam
			 * čiarových spojníc, ktoré sú definovateľné medzi robotmi.
			 * Na vytváranie (prípane rušenie) spojníc slúžia výhradne metódy
			 * z <a href="kategorie-metod.html#GRobot-Spojnice">kategórie
			 * spojníc grafického robota.</a> Táto trieda poskytuje prístup
			 * k hodnotám jestvujúcich nastavení (vrátane poskytovania
			 * možnosti ich zmien) a tiež umožňuje nastavovať a čítať
			 * doplnkové vlastnosti spojníc, napríklad
			 * {@linkplain #vysunutie(double) vysunutie} alebo definovanie
			 * tvaru značky
			 * {@linkplain #definujZnačkuZačiatku(KreslenieTvaru)
			 * začiatku} a/alebo
			 * {@linkplain #definujZnačkuKonca(KreslenieTvaru) konca}
			 * čiary spojnice.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>Nasledujúci jednoduchý príklad ukazuje nielen vytvorenie
			 * spojníc a konfiguráciu ich vlastností, ale používa zároveň
			 * automatickú konfiguráciu sveta a obsluhu udalostí, vďaka ktorej
			 * je možné roboty na plátne presúvať myšou.</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdimport} knižnica.*;
				{@code kwdimport} {@code kwdstatic} knižnica.{@link Konštanty Konštanty}.*;

				{@code kwdpublic} {@code typeclass} TestovanieSpojníc
				{
					{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
					{
						{@code comm// Začiatok automatickej konfigurácie:}
						{@link Svet Svet}.{@link Svet#použiKonfiguráciu(String) použiKonfiguráciu}({@code srg"TestovanieSpojníc.cfg"});

						{@code comm// Definícia kreslenia vlastného tvaru robotov (elipsy s menom}
						{@code comm// robota v strede):}
						{@link KreslenieTvaru KreslenieTvaru} tvar = r -&gt;
						{
							r.{@link GRobot#elipsa(double) elipsa}({@code num2});
							r.{@link GRobot#text(String) text}(r.{@link GRobot#meno() meno}());
						};

						{@code comm// Definícia kreslenia koncových značiek čiar spojníc:}
						{@link KreslenieTvaru KreslenieTvaru} šípka = r -&gt;
						{
							r.{@link GRobot#vpravo(double) vpravo}({@code num30});
							r.{@link GRobot#dopredu(double) dopredu}({@code num10});
							r.{@link GRobot#zdvihniPero() zdvihniPero}();
							r.{@link GRobot#vzad(double) vzad}({@code num10});
							r.{@link GRobot#vľavo(double) vľavo}({@code num60});
							r.{@link GRobot#položPero() položPero}();
							r.{@link GRobot#dopredu(double) dopredu}({@code num10});
						};
						<hr/>
						{@code comm// Vytvorenie štyroch inštancií robotov, ktoré budú prepojené}
						{@code comm// spojnicami (prvý robot je hlavný, takže používame konštruktor,}
						{@code comm// ktorým zároveň nastavíme veľkosť plátien):}

						{@link GRobot GRobot} alfa = {@code kwdnew} {@link GRobot#GRobot(int, int) GRobot}({@code num400}, {@code num400})
						{{
							{@link GRobot#meno(String) meno}({@code srg"Alfa"});
							{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
							{@link GRobot#veľkosť(double) veľkosť}({@code num20});
							{@link GRobot#skočNa(double, double) skočNa}(-{@code num100}, {@code num100});
							{@link GRobot#nekresliTvary() nekresliTvary}();
						}};

						{@link GRobot GRobot} beta = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
						{{
							{@link GRobot#meno(String) meno}({@code srg"Beta"});
							{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
							{@link GRobot#veľkosť(double) veľkosť}({@code num30});
							{@link GRobot#skočNa(double, double) skočNa}({@code num100}, {@code num100});
							{@link GRobot#nekresliTvary() nekresliTvary}();
						}};

						{@link GRobot GRobot} gama = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
						{{
							{@link GRobot#meno(String) meno}({@code srg"Gama"});
							{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
							{@link GRobot#veľkosť(double) veľkosť}({@code num40});
							{@link GRobot#skočNa(double, double) skočNa}({@code num100}, -{@code num100});
							{@link GRobot#nekresliTvary() nekresliTvary}();
						}};

						{@link GRobot GRobot} delta = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
						{{
							{@link GRobot#meno(String) meno}({@code srg"Delta"});
							{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
							{@link GRobot#veľkosť(double) veľkosť}({@code num30});
							{@link GRobot#skočNa(double, double) skočNa}(-{@code num100}, -{@code num100});
							{@link GRobot#nekresliTvary() nekresliTvary}();
						}};

						{@code comm// Uloženie inštancií do zoznamu:}
						{@code kwdfinal} {@link Zoznam Zoznam}&lt;{@link GRobot GRobot}&gt; zoznam = {@code kwdnew} {@link Zoznam#Zoznam(Object...) Zoznam}&lt;{@link GRobot GRobot}&gt;(
							alfa, beta, gama, delta);
						<hr/>
						{@code comm// Vytvorenie (definovanie) spojníc a ich vlastností:}

						alfa.{@link GRobot#spojnica(GRobot, Shape, Shape) spojnica}(beta, alfa.{@link GRobot#elipsa(double) elipsa}({@code num2}), beta.{@link GRobot#elipsa(double) elipsa}({@code num2}))
							.{@link Spojnica#definujZnačkuKonca(KreslenieTvaru) definujZnačkuKonca}(šípka)
							.{@link Spojnica#vysunutie(double) vysunutie}({@code num10});

						beta.{@link GRobot#spojnica(GRobot, Shape, Shape) spojnica}(alfa, beta.{@link GRobot#elipsa(double) elipsa}({@code num2}), alfa.{@link GRobot#elipsa(double) elipsa}({@code num2}))
							.{@link Spojnica#definujZnačkuKonca(KreslenieTvaru) definujZnačkuKonca}(šípka)
							.{@link Spojnica#vysunutie(double) vysunutie}({@code num10});

						alfa.{@link GRobot#spojnica(GRobot, Shape, Shape) spojnica}(gama, alfa.{@link GRobot#elipsa(double) elipsa}({@code num2}), gama.{@link GRobot#elipsa(double) elipsa}({@code num2}))
							.{@link Spojnica#definujZnačkuZačiatku(KreslenieTvaru) definujZnačkuZačiatku}(šípka)
							.{@link Spojnica#definujZnačkuKonca(KreslenieTvaru) definujZnačkuKonca}(šípka);

						beta.{@link GRobot#spojnica(GRobot, Shape, Shape) spojnica}(delta, beta.{@link GRobot#elipsa(double) elipsa}({@code num2}), delta.{@link GRobot#elipsa(double) elipsa}({@code num2}))
							.{@link Spojnica#definujZnačkuZačiatku(KreslenieTvaru) definujZnačkuZačiatku}(šípka)
							.{@link Spojnica#definujZnačkuKonca(KreslenieTvaru) definujZnačkuKonca}(šípka);
						<hr/>
						{@code comm// Dokončenie automatickej konfigurácie a obsluha udalostí:}

						{@code kwdfor} ({@link GRobot GRobot} r : zoznam) r.{@link GRobot#registrujVKonfigurácii() registrujVKonfigurácii}();

						{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
						{
							{@link GRobot GRobot} aktívnyRobot = {@code valnull};

							{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#klik() klik}()
							{
								{@link GRobot#ťahanieMyšou() ťahanieMyšou}();
							}

							{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#stlačenieTlačidlaMyši() stlačenieTlačidlaMyši}()
							{
								aktívnyRobot = {@code valnull};
								{@code kwdfor} ({@link GRobot GRobot} r : zoznam) {@code kwdif} (r.{@link GRobot#myšVElipse(double) myšVElipse}({@code num2})) aktívnyRobot = r;
							}

							{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#ťahanieMyšou() ťahanieMyšou}()
							{
								{@code kwdif} ({@code valnull} != aktívnyRobot)
								{
									{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#myš() myš}().{@link MouseEvent#isShiftDown() isShiftDown}())
									{
										{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#tlačidloMyši(int) tlačidloMyši}({@link Konštanty#ĽAVÉ ĽAVÉ}))
											aktívnyRobot.{@link GRobot#otočNaMyš() otočNaMyš}();
									}
									{@code kwdelse}
									{
										{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#tlačidloMyši(int) tlačidloMyši}({@link Konštanty#ĽAVÉ ĽAVÉ}))
											aktívnyRobot.{@link GRobot#skočNaMyš() skočNaMyš}();
									}
								}
							}
						};
					}
				}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <p><image>spojnice.png<alt/>Ukážka spojníc.</image>Ukážka
			 * výsledku príkladu pri jeho prvom spustení.</p>
			 */
			public static class Spojnica
			{
				// Táto statická inštancia bude použitá na zisťovanie
				// polohy koncovej značky:
				private static BasicStroke čiaraNaPriesečníky =
					new BasicStroke(3.0F, BasicStroke.CAP_ROUND,
						BasicStroke.JOIN_ROUND);

				// Trieda uchovávajúca údaje o značkách na koncoch spojnice
				private class ZnačkaČiary
				{
					// Definícia kreslenia tvaru značky – kreslí sa
					// s pomocou súvisiacich robotov:
					private KreslenieTvaru kreslenie;

					// Definuje vlastné orezanie tohto konca spojnice pre
					// kreslenie oboch značiek (čiže odlišné orezanie od
					// toho, ktoré je použité na kreslenie samotnej spojnice):
					private Shape vlastnéOrezanie;

					// Určuje, či je táto značka koncová:
					private boolean koncová;


					// Súhrnné vysvetlenie k nasledujúcim atribútom:
						// Ak nie je aktuálne orezanie null, tak sa poloha
						// značky musí určiť podľa zadaného orezania
						// a aktuálnej polohy a orientácie robota. Algoritmus
						// nie je príliš efektívny (pracuje s prienikom
						// oblastí tvarov prevedených na ťahy), preto je
						// mierne optimalizovaný zálohovaním hodnôt
						// posledného orezania, polohy a orientácie.

					// Aktuálna poloha (buď je to kópia polohy súvisiacieho
					// robota, alebo poloha získaná algoritmicky – v prípade
					// aktívneho orezania) a smer (vypočítaný podľa smeru
					// spojnice) značky:
					private double polohaX, polohaY, uhol;

					// Posledné súvisiace hlavné orezanie (to jest to
					// orezanie, ktoré slúži na zíkanie polohy značky):
					private Area poslednéOrezanie;

					// Posledné polohy robota a cieľa:
					private double polohaRobotaX, polohaRobotaY,
						polohaCieľaX, polohaCieľaY;

					// Posledná orientácia robota:
					private double uholRobota;


					// Konštruktor
					private ZnačkaČiary(KreslenieTvaru kreslenie,
						Shape vlastnéOrezanie, boolean koncová)
					{
						this.kreslenie = kreslenie;
						this.koncová = koncová;
						vlastnéOrezanie(vlastnéOrezanie);

						poslednéOrezanie = null;
						polohaX = polohaY = uhol = 0;
						polohaRobotaX = polohaRobotaY =
							polohaCieľaX = polohaCieľaY = 0;
						uholRobota = 0;
					}


					/**
					 * <p>Nastaví alebo zruší vlastné orezanie tejto inštancie.</p>
					 */
					public void vlastnéOrezanie(Shape vlastnéOrezanie)
					{
						if (null == vlastnéOrezanie)
							this.vlastnéOrezanie = null;
						else if (koncová)
						{
							AffineTransform at = new AffineTransform();
							at.translate(-cieľ.aktuálneX,
								cieľ.aktuálneY);
							at.rotate(toRadians((cieľ.aktuálnyUhol +
									cieľ.pootočenieTvaru) - 90),
								Svet.prepočítajX(cieľ.aktuálneX),
								Svet.prepočítajY(cieľ.aktuálneY));

							this.vlastnéOrezanie = new Area(vlastnéOrezanie).
								createTransformedArea(at);
						}
						else
						{
							AffineTransform at = new AffineTransform();
							at.translate(-robot.aktuálneX,
								robot.aktuálneY);
							at.rotate(toRadians(
								(robot.aktuálnyUhol +
									robot.pootočenieTvaru) - 90),
								Svet.prepočítajX(robot.aktuálneX),
								Svet.prepočítajY(robot.aktuálneY));

							this.vlastnéOrezanie = new Area(vlastnéOrezanie).
								createTransformedArea(at);
						}
					}

					/**
					 * <p>Použije zadané orezanie na prípadný prepočet polohy
					 * kreslenia tejto značky.</p>
					 */
					public void vypočítajPolohu(Shape orezanie, Shape čiara)
					{
						if (koncová)
						{
							if (null != orezanie)
							{
								Area novéOrezanie = new Area(orezanie);
								if (null == poslednéOrezanie ||
									polohaRobotaX != robot.aktuálneX ||
									polohaRobotaY != robot.aktuálneY ||
									polohaCieľaX != cieľ.aktuálneX ||
									polohaCieľaY != cieľ.aktuálneY ||
									uholRobota != (cieľ.aktuálnyUhol +
										cieľ.pootočenieTvaru) ||
									!poslednéOrezanie.equals(novéOrezanie))
								{
									Area hľadaj = new Area(čiaraNaPriesečníky.
										createStrokedShape(novéOrezanie));
									hľadaj.intersect(new Area(
										čiaraNaPriesečníky.
											createStrokedShape(čiara)));

									if (hľadaj.isEmpty())
									{
										polohaX = cieľ.aktuálneX;
										polohaY = cieľ.aktuálneY;
									}
									else
									{
										Rectangle2D hranice =
											hľadaj.getBounds2D();

										polohaX = Svet.prepočítajSpäťX(
											hranice.getCenterX());
										polohaY = Svet.prepočítajSpäťY(
											hranice.getCenterY());
									}

									uhol = cieľ.smerNa(robot);
									poslednéOrezanie = novéOrezanie;

									polohaRobotaX = robot.aktuálneX;
									polohaRobotaY = robot.aktuálneY;
									uholRobota = (cieľ.aktuálnyUhol +
										cieľ.pootočenieTvaru);

									polohaCieľaX = cieľ.aktuálneX;
									polohaCieľaY = cieľ.aktuálneY;
								}
							}
							else
							{
								polohaX = cieľ.aktuálneX;
								polohaY = cieľ.aktuálneY;
								uhol = cieľ.smerNa(robot);
								poslednéOrezanie = null;
							}
						}
						else
						{
							if (null != orezanie)
							{
								Area novéOrezanie = new Area(orezanie);
								if (null == poslednéOrezanie ||
									polohaRobotaX != robot.aktuálneX ||
									polohaRobotaY != robot.aktuálneY ||
									polohaCieľaX != cieľ.aktuálneX ||
									polohaCieľaY != cieľ.aktuálneY ||
									uholRobota != (robot.aktuálnyUhol +
										robot.pootočenieTvaru) ||
									!poslednéOrezanie.equals(novéOrezanie))
								{
									Area hľadaj = new Area(čiaraNaPriesečníky.
										createStrokedShape(novéOrezanie));
									hľadaj.intersect(new Area(
										čiaraNaPriesečníky.
											createStrokedShape(čiara)));

									if (hľadaj.isEmpty())
									{
										polohaX = robot.aktuálneX;
										polohaY = robot.aktuálneY;
									}
									else
									{
										Rectangle2D hranice =
											hľadaj.getBounds2D();

										polohaX = Svet.prepočítajSpäťX(
											hranice.getCenterX());
										polohaY = Svet.prepočítajSpäťY(
											hranice.getCenterY());
									}

									uhol = robot.smerNa(cieľ);
									poslednéOrezanie = novéOrezanie;

									polohaRobotaX = robot.aktuálneX;
									polohaRobotaY = robot.aktuálneY;
									uholRobota = (robot.aktuálnyUhol +
										robot.pootočenieTvaru);

									polohaCieľaX = cieľ.aktuálneX;
									polohaCieľaY = cieľ.aktuálneY;
								}
							}
							else
							{
								polohaX = robot.aktuálneX;
								polohaY = robot.aktuálneY;
								uhol = robot.smerNa(cieľ);
								poslednéOrezanie = null;
							}
						}
					}

					/**
					 * <p>Zariadi volanie kreslenia tejto značky.</p>
					 */
					public void kresliZnačku(
						BufferedImage obrázok, Graphics2D grafika)
					{
						if (koncová)
						{
							boolean vráťKompozit = cieľ.priehľadnosť < 1.0;
							Composite záloha = null;

							double aktuálneX_Záloha = cieľ.aktuálneX;
							double aktuálneY_Záloha = cieľ.aktuálneY;
							double aktuálnyUhol_Záloha = cieľ.aktuálnyUhol;
							double pootočenieTvaru_Záloha =
								cieľ.pootočenieTvaru;

							// cieľ.poslednéX = aktuálneX; // nie‼
							// cieľ.poslednéY = aktuálneY; // nie‼
							// cieľ.poslednýUhol = aktuálnyUhol; // nie‼
							cieľ.aktuálneX = polohaX;
							cieľ.aktuálneY = polohaY;
							cieľ.aktuálnyUhol = uhol;
							cieľ.pootočenieTvaru = 0;

							kresliTvar(obrázok, grafika, cieľ, kreslenie);

							cieľ.aktuálneX = aktuálneX_Záloha;
							cieľ.aktuálneY = aktuálneY_Záloha;
							cieľ.aktuálnyUhol = aktuálnyUhol_Záloha;
							cieľ.pootočenieTvaru = pootočenieTvaru_Záloha;

							if (vráťKompozit) grafika.setComposite(záloha);
						}
						else
						{
							boolean vráťKompozit = robot.priehľadnosť < 1.0;
							Composite záloha = null;

							double aktuálneX_Záloha = robot.aktuálneX;
							double aktuálneY_Záloha = robot.aktuálneY;
							double aktuálnyUhol_Záloha = robot.aktuálnyUhol;
							double pootočenieTvaru_Záloha =
								robot.pootočenieTvaru;

							// robot.poslednéX = aktuálneX; // nie‼
							// robot.poslednéY = aktuálneY; // nie‼
							// robot.poslednýUhol = aktuálnyUhol; // nie‼
							robot.aktuálneX = polohaX;
							robot.aktuálneY = polohaY;
							robot.aktuálnyUhol = uhol;
							robot.pootočenieTvaru = 0;

							kresliTvar(obrázok, grafika, robot, kreslenie);

							robot.aktuálneX = aktuálneX_Záloha;
							robot.aktuálneY = aktuálneY_Záloha;
							robot.aktuálnyUhol = aktuálnyUhol_Záloha;
							robot.pootočenieTvaru = pootočenieTvaru_Záloha;

							if (vráťKompozit) grafika.setComposite(záloha);
						}
					}
				}

				// Značka kreslená na začiatku a konci čiary:
				private ZnačkaČiary značkaZačiatku = null, značkaKonca = null;

				// Príznak viditeľnosti:
				private boolean viditeľná = true;

				/**
				 * <p>Parametre rôzneho druhu asociované s touto spojnicou.</p>
				 * 
				 * <p>Na mierne zjednodušenie práce s touto mapou boli
				 * definované dve metódy spojnice: {@link #parameter(String)
				 * parameter(index)} a {@link #parameter(String, Object)
				 * parameter(index, hodnota)}.</p>
				 */
				public final TreeMap<String, Object> parametre = new TreeMap<>();

				/**
				 * <p>Vráti hodnotu parametra asociovanú so zadaným indexom.
				 * Ak je hodnota indexu rovná {@code valnull}, tak metóda
				 * vráti {@code valnull}. Ak parameter nie je definovaný, tak
				 * metóda tiež vráti {@code valnull}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Keďže prístup
				 * k {@linkplain #parametre mape parametrov spojnice} je
				 * verejný, programátor môže do nej vkladať ľubovoľné hodnoty
				 * parametrov, vrátane prázdnych ({@code valnull}). Stavy,
				 * kedy parameter nejestvuje a kedy je jeho hodnota rovná
				 * {@code valnull} nie je možné touto metódou rozlíšiť. Na to
				 * treba použiť metódu {@link TreeMap#containsKey(Object)
				 * parameter.containsKey(index)}.</p>
				 * 
				 * @param index index asociovaný s hodnotou parametra
				 * @return hodnota parametra, ak je nastavená alebo
				 *     {@code valnull}
				 */
				public Object parameter(String index)
				{
					if (null == index) return null;
					return parametre.get(index);
				}

				/**
				 * <p>Nastaví alebo vymaže hodnotu parametra asociovanú so
				 * zadaným indexom. Ak je hodnota indexu rovná {@code valnull},
				 * tak metóda nevykoná nič. Ak je hodnota parametra rovná
				 * {@code valnull}, tak ho metóda zo zoznamu parametrov
				 * vymaže.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Prístup
				 * k {@linkplain #parametre mape parametrov spojnice} je
				 * verejný. Vďaka tomu môže do nej programátor vkladať
				 * ľubovoľné hodnoty parametrov, vrátane prázdnych
				 * ({@code valnull}), avšak potom sa musí riadiť pravidlami
				 * práce s mapou {@link TreeMap TreeMap}.</p>
				 * 
				 * @param index index asociovaný s hodnotou parametra
				 * @param hodnota nová hodnota parametra, ak má byť parameter
				 *     nastavený alebo {@code valnull}, ak má byť parameter
				 *     vymazaný
				 */
				public void parameter(String index, Object hodnota)
				{
					if (null == index) return;
					if (null == hodnota) parametre.remove(index);
					else parametre.put(index, hodnota);
				}


				/**
				 * <p>Vráti implementované rozhranie {@linkplain KreslenieTvaru
				 * kreslenia tvaru} začiatočnej značky čiary spojnice alebo
				 * {@code valnull}, ak začiatočná značka nie je definovaná.</p>
				 * 
				 * @return implementácia rozhrania vlastného tvaru
				 *     zabezpečujúca kreslenie začiatočnej značky spojnice
				 *     alebo {@code valnull}, ak značka nemá byť kreslená
				 */
				public KreslenieTvaru dajZnačkuZačiatku()
				{
					if (null == značkaZačiatku) return null;
					return značkaZačiatku.kreslenie;
				}

				/** <p><a class="alias"></a> Alias pre {@link #dajZnačkuZačiatku() dajZnačkuZačiatku}.</p> */
				public KreslenieTvaru dajZnackuZaciatku()
				{ return dajZnačkuZačiatku(); }

				/**
				 * <p>Vráti implementované rozhranie {@linkplain KreslenieTvaru
				 * kreslenia tvaru} koncovej značky čiary spojnice alebo
				 * {@code valnull}, ak koncová značka nie je definovaná.</p>
				 * 
				 * @return implementácia rozhrania vlastného tvaru
				 *     zabezpečujúca kreslenie koncovej značky spojnice
				 *     alebo {@code valnull}, ak značka nemá byť kreslená
				 */
				public KreslenieTvaru dajZnačkuKonca()
				{
					if (null == značkaKonca) return null;
					return značkaKonca.kreslenie;
				}

				/** <p><a class="alias"></a> Alias pre {@link #dajZnačkuKonca() dajZnačkuKonca}.</p> */
				public KreslenieTvaru dajZnackuKonca()
				{ return dajZnačkuKonca(); }


				/**
				 * <p>Definuje začiatočnú značku čiary spojnice s pomocou
				 * rozhrania, ktoré v programovacom rámci zároveň slúži na
				 * definovanie vlastného tvaru robota. Hodnota {@code valnull}
				 * znamená, že značka začiatku spojnice nemá byť kreslená.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@code comm// Vytvorenie dvoch robotov:}
					{@link GRobot GRobot} robotA = {@code kwdnew} {@link GRobot GRobot}();
					{@link GRobot GRobot} robotB = {@code kwdnew} {@link GRobot GRobot}();

					{@code comm// Definície tvarov (objektov kreslenia tvaru):}
					{@link KreslenieTvaru KreslenieTvaru} tvarRobotov = r -> r.{@link GRobot#krúžok() krúžok}();
					{@link KreslenieTvaru KreslenieTvaru} tvarŠípky = r ->
					{
						r.{@link GRobot#vpravo(double) vpravo}({@code num30});
						r.{@link GRobot#vpred(double) vpred}(r.{@link GRobot#veľkosť() veľkosť}() / {@code num2});

						r.{@link GRobot#domov() domov}();

						r.{@link GRobot#vľavo(double) vľavo}({@code num30});
						r.{@link GRobot#vpred(double) vpred}(r.{@link GRobot#veľkosť() veľkosť}() / {@code num2});
					};

					{@code comm// Priradenie tvarov robotom:}
					robotA.{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvarRobotov);
					robotB.{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvarRobotov);

					{@code comm// Úprava veľkostí, polôh a vypnutie kreslenia tvarov robotmi:}

					robotA.{@link GRobot#veľkosť(double) veľkosť}({@code num40});
					robotB.{@link GRobot#veľkosť(double) veľkosť}({@code num60});

					robotA.{@link GRobot#skoč(double, double) skoč}({@code num50}, {@code num80});
					robotB.{@link GRobot#skoč(double, double) skoč}(-{@code num50}, -{@code num80});

					robotA.{@link GRobot#nekresliTvary() nekresliTvary}();
					robotB.{@link GRobot#nekresliTvary() nekresliTvary}();

					{@code comm// Definícia novej spojnice s tvarmi jej orezania a značkami začiatku}
					{@code comm// a konca. Metódy spojnica, definujZnačkuZačiatku a definujZnačkuKonca}
					{@code comm// sú zreťazené: Keďže návratovou hodnotou metódy spojnica je objekt}
					{@code comm// spojnice, dá sa na neho priamo nadviazať volaním metódy}
					{@code comm// definujZnačuZačiatku a keďže aj jej návratovou hodnotou je ten istý}
					{@code comm// objekt, dá sa na to opäť nadviazať volaním metódy definujZnačkuKonca.}
					robotA.{@link GRobot#spojnica(GRobot, Shape, Shape) spojnica}(robotB, robotA.{@link GRobot#krúžok() krúžok}(), robotB.{@link GRobot#krúžok() krúžok}())
						.{@link Spojnica#definujZnačkuZačiatku(KreslenieTvaru) definujZnačkuZačiatku}(tvarŠípky)
						.{@link Spojnica#definujZnačkuKonca(KreslenieTvaru) definujZnačkuKonca}(tvarŠípky);

					{@code comm// Toto zreťazenie by sme mohli rozpísať takto:}
					{@code comm// 	Spojnica spojnica = robotA.spojnica(robotB,}
					{@code comm// 		robotA.krúžok(), robotB.krúžok());}
					{@code comm// 	spojnica.definujZnačkuZačiatku(tvarŠípky);}
					{@code comm// 	spojnica.definujZnačkuKonca(tvarŠípky);}
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>definuj-znacky-spojnice.png<alt/>Výsledné
				 * zobrazenie príkladu definície vlastných značiek
				 * spojnice.</image>Výsledné zobrazenie príkladu definície
				 * vlastných značiek spojnice.</p>
				 * 
				 * @param kreslenie inštancia implementácie vlastného tvaru,
				 *     ktorá zabezpečí nakreslenie začiatočnej značky spojnice
				 *     alebo {@code valnull} ak značka nemá byť kreslená
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica definujZnačkuZačiatku(KreslenieTvaru kreslenie)
				{
					if (null == kreslenie) značkaZačiatku = null;
					else značkaZačiatku = new ZnačkaČiary(
						kreslenie, null, false);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #definujZnačkuZačiatku(KreslenieTvaru) definujZnačkuZačiatku}.</p> */
				public Spojnica definujZnackuZaciatku(KreslenieTvaru kreslenie)
				{ return definujZnačkuZačiatku(kreslenie); }

				/**
				 * <p>Definuje koncovú značku čiary spojnice s pomocou
				 * rozhrania, ktoré v programovacom rámci zároveň slúži na
				 * definovanie vlastného tvaru robota. Hodnota {@code valnull}
				 * znamená, že značka konca spojnice nemá byť kreslená.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Príklad použitia definície
				 * koncovej aj začiatočnej značky spojnice je v opise metódy
				 * {@link #definujZnačkuZačiatku(KreslenieTvaru)
				 * definujZnačkuZačiatku}.</p>
				 * 
				 * @param kreslenie inštancia implementácie vlastného tvaru,
				 *     ktorá zabezpečí nakreslenie koncovej značky spojnice
				 *     alebo {@code valnull} ak značka nemá byť kreslená
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica definujZnačkuKonca(KreslenieTvaru kreslenie)
				{
					if (null == kreslenie) značkaKonca = null;
					else značkaKonca = new ZnačkaČiary(kreslenie, null, true);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #definujZnačkuKonca(KreslenieTvaru) definujZnačkuKonca}.</p> */
				public Spojnica definujZnackuKonca(KreslenieTvaru kreslenie)
				{ return definujZnačkuKonca(kreslenie); }


				/**
				 * <p>Definuje začiatočnú značku čiary spojnice s pomocou
				 * rozhrania, ktoré v programovacom rámci zároveň slúži na
				 * definovanie vlastného tvaru robota a s vlastným spôsobom
				 * orezania (ktoré sa vzťahuje aj na prípadnú koncovú značku).
				 * Hodnota {@code valnull} parametra {@code kreslenie} znamená,
				 * že značka začiatku spojnice nemá byť kreslená, ale v tom
				 * prípade stráca hodnota parametra {@code vlastnéOrezanie}
				 * akýkoľvek ďalší zmysel. Inak určuje parameter
				 * {@code vlastnéOrezanie} vlastný tvar orezania kreslenia
				 * oboch značiek, ktorý má byť odlišný od orezania kreslenia
				 * čiary samotnej spojnice. Hodnota {@code valnull} parametra
				 * {@code vlastnéOrezanie} hovorí, že pri kreslení značiek
				 * má byť použité rovnaké orezanie ako pri kreslení čiary
				 * spojnice.</p>
				 * 
				 * <p>Podrobnejšie informácie o značkách začiatku a konca
				 * spojnice sú v opise metódy
				 * {@link #definujZnačkuZačiatku(KreslenieTvaru)
				 * definujZnačkuZačiatku}.</p>
				 * 
				 * <p>Vlastné orezanie je podrobnejšie vysvetlené v opise
				 * metódy {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku}
				 * (resp. {@link #upravOrezanieZnačkyKonca(Shape)
				 * upravOrezanieZnačkyKonca}).</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Príklad použitia
				 * definície začiatočnej a koncovej značky spojnice je v opise
				 * metódy {@link #definujZnačkuZačiatku(KreslenieTvaru)
				 * definujZnačkuZačiatku} a príklad použitia vlastného
				 * orezania začiatočnej a koncovej značky je v opise metódy
				 * {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku}.</p>
				 * 
				 * <p class="tip"><b>Tip:</b> ak chcete druhý parameter využiť
				 * na orezanie kreslenia koncovej značky, ale nekresliť žiadnu
				 * začiatočnú značku, tak implementujte <b>a použite</b>
				 * prázdne rozhranie kreslenia tvaru – to jest také, ktoré
				 * jestvuje, ale nič nekreslí.</p>
				 * 
				 * @param kreslenie inštancia implementácie vlastného tvaru,
				 *     ktorá zabezpečí nakreslenie začiatočnej značky spojnice
				 *     alebo {@code valnull} ak značka nemá byť kreslená –
				 *     v takom prípade stráca hodnota ďalšieho parametra význam
				 * @param vlastnéOrezanie dovoľuje definovať vlastné orezanie
				 *     kreslenia značiek; ak je {@code valnull}, tak je použité
				 *     orezanie, ktoré bolo definované na kreslenie samotnej
				 *     čiary spojnice
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica definujZnačkuZačiatku(KreslenieTvaru kreslenie,
					Shape vlastnéOrezanie)
				{
					if (null == kreslenie) značkaZačiatku = null;
					else značkaZačiatku = new ZnačkaČiary(
						kreslenie, vlastnéOrezanie, false);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #definujZnačkuZačiatku(KreslenieTvaru, Shape) definujZnačkuZačiatku}.</p> */
				public Spojnica definujZnackuZaciatku(KreslenieTvaru kreslenie,
					Shape vlastnéOrezanie)
				{ return definujZnačkuZačiatku(kreslenie, vlastnéOrezanie); }

				/**
				 * <p>Definuje koncovú značku čiary spojnice s pomocou
				 * rozhrania, ktoré v programovacom rámci zároveň slúži na
				 * definovanie vlastného tvaru robota a s vlastným spôsobom
				 * orezania (ktoré sa vzťahuje aj na prípadnú začiatočnú
				 * značku). Hodnota {@code valnull} znamená, že značka konca
				 * spojnice nemá byť kreslená, ale v tom prípade stráca hodnota
				 * parametra {@code vlastnéOrezanie} akýkoľvek ďalší zmysel.
				 * Inak určuje parameter {@code vlastnéOrezanie} vlastný tvar
				 * orezania kreslenia oboch značiek, ktorý má byť odlišný od
				 * orezania kreslenia čiary samotnej spojnice. Hodnota
				 * {@code valnull} parametra {@code vlastnéOrezanie} hovorí,
				 * že pri kreslení značiek má byť použité rovnaké orezanie ako
				 * pri kreslení čiary spojnice.</p>
				 * 
				 * <p>Podrobnejšie informácie o značkách konca aj začiatku
				 * spojnice sú v opise metódy
				 * {@link #definujZnačkuZačiatku(KreslenieTvaru)
				 * definujZnačkuZačiatku}.</p>
				 * 
				 * <p>Vlastné orezanie je podrobnejšie vysvetlené v opise
				 * metódy {@link #upravOrezanieZnačkyKonca(Shape)
				 * upravOrezanieZnačkyKonca}
				 * (resp. {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku}).</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Príklad použitia
				 * definície koncovej aj začiatočnej značky spojnice je v opise
				 * metódy {@link #definujZnačkuZačiatku(KreslenieTvaru)
				 * definujZnačkuZačiatku} a príklad použitia vlastného
				 * orezania koncovej aj začiatočnej značky je v opise metódy
				 * {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku}.</p>
				 * 
				 * <p class="tip"><b>Tip:</b> ak chcete druhý parameter využiť
				 * na orezanie kreslenia začiatočnej značky, ale nekresliť
				 * žiadnu koncovú značku, tak implementujte <b>a použite</b>
				 * prázdne rozhranie kreslenia tvaru – to jest také, ktoré
				 * jestvuje, ale nič nekreslí.</p>
				 * 
				 * @param kreslenie inštancia implementácie vlastného tvaru,
				 *     ktorá zabezpečí nakreslenie koncovej značky spojnice
				 *     alebo {@code valnull} ak značka nemá byť kreslená –
				 *     v takom prípade stráca hodnota ďalšieho parametra význam
				 * @param vlastnéOrezanie dovoľuje definovať vlastné orezanie
				 *     kreslenia značiek; ak je {@code valnull}, tak je použité
				 *     orezanie, ktoré bolo definované na kreslenie samotnej
				 *     čiary spojnice
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica definujZnačkuKonca(KreslenieTvaru kreslenie,
					Shape vlastnéOrezanie)
				{
					if (null == kreslenie) značkaKonca = null;
					else značkaKonca = new ZnačkaČiary(
						kreslenie, vlastnéOrezanie, true);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #definujZnačkuKonca(KreslenieTvaru, Shape) definujZnačkuKonca}.</p> */
				public Spojnica definujZnackuKonca(KreslenieTvaru kreslenie,
					Shape vlastnéOrezanie)
				{ return definujZnačkuKonca(kreslenie, vlastnéOrezanie); }


				/**
				 * <p>Vráti inštanciu {@linkplain Shape tvaru} vlastného orezania
				 * značiek pri začiatku čiary spojnice alebo {@code valnull},
				 * ak je použité rovnaké orezanie ako pri kreslení samotnej
				 * spojnice.</p>
				 * 
				 * @return inštancia tvaru určujúca vlastné orezanie značiek
				 *     pri začiatku spojnice alebo {@code valnull}, ak má byť
				 *     použité rovnaké orezanie ako pri kreslení samotnej
				 *     spojnice
				 */
				public Shape dajOrezanieZnačkyZačiatku()
				{
					if (null == značkaZačiatku) return null;
					return značkaZačiatku.vlastnéOrezanie;
				}

				/** <p><a class="alias"></a> Alias pre {@link #dajOrezanieZnačkyZačiatku() dajOrezanieZnačkyZačiatku}.</p> */
				public Shape dajOrezanieZnackyZaciatku()
				{ return dajOrezanieZnačkyZačiatku(); }

				/**
				 * <p>Vráti inštanciu {@linkplain Shape tvaru} vlastného orezania
				 * značiek pri konci čiary spojnice alebo {@code valnull},
				 * ak je použité rovnaké orezanie ako pri kreslení samotnej
				 * spojnice.</p>
				 * 
				 * @return inštancia tvaru určujúca vlastné orezanie značiek
				 *     pri konci spojnice alebo {@code valnull}, ak má byť
				 *     použité rovnaké orezanie ako pri kreslení samotnej
				 *     spojnice
				 */
				public Shape dajOrezanieZnačkyKonca()
				{
					if (null == značkaKonca) return null;
					return značkaKonca.vlastnéOrezanie;
				}

				/** <p><a class="alias"></a> Alias pre {@link #dajOrezanieZnačkyKonca() dajOrezanieZnačkyKonca}.</p> */
				public Shape dajOrezanieZnackyKonca()
				{ return dajOrezanieZnačkyKonca(); }


				/**
				 * <p>Umožňuje zmeniť spôsob orezania značiek pri začiatku
				 * spojnice.</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Volanie tejto metódy nemá
				 * význam ak nie je definované {@linkplain 
				 * #definujZnačkuZačiatku(KreslenieTvaru) kreslenie značky
				 * začiatku}! Hodnota {@code valnull} znamená, že má byť
				 * použité rovnaké orezanie ako pri kreslení samotnej čiary
				 * spojnice.</p>
				 * 
				 * <p class="tip"><b>Tip:</b> Ak chcete použiť vlastné orezanie
				 * kreslenia značiek pri začiatku spojnice, a pritom
				 * nekresliť žiadnu začiatočnú značku, tak implementujte
				 * <b>a použite</b> prázdne rozhranie kreslenia tvaru – to
				 * jest také, ktoré jestvuje, ale nič nekreslí.</p>
				 * 
				 * <p><image>vlastne-orezanie.png<alt/>Vysvetlenie princípu
				 * vlastného orezania.</image>Ukážka využitia vlastného
				 * orezania<br /><small>(podrobnejšie vysvetlenie je
				 * nižšie)</small>.</p>
				 * 
				 * <p>Obrázok vyššie ukazuje dve situácie používajúce vlastné
				 * orezanie značiek začiatku a konca. Obrázok poskytuje pohľad
				 * na detail časti scény, ktorej úplná zmenšená verzia je
				 * vložená do rámčeka v pravej hornej časti obrázka. Obrázok
				 * je výsledkom riešenia zadania, ktoré určovalo, že elipsa
				 * A má mať značku spojnice (v tvare krúžka) kreslenú
				 * z vonkajšej strany a elipsa B naopak z vnútornej strany
				 * svojho tvaru.</p>
				 * 
				 * <p>Elipsa A musí mať nastavené väčšie rozmery orezania než
				 * sú jej vlastné rozmery, aby bola čiara spojnice kreslená
				 * ďalej od okraja elipsy. Rozmer orezania spojnice pri tejto
				 * elipse naznačuje oranžová čiara nakreslená v detailnom
				 * pohľade. Ak by nejestvovala možnosť nastavenia vlastného
				 * orezania značky, tak by značku nebolo vidno, lebo všetko za
				 * hranicou oranžovej čiary by bolo orezané (vrátane značky).
				 * Značka musí mať nastavené vlastné orezanie totožné
				 * s rozmermi elipsy (prípadne <em>prázdne orezanie</em> –
				 * <b>prázdnu oblasť orezania,</b> avšak pozor, to neznamená
				 * hodnotu {@code valnull}; hodnota {@code valnull} by opäť
				 * znamenala orezanie totožné s hlavným orezaním, čiže na
				 * úrovni oranžovej čiary; <b>prázdnu oblasť</b> vytvoríte
				 * napríklad príkazom {@code kwdnew} {@link 
				 * Oblasť#Oblasť() Oblasť}{@code ()} alebo spustením
				 * metódy {@link Oblasť#vymaž() vymaž} pre jestvujúcu
				 * oblasť).</p>
				 * 
				 * <p>Elipsa B musí mať nastavené rovnaké rozmery orezania
				 * ako sú jej vlastné rozmery, aby sa čiara spojnice končila
				 * presne na jej hraniciach. Ak by nejestvovala možnosť
				 * nastavenia vlastného orezania značky, tak by značku takmer
				 * nebolo vidno, lebo by bola z väčšej časti „ponorená“
				 * vo vnútri oblasti, ktorá je orezaná. Aby bola celá značka
				 * viditeľná, musí mať nastavené menšie rozmery orezania,
				 * napríklad také, ktoré sú na obrázku naznačené žltou
				 * čiarou (prípadne sa dá použiť <em>prázdna oblasť
				 * orezania</em> tak ako pri elipse A, pričom to opäť
				 * neznamená vloženie hodnoty {@code valnull} namiesto
				 * oblasti vlastného orezania, ale <em>jestvujúcej oblasti
				 * bez geometrie</em>).</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Nasledujúci úryvok kódu ukazuje jednoduchý spôsob
				 * riešenia rovnakej úlohy akú znázorňuje obrázok a opisuje
				 * text vyššie (tesne nad týmto príkladom).</p>
				 * 
				 * <pre CLASS="example">
					{@code comm// Definovanie konštánt – veľkosť robotov, veľkosti značiek a pomer}
					{@code comm// medzi šírkou a výškou elipsy, ktorá bude tvarom robotov:}
					{@code kwdfinal} {@code typedouble} veľkosťRobota = {@code num50.0};
					{@code kwdfinal} {@code typedouble} veľkosťZnačky = {@code num12.5};
					{@code kwdfinal} {@code typedouble} pomer = {@code num2.5};
					<hr/>
					{@code comm// Definícia tvaru robotov:}
					{@link KreslenieTvaru KreslenieTvaru} tvar = r -&gt;
					{
						r.{@link GRobot#elipsa(double) elipsa}(pomer);
						r.{@link GRobot#text(String) text}(r.{@link GRobot#meno() meno}());
					};

					{@code comm// Definícia tvaru značiek:}
					{@link KreslenieTvaru KreslenieTvaru} značka = r -&gt;
					{
						r.{@link GRobot#zdvihniPero() zdvihniPero}();
						r.{@link GRobot#vzad(double) vzad}(veľkosťZnačky);
						r.{@link GRobot#kružnica(double) kružnica}(veľkosťZnačky);
					};
					<hr/>
					{@code comm// Definícia prvého robota (A):}
					{@link GRobot GRobot} A = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
					{{
						{@link GRobot#meno(String) meno}({@code srg"A"});
						{@link GRobot#veľkosť(double) veľkosť}(veľkosťRobota);
						{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
						{@link GRobot#nekresliTvary() nekresliTvary}();

						{@link GRobot#skoč(double, double) skoč}(-{@code num180}, {@code num150});
					}};

					{@code comm// Definícia druhého robota (B):}
					{@link GRobot GRobot} B = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
					{{
						{@link GRobot#meno(String) meno}({@code srg"B"});
						{@link GRobot#veľkosť(double) veľkosť}(veľkosťRobota);
						{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
						{@link GRobot#nekresliTvary() nekresliTvary}();

						{@link GRobot#skoč(double, double) skoč}({@code num180}, -{@code num150});
					}};
					<hr/>
					{@code comm// Definícia spojnice so začiatkom v robote (elipse) A a koncom}
					{@code comm// v robote (elipse) B:}
					A.{@link GRobot#spojnica(GRobot, Shape, Shape) spojnica}(B,

						{@code comm// Orezanie začiatku spojnice – elipsa, ktorá je väčšia oproti}
						{@code comm// kreslenému tvaru:}
						A.{@link GRobot#elipsa(double, double) elipsa}(pomer * A.{@link GRobot#veľkosť() veľkosť}() + veľkosťZnačky * {@code num2.0},
							A.{@link GRobot#veľkosť() veľkosť}() + veľkosťZnačky * {@code num2.0}),

						{@code comm// Orezanie konca spojnice – elipsa, ktorá je totožná s kresleným}
						{@code comm// tvarom:}
						B.{@link GRobot#elipsa(double) elipsa}(pomer))

						{@code comm// Definícia značky na začiatku spojnice s vlastným tvarom}
						{@code comm// orezania (elipsou totožnou s kresleným tvarom):}
						.{@link Spojnica#definujZnačkuZačiatku(KreslenieTvaru, Shape) definujZnačkuZačiatku}(značka, A.{@link GRobot#elipsa(double) elipsa}(pomer))

						{@code comm// Definícia značky na konci spojnice s vlastným tvarom}
						{@code comm// orezania (elipsou menšou oproti kreslenému tvaru):}
						.{@link Spojnica#definujZnačkuKonca(KreslenieTvaru, Shape) definujZnačkuKonca}(značka,
							B.{@link GRobot#elipsa(double, double) elipsa}(pomer * B.{@link GRobot#veľkosť() veľkosť}() &#45; veľkosťZnačky * {@code num2.0},
								B.{@link GRobot#veľkosť() veľkosť}() &#45; veľkosťZnačky * {@code num2.0}));
					</pre>
				 * 
				 * @param vlastnéOrezanie vlastné orezanie kreslenia značiek
				 *     pri začiatku spojnice alebo {@code valnull}, ak má
				 *     byť použité rovnaké orezanie, aké je definované pre
				 *     kreslenie samotnej čiary spojnice
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica upravOrezanieZnačkyZačiatku(
					Shape vlastnéOrezanie)
				{
					if (null != značkaZačiatku)
						značkaZačiatku.vlastnéOrezanie(vlastnéOrezanie);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravOrezanieZnačkyZačiatku(Shape) upravOrezanieZnačkyZačiatku}.</p> */
				public Spojnica upravOrezanieZnackyZaciatku(
					Shape vlastnéOrezanie)
				{ return upravOrezanieZnačkyZačiatku(vlastnéOrezanie); }

				/**
				 * <p>Umožňuje zmeniť spôsob orezania značiek pri začiatku
				 * spojnice.</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Volanie tejto metódy nemá
				 * význam ak nie je definované {@linkplain 
				 * #definujZnačkuKonca(KreslenieTvaru) kreslenie značky
				 * konca}! Hodnota {@code valnull} znamená, že má byť použité
				 * rovnaké orezanie ako pri kreslení samotnej čiary spojnice.</p>
				 * 
				 * <p class="tip"><b>Tip:</b> Ak chcete použiť vlastné orezanie
				 * kreslenia značiek pri konci spojnice, a pritom
				 * nekresliť žiadnu koncovú značku, tak implementujte
				 * <b>a použite</b> prázdne rozhranie kreslenia tvaru – to
				 * jest také, ktoré jestvuje, ale nič nekreslí.</p>
				 * 
				 * <p><image>vlastne-orezanie.png<alt/>Vysvetlenie princípu
				 * vlastného orezania.</image>Ukážka využitia vlastného
				 * orezania<br /><small>(podrobnejšie vysvetlenie je
				 * v opise metódy {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku} pod identickým
				 * obrázkom.)</small>.</p>
				 * 
				 * <p>Obrázok vyššie ukazuje dve situácie používajúce vlastné
				 * orezanie značiek začiatku a konca. Obrázok poskytuje pohľad
				 * na detail časti scény, ktorej úplná zmenšená verzia je
				 * vložená do rámčeka v pravej hornej časti obrázka. Obrázok
				 * je výsledkom riešenia zadania, ktoré určovalo, že elipsa
				 * A má mať značku spojnice (v tvare krúžka) kreslenú
				 * z vonkajšej strany a elipsa B naopak z vnútornej strany
				 * svojho tvaru. Podrobnejšie vysvetlenie je v opise metódy
				 * {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku} (<small>pod identickým
				 * obrázkom</small>).</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Príklad použitia vlastného
				 * orezania koncovej aj začiatočnej značky je v opise metódy
				 * {@link #upravOrezanieZnačkyZačiatku(Shape)
				 * upravOrezanieZnačkyZačiatku}.</p>
				 * 
				 * @param vlastnéOrezanie vlastné orezanie kreslenia značiek
				 *     pri konci spojnice alebo {@code valnull}, ak má byť
				 *     použité rovnaké orezanie, aké je definované pre
				 *     kreslenie samotnej čiary spojnice
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica upravOrezanieZnačkyKonca(
					Shape vlastnéOrezanie)
				{
					if (null != značkaKonca)
						značkaKonca.vlastnéOrezanie(vlastnéOrezanie);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravOrezanieZnačkyKonca(Shape) upravOrezanieZnačkyKonca}.</p> */
				public Spojnica upravOrezanieZnackyKonca(
					Shape vlastnéOrezanie)
				{ return upravOrezanieZnačkyKonca(vlastnéOrezanie); }


				// Zdrojový a cieľový robot
				/*packagePrivate*/ GRobot robot, cieľ;

				// Štýl čiary
				private Stroke čiara;

				// Farby začiatku a konca čiary spojnice
				private Farba farba, farbaKonca;

				// Začiatočný a koncový tvar (oblasť) orezania
				private Shape orezanieZačiatku, orezanieKonca;

				// Vysunutie začiatku a konca spojnice od ich stredov
				private double vysunutieZačiatku, vysunutieKonca;


				// Úplný konštruktor (prijímajúci objekt Color)
				private Spojnica(Color farba, Color farbaKonca, Stroke čiara,
					GRobot robot, GRobot cieľ, Shape orezanieZačiatku,
					Shape orezanieKonca)
				{
					if (null == farba)
						this.farba = null;
					else if (farba instanceof Farba)
						this.farba = (Farba)farba;
					else
						this.farba = new Farba(farba);

					if (null == farbaKonca)
						this.farbaKonca = null;
					else if (farbaKonca instanceof Farba)
						this.farbaKonca = (Farba)farbaKonca;
					else
						this.farbaKonca = new Farba(farbaKonca);

					this.čiara = čiara;
					this.robot = robot;
					this.cieľ = cieľ;

					// boolean nekresli_Záloha = Svet.nekresli;
					// Svet.nekresli = true;
					spracujOrezanieZačiatku(orezanieZačiatku);
					spracujOrezanieKonca(orezanieKonca);
					// Svet.nekresli = nekresli_Záloha;
				}


				// Spracuje orezanie začiatku spojnice
				private void spracujOrezanieZačiatku(Shape orezanieZačiatku)
				{
					if (null == orezanieZačiatku)
						this.orezanieZačiatku = null;
					else
					{
						AffineTransform at = new AffineTransform();
						at.translate(-robot.aktuálneX,
							robot.aktuálneY);
						at.rotate(toRadians(
							(robot.aktuálnyUhol + robot.pootočenieTvaru) - 90),
							Svet.prepočítajX(robot.aktuálneX),
							Svet.prepočítajY(robot.aktuálneY));

						this.orezanieZačiatku = new Area(orezanieZačiatku).
							createTransformedArea(at);
					}
				}

				// Spracuje orezanie konca spojnice
				private void spracujOrezanieKonca(Shape orezanieKonca)
				{
					if (null == orezanieKonca)
						this.orezanieKonca = null;
					else
					{
						AffineTransform at = new AffineTransform();
						at.translate(-cieľ.aktuálneX,
							cieľ.aktuálneY);
						at.rotate(toRadians(
							(cieľ.aktuálnyUhol + cieľ.pootočenieTvaru) - 90),
							Svet.prepočítajX(cieľ.aktuálneX),
							Svet.prepočítajY(cieľ.aktuálneY));

						this.orezanieKonca = new Area(orezanieKonca).
							createTransformedArea(at);
					}
				}


				/**
				 * <p>Prepočíta a vráti aktuálny tvar úsečky tejto spojnice.
				 * Metóda je použiteľná napríklad pri exporte spojníc do
				 * formátu {@linkplain SVGPodpora SVG}.</p>
				 * 
				 * @return aktuálny tvar úsečky spojnice
				 */
				public Line2D.Double tvar()
				{
					double začiatokX, začiatokY, koniecX, koniecY;

					if (null != orezanieZačiatku || null != orezanieKonca)
					{
						Area oblasťZačiatku;

						if (null != orezanieZačiatku)
						{
							oblasťZačiatku = new Area(orezanieZačiatku);

							if ((robot.aktuálnyUhol +
								robot.pootočenieTvaru) != 90 ||
								robot.aktuálneX != 0 ||
								robot.aktuálneY != 0)
							{
								AffineTransform at = new AffineTransform();
								at.rotate(toRadians(
									90 - (robot.aktuálnyUhol +
										robot.pootočenieTvaru)),
									Svet.prepočítajX(robot.aktuálneX),
									Svet.prepočítajY(robot.aktuálneY));
								at.translate(robot.aktuálneX,
									-robot.aktuálneY);
								oblasťZačiatku = oblasťZačiatku.
									createTransformedArea(at);
							}
						}
						else oblasťZačiatku = null;

						Area oblasťKonca;

						if (null != orezanieKonca)
						{
							oblasťKonca = new Area(orezanieKonca);

							if ((cieľ.aktuálnyUhol +
								cieľ.pootočenieTvaru) != 90 ||
								cieľ.aktuálneX != 0 ||
								cieľ.aktuálneY != 0)
							{
								AffineTransform at = new AffineTransform();
								at.rotate(toRadians(
									90 - (cieľ.aktuálnyUhol +
										cieľ.pootočenieTvaru)),
									Svet.prepočítajX(cieľ.aktuálneX),
									Svet.prepočítajY(cieľ.aktuálneY));
								at.translate(cieľ.aktuálneX,
									-cieľ.aktuálneY);
								oblasťKonca = oblasťKonca.
									createTransformedArea(at);
							}
						}
						else oblasťKonca = null;

						Line2D.Double čiaraSpojnice;

						if (0 == vysunutieZačiatku &&
							0 == vysunutieKonca)
							čiaraSpojnice = new Line2D.Double(
								Svet.prepočítajX(začiatokX = robot.aktuálneX),
								Svet.prepočítajY(začiatokY = robot.aktuálneY),
								Svet.prepočítajX(koniecX = cieľ.aktuálneX),
								Svet.prepočítajY(koniecY = cieľ.aktuálneY));
						else
						{
							double α = toRadians(robot.smerNa(cieľ) - 90);
							double Δx1 = cos(α) * vysunutieZačiatku;
							double Δy1 = sin(α) * vysunutieZačiatku;
							double Δx2 = cos(α) * vysunutieKonca;
							double Δy2 = sin(α) * vysunutieKonca;

							čiaraSpojnice = new Line2D.Double(
								Svet.prepočítajX(začiatokX = robot.aktuálneX + Δx1),
								Svet.prepočítajY(začiatokY = robot.aktuálneY + Δy1),
								Svet.prepočítajX(koniecX = cieľ.aktuálneX + Δx2),
								Svet.prepočítajY(koniecY = cieľ.aktuálneY + Δy2));
						}

						if (null != oblasťZačiatku)
						{
							if (null != značkaZačiatku)
							{
								značkaZačiatku.vypočítajPolohu(
									oblasťZačiatku, čiaraSpojnice);
								začiatokX = značkaZačiatku.polohaX;
								začiatokY = značkaZačiatku.polohaY;
							}
							else
							{
								ZnačkaČiary značka =
									new ZnačkaČiary(null, null, false);
								značka.vypočítajPolohu(
									oblasťZačiatku, čiaraSpojnice);
								začiatokX = značka.polohaX;
								začiatokY = značka.polohaY;
							}
						}

						if (null != oblasťKonca)
						{
							if (null != značkaKonca)
							{
								značkaKonca.vypočítajPolohu(
									oblasťKonca, čiaraSpojnice);
								koniecX = značkaKonca.polohaX;
								koniecY = značkaKonca.polohaY;
							}
							else
							{
								ZnačkaČiary značka =
									new ZnačkaČiary(null, null, true);
								značka.vypočítajPolohu(
									oblasťKonca, čiaraSpojnice);
								koniecX = značka.polohaX;
								koniecY = značka.polohaY;
							}
						}
					}
					else
					{
						Line2D.Double čiaraSpojnice;

						if (0 == vysunutieZačiatku &&
							0 == vysunutieKonca)
							čiaraSpojnice = new Line2D.Double(
								Svet.prepočítajX(začiatokX = robot.aktuálneX),
								Svet.prepočítajY(začiatokY = robot.aktuálneY),
								Svet.prepočítajX(koniecX = cieľ.aktuálneX),
								Svet.prepočítajY(koniecY = cieľ.aktuálneY));
						else
						{
							double α = toRadians(robot.smerNa(cieľ) - 90);
							double Δx1 = cos(α) * vysunutieZačiatku;
							double Δy1 = sin(α) * vysunutieZačiatku;
							double Δx2 = cos(α) * vysunutieKonca;
							double Δy2 = sin(α) * vysunutieKonca;

							čiaraSpojnice = new Line2D.Double(
								Svet.prepočítajX(začiatokX = robot.aktuálneX + Δx1),
								Svet.prepočítajY(začiatokY = robot.aktuálneY + Δy1),
								Svet.prepočítajX(koniecX = cieľ.aktuálneX + Δx2),
								Svet.prepočítajY(koniecY = cieľ.aktuálneY + Δy2));
						}
					}

					return new Line2D.Double(
						Svet.prepočítajX(začiatokX), Svet.prepočítajY(začiatokY),
						Svet.prepočítajX(koniecX), Svet.prepočítajY(koniecY));
				}


				/**
				 * <p>Vráti inštanciu zdrojového robota, čiže toho, od ktorého
				 * smeruje táto spojnica.</p>
				 * 
				 * @return inštancia zdrojového robota – toho, od ktorého
				 *     smeruje spojnica
				 */
				public GRobot zdroj()
				{
					return robot;
				}


				/**
				 * <p>Vráti inštanciu cieľového robota, čiže toho, ku ktorému
				 * smeruje táto spojnica.</p>
				 * 
				 * @return inštancia cieľového robota – toho, ku ktorému
				 *     smeruje spojnica
				 */
				public GRobot cieľ()
				{
					return cieľ;
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ() cieľ}.</p> */
				public GRobot ciel()
				{
					return cieľ;
				}


				/**
				 * <p>Vráti objekt typu (implementáciu rozhrania) {@link Stroke
				 * Stroke} určujúcu viaceré vlastnosti čiary. Je vysoká
				 * pravdepodobnosť, že vrátená implementácia je typu
				 * {@link BasicStroke BasicStroke}, ktorá umožňuje zistiť
				 * {@linkplain BasicStroke#getLineWidth() hrúbku čiary},
				 * {@linkplain BasicStroke#getEndCap() štýl ukončenia
				 * čiary}, {@linkplain BasicStroke#getLineJoin() štýl
				 * spojov lomených čiar},
				 * {@linkplain BasicStroke#getDashArray() pole hodnôt
				 * určujúcich čiarkovanú čiaru} a podobne.</p>
				 * 
				 * @return implementácia rozhrania {@link Stroke Stroke}
				 *     určujúca viaceré vlastnosti čiary
				 */
				public Stroke čiara()
				{
					return čiara;
				}

				/** <p><a class="alias"></a> Alias pre {@link #čiara() čiara}.</p> */
				public Stroke ciara()
				{
					return čiara;
				}

				/**
				 * <p>Umožňuje určiť nový štýl čiary prostredníctvom implementácie
				 * rozhrania {@link Stroke Stroke}. Základnou implementáciou
				 * je trieda {@link BasicStroke BasicStroke}, ktorá umožňuje
				 * definovať značné množstvo vlastností čiary. (Nazložitejší
				 * konštruktor uvedenej triedy prijíma {@linkplain 
				 * BasicStroke#BasicStroke(float, int, int, float,
				 * float[], float) hrúbku čiary, štýl ukončenia čiary, štýl
				 * spojov lomených čiar, limit dĺžky špičiek ostrých hrán,
				 * pole hodnôt určujúcich čiarkovanú čiaru a fázu čiarkovanej
				 * čiary}.)</p>
				 * 
				 * @param čiara štýl čiary určenej implementáciou rozhrania
				 *     {@link Stroke Stroke}, napríklad {@link BasicStroke
				 *     BasicStroke}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica čiara(Stroke čiara)
				{
					if (null == čiara)
						this.čiara = null;
					else
						this.čiara = čiara;
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #čiara(Stroke) čiara}.</p> */
				public Spojnica ciara(Stroke čiara)
				{
					return čiara(čiara);
				}


				/**
				 * <p>Vráti hrúbku čiary poskytnutú aktuálnym štýlom čiary. Ak
				 * hrúbka nie je zistiteľná, tak metóda vráti hodnotu
				 * {@code num-1}.</p>
				 * 
				 * @return hrúbka čiary (podľa aktuálneho štýlu čiary) alebo
				 *     {@code num-1}
				 */
				public double hrúbkaČiary()
				{
					if (null == čiara) return -1;
					if (čiara instanceof BasicStroke)
						return ((BasicStroke)čiara).getLineWidth();
					return -1;
				}

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaČiary() hrúbkaČiary}.</p> */
				public double hrubkaCiary()
				{
					return hrúbkaČiary();
				}

				/**
				 * <p>Určí novú hrúbku čiary spojnice. Ak je zadaná záporná
				 * hodnota, tak spojnica počas kreslenia prevezme hrúbku
				 * (resp. aj štýl) čiary zdrojového robota spojnice.</p>
				 * 
				 * @param hrúbkaČiary nová hrúbka čiary, prípadne záporná
				 *     hodnota, ak má byť štýl čiary zdedený od hlavného robota
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica hrúbkaČiary(double hrúbkaČiary)
				{
					this.čiara = (hrúbkaČiary < 0) ? null : new BasicStroke(
						(float)hrúbkaČiary, BasicStroke.CAP_ROUND,
						BasicStroke.JOIN_ROUND);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaČiary(double) hrúbkaČiary}.</p> */
				public Spojnica hrubkaCiary(double hrúbkaČiary)
				{
					return hrúbkaČiary(hrúbkaČiary);
				}


				/**
				 * <p>Vráti aktuálnu farbu začiatku čiary spojnice alebo
				 * hodnotu {@code valnull}, ak je farba zdedená od zdrojového
				 * robota.</p>
				 * 
				 * @return aktuálna farba začiatku čiary spojnice alebo
				 *     {@code valnull}
				 */
				public Farba farba()
				{
					return farba;
				}

				/**
				 * <p>Určuje novú farbu začiatku čiary spojnice. Metóda
				 * prijíma aj hodnotu {@code valnull}. V takom prípade bude
				 * farba spojnice počas kreslenia prevzatá od zdrojového
				 * robota.</p>
				 * 
				 * @param farba nová farba začiatku spojnice alebo {@code valnull}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica farba(Color farba)
				{
					if (null == farba)
						this.farba = null;
					else if (farba instanceof Farba)
						this.farba = (Farba)farba;
					else
						this.farba = new Farba(farba);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/**
				 * <p>Určuje novú farbu začiatku čiary spojnice prostredníctvom
				 * objektu, ktorý implementuje rozhranie {@link Farebnosť
				 * Farebnosť}.
				 * Metóda prijíma aj hodnotu {@code valnull}. V takom prípade
				 * bude farba spojnice počas kreslenia prevzatá od zdrojového
				 * robota.</p>
				 * 
				 * @param objekt objekt určujúci novú farbu začiatku spojnice
				 *     alebo {@code valnull}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica farba(Farebnosť objekt)
				{
					if (null == objekt)
						farba = null;
					else
						farba = objekt.farba();
					Svet.automatickéPrekreslenie();
					return this;
				}


				/**
				 * <p>Vráti farbu ukončenia čiary spojnice (slúžiacej na vytvorenie
				 * farebného prechodu) alebo hodnotu {@code valnull}, ak je farba
				 * určená automaticky.</p>
				 * 
				 * @return farba ukončenia čiary spojnice alebo {@code valnull}
				 */
				public Farba farbaKonca()
				{
					return farbaKonca;
				}

				/**
				 * <p>Určuje farbu ukončenia čiary spojnice. Táto farba bude v prípade
				 * nezhody so začiatočnou farbou použitá na vytvorenie farebného
				 * prechodu pri kreslení spojnice. Metóda prijíma aj hodnotu
				 * {@code valnull}. V takom prípade bude farba ukončenia
				 * spojnice prevzatá od cieľového robota.</p>
				 * 
				 * @param farba farba ukončenia spojnice alebo {@code valnull}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica farbaKonca(Color farba)
				{
					if (null == farba)
						this.farbaKonca = null;
					else if (farba instanceof Farba)
						this.farbaKonca = (Farba)farba;
					else
						this.farbaKonca = new Farba(farba);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/**
				 * <p>Určuje farbu ukončenia čiary spojnice prostredníctvom objektu,
				 * ktorý implementuje rozhranie {@link Farebnosť Farebnosť}.
				 * Táto farba bude v prípade nezhody so začiatočnou farbou použitá
				 * na vytvorenie farebného prechodu pri kreslení spojnice. Metóda
				 * prijíma aj hodnotu {@code valnull}. V takom prípade bude farba
				 * ukončenia spojnice prevzatá od cieľového robota.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@code valsuper}({@code num350}, {@code num250});
					{@link GRobot#skry() skry}();

					{@code comm// Definovanie konštánt – veľkosť robotov, veľkosti značiek a pomer}
					{@code comm// medzi šírkou a výškou elipsy, ktorá bude tvarom robotov:}
					{@code kwdfinal} {@code typedouble} veľkosťRobota = {@code num25.0};
					{@code kwdfinal} {@code typedouble} veľkosťZnačky = {@code num6.0};
					{@code kwdfinal} {@code typedouble} pomer = {@code num2.5};
					<hr/>
					{@code comm// Definícia tvaru robotov:}
					{@link KreslenieTvaru KreslenieTvaru} tvar = r -&gt;
					{
						r.{@link GRobot#elipsa(double) elipsa}(pomer);
						r.{@link GRobot#text(String) text}(r.{@link GRobot#meno() meno}());
					};

					{@code comm// Definícia prvého robota:}
					{@link GRobot GRobot} štart = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
					{{
						{@link GRobot#meno(String) meno}({@code srg"Štart"});
						{@link GRobot#veľkosť(double) veľkosť}(veľkosťRobota);
						{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
						{@link GRobot#nekresliTvary() nekresliTvary}();
						{@link GRobot#farba(Color) farba}({@link Farebnosť#modrá modrá});
						{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num3});
						{@link GRobot#písmo(String, double) písmo}({@code srg"Arial"}, {@code num28});

						{@link GRobot#skoč(double, double) skoč}(-{@code num90}, {@code num75});
					}};

					{@code comm// Definícia druhého robota:}
					{@link GRobot GRobot} koniec = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
					{{
						{@link GRobot#meno(String) meno}({@code srg"Koniec"});
						{@link GRobot#veľkosť(double) veľkosť}(veľkosťRobota);
						{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
						{@link GRobot#nekresliTvary() nekresliTvary}();
						{@link GRobot#farba(Color) farba}({@link Farebnosť#purpurová purpurová});
						{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num3});
						{@link GRobot#písmo(String, double) písmo}({@code srg"Arial"}, {@code num28});

						{@link GRobot#skoč(double, double) skoč}({@code num90}, -{@code num75});
					}};
					<hr/>
					{@code comm// Definícia spojnice:}
					{@link Spojnica Spojnica} spojnica = štart.{@link GRobot#spojnica(GRobot) spojnica}(koniec,

						{@code comm// Orezanie spojnice:}
						štart.{@link GRobot#elipsa(double) elipsa}(pomer), koniec.{@link GRobot#elipsa(double) elipsa}(pomer)

					{@code comm// Zrušenie predvolených farieb, aby sa}
					{@code comm// zhodovali s farbami prepájaných robotov:}
					).{@link Spojnica#farba(Color) farba}(({@link Farba Farba}){@code valnull}).{@link Spojnica#farbaKonca(Color) farbaKonca}(({@link Farba Farba}){@code valnull});
					<hr/>
					{@code comm// Počiatočné čakanie tri sekundy:}
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num3.0});

					{@code comm// Zmena farieb a orientácie prvého robota:}
					štart.{@link GRobot#farba(Color) farba}({@link Farebnosť#zelená zelená});
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num1.5});
					štart.{@link GRobot#cieľováFarba(Color) cieľováFarba}({@link Farebnosť#žltá žltá});
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num1.5});
					štart.{@link GRobot#vpravo(double) vpravo}({@code num30});
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num1.5});

					{@code comm// Zmena farieb a orientácie druhého robota:}
					koniec.{@link GRobot#farba(Color) farba}({@link Farebnosť#červená červená});
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num1.5});
					koniec.{@link GRobot#cieľováFarba(Color) cieľováFarba}({@link Farebnosť#oranžová oranžová});
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num1.5});
					koniec.{@link GRobot#vľavo(double) vľavo}({@code num30});
					{@link Svet Svet}.{@link Svet#čakaj(double) čakaj}({@code num1.5});

					{@code comm// Nastavenie vlastných farieb spojnice:}
					spojnica.{@link GRobot#farba(Color) farba}({@link Farebnosť#svetlomodrá svetlomodrá}.{@link Farba#bledšia() bledšia}()).{@link Spojnica#farbaKonca(Color) farbaKonca}({@link Farebnosť#tyrkysová tyrkysová});
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <table class="centered">
				 * <tr><td><image>spojnica-s-prechodom-01.png<alt/></image></td>
				 * <td><image>spojnica-s-prechodom-02.png<alt/></image></td>
				 * <td><image>spojnica-s-prechodom-03.png<alt/></image></td></tr>
				 * <tr><td><image>spojnica-s-prechodom-04.png<alt/></image></td>
				 * <td><image>spojnica-s-prechodom-05.png<alt/></image></td>
				 * <td><image>spojnica-s-prechodom-06.png<alt/></image></td></tr>
				 * <tr><td><image>spojnica-s-prechodom-07.png<alt/></image></td>
				 * <td><image>spojnica-s-prechodom-08.png<alt/></image></td></tr>
				 * </table>
				 * 
				 * <p class="image">Jednotlivé fázy
				 * vykonania programu – zmeny farebnosti v scéne so spojnicou
				 * postupujú od úplne automatického určenia farebnosti oboch
				 * koncov spojnice, cez farebné prispôsobenie robotov až po
				 * individuálne zafarbenie koncov samotnej spojnice.</p>
				 * 
				 * @param objekt objekt určujúci farbu ukončenia spojnice alebo
				 *     {@code valnull}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica farbaKonca(Farebnosť objekt)
				{
					if (null == objekt)
						farbaKonca = null;
					else
						farbaKonca = objekt.farba();
					Svet.automatickéPrekreslenie();
					return this;
				}


				// /** <p>ZAVRHNUTÉ<br />
					//  * Vráti tvar orezania začiatku spojnice alebo {@code valnull},
					//  * ak orezanie nebolo definované. Orezanie začiatku (i konca)
					//  * čiary spojnice má význam vo viacerých prípadoch –
					//  * podrobnosti sú v opise metódy {@link #orežZačiatok(Shape)
					//  * orežZačiatok(orezanieZačiatku}.</p>
					//  * 
					//  * @return tvar orezania začiatku spojnice alebo
					//  *     {@code valnull}
					//  */
					// public Shape orežZačiatok()
					// {
					// 	return orezanieZačiatku;
					// }
					// 
					// /** <p><a class="alias"></a> Alias pre {@link #orežZačiatok() orežZačiatok}.</p> */
					// public Shape orezZaciatok()
					// {
					// 	return orezanieZačiatku;
					// }
					// 
					// /**
					//  * <p>Vráti tvar orezania konca spojnice alebo {@code valnull},
					//  * ak orezanie nebolo definované. Orezanie konca (i začiatku)
					//  * čiary spojnice má význam vo viacerých prípadoch –
					//  * podrobnosti sú v opise metódy {@link #orežKoniec(Shape)
					//  * orežKoniec(orezanieKonca}.</p>
					//  * 
					//  * @return tvar orezania začiatku spojnice alebo
					//  *     {@code valnull}
					//  */
					// public Shape orežKoniec()
					// {
					// 	return orezanieKonca;
					// }
					// 
					// /** <p><a class="alias"></a> Alias pre {@link #orežKoniec() orežKoniec}.</p> */
					// public Shape orezKoniec()
					// {
					// 	return orezanieKonca;
					// }

				/**
				 * <p>Vráti tvar orezania začiatku spojnice alebo {@code valnull},
				 * ak orezanie nebolo definované. Orezanie začiatku (i konca)
				 * čiary spojnice má význam vo viacerých prípadoch –
				 * podrobnosti sú v opise metódy {@link #orezanieZačiatku(Shape)
				 * orezanieZačiatku(orezanieZačiatku)}.</p>
				 * 
				 * @return tvar orezania začiatku spojnice alebo
				 *     {@code valnull}
				 */
				public Shape orezanieZačiatku()
				{
					return orezanieZačiatku;
				}

				/** <p><a class="alias"></a> Alias pre {@link #orezanieZačiatku() orezanieZačiatku}.</p> */
				public Shape orezanieZaciatku()
				{
					return orezanieZačiatku;
				}

				/**
				 * <p>Vráti tvar orezania konca spojnice alebo {@code valnull},
				 * ak orezanie nebolo definované. Orezanie konca (i začiatku)
				 * čiary spojnice má význam vo viacerých prípadoch –
				 * podrobnosti sú v opise metódy {@link #orezanieKonca(Shape)
				 * orezanieKonca(orezanieKonca}.</p>
				 * 
				 * @return tvar orezania začiatku spojnice alebo
				 *     {@code valnull}
				 */
				public Shape orezanieKonca()
				{
					return orezanieKonca;
				}

				/**
				 * <p>Definuje tvar orezania začiatku spojnice. Ak je zadaná
				 * hodnota {@code valnull}, tak bude orezanie zrušené.
				 * Orezanie začiatku (i konca) čiary spojnice má význam vo
				 * viacerých prípadoch. Napríklad, ak chceme kresliť
				 * priehľadný tvar robota a zároveň chceme, aby sa čiara
				 * spojnice začínala na jeho hraniciach alebo potrebujeme
				 * kresliť
				 * {@linkplain #definujZnačkuZačiatku(KreslenieTvaru)
				 * značku začiatku} čiary spojnice presne na hraniciach
				 * tvaru robota. Tvar orezania by sme v týchto prípadoch
				 * volili tak, aby vymedzoval hranice objektu, ktorý robot
				 * reprezentuje svojím tvarom.</p>
				 * 
				 * <p>Pri definovaní orezania je dôležité vedieť niekoľko
				 * informácií, aby nevznikali chybné orezania alebo chybné
				 * umiestňovanie značiek spojníc. V tomto odseku sú
				 * vysvetľované príčiny a technické detaily (ak ich
				 * nepotrebujete alebo nechcete vedieť, môžete tento odsek
				 * preskočiť) a v nasledujúcich odsekoch sú opísané dôsledky
				 * a vyslovené odporúčania. Orezanie sa deje s pomocou
				 * tvarov Javy, ktoré sa skladajú z menších častí (čiara,
				 * krivka, posunutie…) a sú za normálnych okolností
				 * „nepohyblivé.“ Na to, aby bolo orezanie použiteľné, je
				 * nevyhnutné tvary „rozhýbať.“ To sa deje s pomocou
				 * geometrických transformácií. Každý tvar orezania je pri
				 * použití transformovaný podľa aktuálneho smeru a polohy
				 * robota umiestneného na prislúchajúcom zakončení spojnice.
				 * Do tohto procesu vstupuje ešte jeden fakt. Každý tvar
				 * vygenerovaný robotom je ešte pri jeho generovaní umiestnený
				 * a pootočený podľa aktuálnej polohy a smeru robota, ktorý
				 * ho vygeneroval. Preto, aby orezanie mohlo správne fungovať,
				 * musí byť každý tvar pri definovaní nového alebo
				 * aktualizovaní jestvujúceho orezania spojnice transformovaný
				 * do neutrálnej polohy a smeru. Objekt tvaru neobsahuje
				 * informáciu o tom, ktorý robot ho vygeneroval, ani o tom,
				 * akú polohu a orientáciu vtedy ten robot mal. Preto sú
				 * tvary transformované podľa toho robota, ktorý prislúcha
				 * súvisiacemu zakončeniu spojnice – začiatočné orezanie podľa
				 * začiatočného robota spojnice a koncové podľa koncového.
				 * Orezania by tiež mali pokrývať celú plochu tvaru robotov,
				 * inak sa môžu pri výslednom zobrazení spojnice kresliť
				 * nežiadúce úseky spojnice a tiež môže nastať chybné
				 * umiestnenie značiek spojnice. (Podrobnosti sú nižšie.)</p>
				 * 
				 * <p>Na základe informácií z predchádzajúceho odseku je
				 * dôležité, aby tvar orezania začiatku spojnice bol
				 * vygenerovaný začiatočným robotom (to jest robotom, z ktorého
				 * spojnica vychádza) a tvar orezania konca koncovým robotom
				 * (to jest tým, v ktorom spojnica končí). Na nasledujúcich
				 * dvoch animovaných obrázkoch je znázornená spojnica, ktorá
				 * nie je orezaná (vľavo) a spojnica, ktorá bola správne
				 * orezaná (vpravo) – tvar orezania začiatku (A) bol
				 * vygenerovaný začiatočným robotom ({@code srg"A"}) a tvar
				 * orezania konca (B) bol vygenerovaný koncovým (cieľovým)
				 * robotom ({@code srg"B"}).</p>
				 * 
				 * <table class="centered">
				 * <tr><td><image>spojnica-bez-orezania.gif<alt/></image></td>
				 * <td><image>spojnica-spravne-orezanie.gif<alt/></image></td></tr>
				 * <tr><td><p class="image">Spojnica bez orezania.</p></td>
				 * <td><p class="image">Správne orezaná spojnica.</p></td></tr>
				 * </table>
				 * 
				 * <p>Nasledujúce dva animované obrázky ukazujú dve rôzne
				 * situácie nesprávneho orezania.</p>
				 * 
				 * <p>Na obrázku vľavo sú použité tri rozmery orezania,
				 * ktoré nie je zhodné s tvarom robota (neprekrýva sa s ním).
				 * V prvých dvoch prípadoch nezasahuje orezanie stred tvaru
				 * prislúchajúceho robota, čo je príčinou toho, že sa
				 * v určitých fázach animácie spojnica rozdelí na dve časti
				 * a to zároveň spôsobuje chybné zobrazenie značky spojnice
				 * (šípky). Orezanie je totiž zároveň používané pri zisťovaní
				 * umiestnenia krajných značiek spojnice. Používa sa pri tom
				 * operácia prieniku tvaru orezania s čiarou spojnice. Ak je
				 * prienik zložitý, tak nemôže byť správne určené umiestnenie
				 * značky spojnice.</p>
				 * 
				 * <p>Na obrázku vpravo bol na definovanie začiatočného
				 * orezania použitý koncový robot a naopak. Tvar orezania je
				 * za normálnych okolností neviditeľný. Aby bolo jasné, čo
				 * sa deje, sú tvary orezania na tomto obrázku zobrazené
				 * tenkými elipsami. Orezanie spojnice je správne v jednom
				 * jedinom okamihu animácie a to presne v tom, v ktorom bolo
				 * definované. Ak sa jeden z robotov pohne, orezanie prestane
				 * správne fungovať.</p>
				 * 
				 * <table class="centered">
				 * <tr><td><image>spojnica-nespravne-orezanie-1.gif<alt/></image></td>
				 * <td><image>spojnica-nespravne-orezanie-2.gif<alt/></image></td></tr>
				 * <tr><td><p class="image">Nesprávne orezaná spojnica<br
				 * /><small>(tvar, ktorý neprechádza stredom)</small>.</p></td>
				 * <td><p class="image">Nesprávne orezaná spojnica<br
				 * /><small>(zámena robotov, ktorí generovali
				 * orezanie)</small>.</p></td></tr>
				 * </table>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Tento príklad ukazuje spôsob definovania dvoch robotov
				 * v tvare hviezdy prepojených správne orezanou spojnicou,
				 * ktorej jeden koniec má definovanú značku v tvare šípky.
				 * Oba roboty je možné presúvať a otáčať s pomocou myši.
				 * Na otáčanie robota je potrebné držať stlačený kláves
				 * {@code Shift}.</p>
				 * 
				 * <pre CLASS="example">
					{@code comm// Konštanta veľkostí robotov:}
					{@code kwdfinal} {@code typedouble} veľkosťRobota = {@code num66.0};
					<hr/>
					{@code comm// Kreslenie tvaru šípky, ktorá bude tvoriť značku spojnice:}
					{@code kwdfinal} {@link KreslenieTvaru KreslenieTvaru} šípka = r -&gt;
					{
						r.{@link GRobot#vpravo(double) vpravo}({@code num20});
						r.{@link GRobot#vpred(double) vpred}({@code num12});
						{@link Poloha Poloha} p = r.{@link GRobot#poloha() poloha}();
						r.{@link GRobot#zdvihniPero() zdvihniPero}();
						r.{@link GRobot#vzad(double) vzad}({@code num12});
						r.{@link GRobot#vľavo(double) vľavo}({@code num40});
						r.{@link GRobot#položPero() položPero}();
						r.{@link GRobot#vpred(double) vpred}({@code num12});
						r.{@link GRobot#choďNa(double, double) choďNa}(p);
					};

					{@code comm// Definícia tvaru robotov:}
					{@code kwdfinal} {@link KreslenieTvaru KreslenieTvaru} tvar = r -&gt;
					{
						r.{@link GRobot#hviezda() hviezda}();
						r.{@link GRobot#text(String) text}(r.{@link GRobot#meno() meno}());
					};
					<hr/>
					{@code comm// Definícia robota s menom αlpha:}
					{@code kwdfinal} {@link GRobot GRobot} α = {@code kwdnew} {@link GRobot#GRobot() GRobot}();
					α.{@link GRobot#meno(String) meno}({@code srg"αlpha"});
					α.{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num1.5});
					α.{@link GRobot#veľkosť(double) veľkosť}(veľkosťRobota);
					α.{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
					α.{@link GRobot#nekresliTvary() nekresliTvary}();
					α.{@link GRobot#zdvihniPero() zdvihniPero}();

					{@code comm// Definícia robota s menom βeta:}
					{@code kwdfinal} {@link GRobot GRobot} β = {@code kwdnew} {@link GRobot#GRobot() GRobot}();
					β.{@link GRobot#meno(String) meno}({@code srg"βeta"});
					β.{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num1.5});
					β.{@link GRobot#veľkosť(double) veľkosť}(veľkosťRobota);
					β.{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(tvar);
					β.{@link GRobot#nekresliTvary() nekresliTvary}();
					β.{@link GRobot#zdvihniPero() zdvihniPero}();

					{@code comm// Nastavenie počiatočných polôh robotov:}
					α.{@link GRobot#skoč(double, double) skoč}({@code num110}, -{@code num55});
					β.{@link GRobot#skoč(double, double) skoč}(-{@code num110}, {@code num55});
					<hr/>
					{@code comm// Definícia spojnice a jej orezania:}
					{@link Spojnica Spojnica} spojnica = α.{@link GRobot#spojnica(GRobot) spojnica}(β);
					spojnica.{@link Spojnica#orezanieZačiatku(Shape) orezanieZačiatku}(α.{@link GRobot#hviezda() hviezda}());
					spojnica.{@link Spojnica#orezanieKonca(Shape) orezanieKonca}(β.{@link GRobot#hviezda() hviezda}());
					<hr/>
					{@code comm// Nastavenie kreslenia značky začiatku:}
					spojnica.{@link Spojnica#definujZnačkuZačiatku(KreslenieTvaru) definujZnačkuZačiatku}(šípka);
					<hr/>
					{@code comm// Definícia takej obsluhy udalostí, ktorá umožnení presúvanie robotov:}
					{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
					{
						{@code comm// Inštancia robota, na ktorú bolo kliknuté:}
						{@link GRobot GRobot} r = {@code valnull};

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#klik() klik}()
						{
							{@code comm// Klik urobí to isté ako ťahanie myšou:}
							{@link GRobot#ťahanieMyšou() ťahanieMyšou}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#stlačenieTlačidlaMyši() stlačenieTlačidlaMyši}()
						{
							{@code comm// Zistenie, na ktorý robot bolo kliknuté a jeho aktivácia:}
							r = {@code valnull};
							{@code kwdif} (α.{@link GRobot#myšVHviezde() myšVHviezde}()) r = α; {@code kwdelse}
							{@code kwdif} (β.{@link GRobot#myšVHviezde() myšVHviezde}()) r = β;
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#ťahanieMyšou() ťahanieMyšou}()
						{
							{@code kwdif} ({@code valnull} != r && {@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#tlačidloMyši(int) tlačidloMyši}({@link Konštanty#ĽAVÉ ĽAVÉ}))
							{
								{@code comm// Ak je aktívny jeden z robotov, tak ťahanie ľavého}
								{@code comm// tlačidla myši so súčasným držaním klávesu Shift ho}
								{@code comm// otočí na súradnice myši, v opačnom prípade je robot}
								{@code comm// na súradnice myši presunutý:}

								{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#myš() myš}().{@link MouseEvent#isShiftDown() isShiftDown}())
									r.{@link GRobot#otočNaMyš() otočNaMyš}();
								{@code kwdelse}
									r.{@link GRobot#skočNaMyš() skočNaMyš}();
							}
						}
					};
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>spojnica-priklad-orezani.gif<alt/>Animovaný
				 * príklad orezaní spojnice.</image>Jednoduché
				 * presunutie jedného a potom druhého robota<br
				 * /><small>(plátno je orezané a automatický návrat do
				 * východiskovej polohy bol doprogramovaný,<br />aby
				 * animácia plynule nadväzovala pri jej opakovaní)</small>.</p>
				 * 
				 * @param orezanieZačiatku nový tvar orezania začiatku
				 *     spojnice alebo {@code valnull}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica orezanieZačiatku(Shape orezanieZačiatku)
				{
					spracujOrezanieZačiatku(orezanieZačiatku);
					Svet.automatickéPrekreslenie();
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #orezanieZačiatku(Shape) orezanieZačiatku}.</p> */
				public Spojnica orezanieZaciatku(Shape orezanieZačiatku)
				{
					return orezanieZačiatku(orezanieZačiatku);
				}

				/**
				 * <p>Definuje tvar orezania konca spojnice. Ak je zadaná
				 * hodnota {@code valnull}, tak bude orezanie zrušené.
				 * Orezanie konca (i začiatku) čiary spojnice má význam vo
				 * viacerých prípadoch. Napríklad, ak chceme kresliť
				 * priehľadný tvar cieľového robota a zároveň chceme, aby sa
				 * čiara spojnice končila na jeho hraniciach alebo potrebujeme
				 * kresliť
				 * {@linkplain #definujZnačkuKonca(KreslenieTvaru)
				 * značku konca} čiary spojnice presne na hraniciach tvaru
				 * cieľového robota. Tvar orezania by sme v týchto prípadoch
				 * volili tak, aby vymedzoval hranice objektu, ktorý svojím
				 * tvarom reprezentuje cieľový robot.</p>
				 * 
				 * <p>Podrobnejšie informácie o orezaní konca aj začiatku
				 * spojnice a príklad ich použitia sú v opise metódy
				 * {@link #orezanieZačiatku(Shape) orezanieZačiatku}.</p>
				 * 
				 * @param orezanieKonca nový tvar orezania konca
				 *     spojnice alebo {@code valnull}
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica orezanieKonca(Shape orezanieKonca)
				{
					spracujOrezanieKonca(orezanieKonca);
					Svet.automatickéPrekreslenie();
					return this;
				}


				/**
				 * <p>Zistí aktuálne vysunutie začiatku spojnice od jej stredu.
				 * Hodnota {@code num0} znamená, že spojnica smeruje zo stredu
				 * zdrojového robota (to jest zo súradníc jeho aktuálnej
				 * polohy). Iná hodnota znamená vysunutie začiatku spojnice
				 * v kladnom alebo zápornom smere, ktorý je súhlasný s kladným
				 * alebo záporným smerom osi x, ak os y smeruje do koncového
				 * bodu spojnice. Napríklad hodnota {@code num10} znamená, že
				 * začiatok spojnice je vysunutý od aktuálnych súradníc
				 * zdroja o desať bodov smerom „doprava“ (ak považujeme smer
				 * „dopredu“ za súhlasný so smerom do cieľa).</p>
				 * 
				 * <p><image>vysunutie-zaciatku-spojnice.png<alt/>Grafické
				 * znázornenie vysunutia začiatku spojnice.</image>Znázornenie
				 * kladného vysunutia začiatku spojnice – zelená čiara je
				 * spojnica,<br />ktorá nie je vysunutá a červená znázorňuje
				 * vysunutú spojnicu.</p>
				 * 
				 * @return aktuálne vysunutie začiatku spojnice od aktuálnej
				 *     polohy začiatočného robota (kladné hodnoty znamenajú
				 *     vysunutie smerom „doprava“ vzhľadom na orientáciu od
				 *     zdroja do cieľa, záporné zase „doľava“)
				 */
				public double vysunutieZačiatku()
				{
					return vysunutieZačiatku;
				}

				/** <p><a class="alias"></a> Alias pre {@link #vysunutieZačiatku() vysunutieZačiatku}.</p> */
				public double vysunutieZaciatku()
				{
					return vysunutieZačiatku;
				}

				/**
				 * <p>Zistí aktuálne vysunutie konca spojnice od jej stredu.
				 * Hodnota {@code num0} znamená, že spojnica smeruje do stredu
				 * cieľového robota (to jesto na súradnice jeho aktuálnej
				 * polohy). Iná hodnota znamená vysunutie konca spojnice
				 * v kladnom alebo zápornom smere, ktorý je súhlasný s kladným
				 * alebo záporným smerom začiatočného vysunutia spojnice.
				 * Napríklad hodnota {@code num10} znamená, že koniec spojnice
				 * je vysunutý o desať bodov smerom „doprava,“ ak považujeme
				 * smer „dopredu“ za súhlasný so smerom od zdroja do cieľa.</p>
				 * 
				 * <p><image>vysunutie-konca-spojnice.png<alt/>Grafické
				 * znázornenie vysunutia konca spojnice.</image>Znázornenie
				 * kladného vysunutia konca spojnice – zelená čiara je
				 * spojnica,<br />ktorá nie je vysunutá a červená znázorňuje
				 * vysunutú spojnicu.</p>
				 * 
				 * @return aktuálne vysunutie konca spojnice od aktuálnej
				 *     polohy koncového robota; kladné hodnoty znamenajú
				 *     vysunutie smerom „doprava“ vzhľadom na orientáciu od
				 *     zdroja do cieľa, záporné zase „doľava“
				 */
				public double vysunutieKonca()
				{
					return vysunutieKonca;
				}

				/**
				 * <p>Umožňuje určiť vysunutie začiatočného bodu spojnice od jeho
				 * stredu. Hodnota {@code num0} znamená, že spojnica smeruje
				 * presne zo stredu zdrojového robota (to jest zo súradníc
				 * jeho aktuálnej polohy). Iná hodnota vysunie začiatok
				 * spojnice v kladnom alebo zápornom smere, ktorý je súhlasný
				 * s kladným alebo záporným smerom osi x, ak os y smeruje do
				 * koncového bodu spojnice. Napríklad hodnota {@code num10}
				 * znamená, že začiatok spojnice bude vysunutý od aktuálnych
				 * súradníc zdroja o desať bodov smerom „doprava“ (ak
				 * považujeme smer „dopredu“ za súhlasný so smerom od zdroja
				 * do cieľa).</p>
				 * 
				 * <p><image>vysunutie-zaciatku-spojnice.png<alt/>Grafické
				 * znázornenie vysunutia začiatku spojnice.</image>Znázornenie
				 * kladného vysunutia začiatku spojnice – zelená čiara je
				 * spojnica,<br />ktorá nie je vysunutá a červená znázorňuje
				 * vysunutú spojnicu.</p>
				 * 
				 * @param vysunutie nové vysunutie začiatku spojnice od
				 *     aktuálnej polohy začiatkočného robota; (kladné hodnoty
				 *     znamenajú vysunutie smerom „doprava“ vzhľadom na
				 *     orientáciu od zdroja do cieľa, záporné zase „doľava“)
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica vysunutieZačiatku(double vysunutie)
				{
					// Reset kreslenia značiek:
					if (null != značkaZačiatku)
						značkaZačiatku.poslednéOrezanie = null;

					if (null != značkaKonca)
						značkaKonca.poslednéOrezanie = null;

					this.vysunutieZačiatku = vysunutie;
					return this;
				}

				/** <p><a class="alias"></a> Alias pre {@link #vysunutieZačiatku(double) vysunutieZačiatku}.</p> */
				public Spojnica vysunutieZaciatku(double vysunutie)
				{
					return vysunutieZačiatku(vysunutie);
				}

				/**
				 * <p>Umožňuje určiť vysunutie koncového bodu spojnice od jeho
				 * stredu. Hodnota {@code num0} znamená, že spojnica smeruje
				 * presne do stredu cieľového robota (to jest na súradnice
				 * jeho aktuálnej polohy). Iná hodnota vysunie koniec spojnice
				 * v kladnom alebo zápornom smere, ktorý je súhlasný s kladným
				 * alebo záporným smerom začiatočného vysunutia spojnice.
				 * Napríklad hodnota {@code num10} znamená, že koniec spojnice
				 * bude vysunutý od aktuálnych súradníc cieľa o desať bodov
				 * smerom „doprava,“ ak považujeme smer „dopredu“ za súhlasný
				 * so smerom od zdroja do cieľa.</p>
				 * 
				 * <p><image>vysunutie-konca-spojnice.png<alt/>Grafické
				 * znázornenie vysunutia konca spojnice.</image>Znázornenie
				 * kladného vysunutia konca spojnice – zelená čiara je
				 * spojnica,<br />ktorá nie je vysunutá a červená znázorňuje
				 * vysunutú spojnicu.</p>
				 * 
				 * @param vysunutie nové vysunutie konca spojnice od
				 *     aktuálnej polohy koncového robota; kladné hodnoty
				 *     znamenajú vysunutie smerom „doprava“ vzhľadom na
				 *     orientáciu od zdroja do cieľa, záporné zase „doľava“
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica vysunutieKonca(double vysunutie)
				{
					// Reset kreslenia značiek:
					if (null != značkaZačiatku)
						značkaZačiatku.poslednéOrezanie = null;

					if (null != značkaKonca)
						značkaKonca.poslednéOrezanie = null;

					this.vysunutieKonca = vysunutie;
					return this;
				}

				/**
				 * <p>Umožňuje určiť vysunutie oboch koncov spojnice od stredov
				 * prepájaných robotov súčasne. Hodnota {@code num0} znamená,
				 * že spojnica smeruje presne zo „stredu“ (z aktuálnej polohy)
				 * zdrojového robota presne do „stredu“ (na súradnice
				 * aktuálnej polohy) cieľového robota. Iná hodnota vysunie
				 * začiatok spojnice v kladnom alebo zápornom smere, napríklad
				 * hodnota {@code num10} znamená, že spojnica bude vysunutá od
				 * aktuálnych súradníc zdroja a cieľa o desať bodov smerom
				 * „doprava,“ ak považujeme smer „dopredu“ za súhlasný so
				 * smerom od zdroja do cieľa.</p>
				 * 
				 * <table class="centered">
				 * <tr><td><image>vysunutie-zaciatku-spojnice.png<alt/>Grafické
				 * znázornenie vysunutia začiatku spojnice.</image></td>
				 * <td><image>vysunutie-konca-spojnice.png<alt/>Grafické
				 * znázornenie vysunutia konca spojnice.</image></td></tr>
				 * <tr><td colspan="2"><p class="image">Znázornenie kladného
				 * vysunutia začiatku (vľavo) a konca (vpravo) spojnice – zelená
				 * čiara je spojnica,<br />ktorá nie je vysunutá a červená
				 * znázorňuje vysunutú spojnicu.</p></td></tr></table>
				 * 
				 * @param vysunutie nové vysunutie spojnice od aktuálnych polôh
				 *     prepájaných robotov; kladné hodnoty znamenajú vysunutie
				 *     smerom „doprava“ vzhľadom na orientáciu od zdroja do
				 *     cieľa, záporné zase „doľava“
				 * @return aktuálna inštancia spojnice (na reťazové nastavenie
				 *     viacerých vlastností)
				 */
				public Spojnica vysunutie(double vysunutie)
				{
					if (null != značkaZačiatku)
						značkaZačiatku.poslednéOrezanie = null;

					if (null != značkaKonca)
						značkaKonca.poslednéOrezanie = null;

					this.vysunutieZačiatku = this.vysunutieKonca = vysunutie;
					return this;
				}


				/**
				 * <p>Zistí, či je spojnica viditeľná alebo skrytá.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda nezistí, či
				 * je spojnica reálne vidno na plátne, iba vráti stav zobrazenia
				 * určený metódami {@link #zobraz() zobraz} a/alebo
				 * {@link #skry() skry}.<br /> <br />(Tým chce byť vysvetlené,
				 * že ak je napríklad spojnica skrytá za nejakým objektom, tak
				 * táto metóda to nezistí.)</p>
				 * 
				 * @return {@code valtrue} ak je spojnica zobrazená, {@code 
				 *     valfalse} v opačnom prípade
				 * 
				 * @see #zobrazená()
				 * @see #skrytá()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 */
				public boolean viditeľná() { return viditeľná; }

				/** <p><a class="alias"></a> Alias pre {@link #viditeľná() viditeľná}.</p> */
				public boolean viditelna() { return viditeľná; }

				/**
				 * <p>Zistí, či je spojnica viditeľná alebo skrytá.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda nezistí, či
				 * je spojnica reálne vidno na plátne, iba vráti stav zobrazenia
				 * určený metódami {@link #zobraz() zobraz} a/alebo
				 * {@link #skry() skry}.<br /> <br />(Tým chce byť vysvetlené,
				 * že ak je napríklad spojnica skrytá za nejakým objektom, tak
				 * táto metóda to nezistí.)</p>
				 * 
				 * @return {@code valtrue} ak je spojnica zobrazená, {@code 
				 *     valfalse} v opačnom prípade
				 * 
				 * @see #viditeľná()
				 * @see #skrytá()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 */
				public boolean zobrazená() { return viditeľná; }

				/** <p><a class="alias"></a> Alias pre {@link #zobrazená() zobrazená}.</p> */
				public boolean zobrazena() { return viditeľná; }

				/**
				 * <p>Zistí, či je spojnica viditeľná alebo skrytá.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda nezistí, či
				 * je spojnica reálne vidno na plátne, iba vráti stav zobrazenia
				 * určený metódami {@link #zobraz() zobraz} a/alebo
				 * {@link #skry() skry}.<br /> <br />(Tým chce byť vysvetlené,
				 * že ak je napríklad spojnica skrytá za nejakým objektom, tak
				 * táto metóda to nezistí.)</p>
				 * 
				 * @return {@code valtrue} ak je spojnica skrytá, {@code 
				 *     valfalse} v opačnom prípade
				 * 
				 * @see #viditeľná()
				 * @see #zobrazená()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 */
				public boolean skrytá() { return !viditeľná; }

				/** <p><a class="alias"></a> Alias pre {@link #skrytá() skrytá}.</p> */
				public boolean skryta() { return !viditeľná; }

				/**
				 * <p>Zobrazí túto spojnicu. Alternatívou tejto metódy je
				 * metóda {@link #zobraz() zobraz}. Opačný efekt má metóda
				 * {@link #skry() skry}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda spúšťa
				 * automatické prekreslenie sveta, ale len v prípade, že sa
				 * stav viditeľnosti spojnice zmení.</p>
				 * 
				 * @see #viditeľná()
				 * @see #zobrazená()
				 * @see #skrytá()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 */
				public void ukáž()
				{
					// Toto nie je alias‼ Prípadné zmeny treba
					// vniesť aj do metódy zobraz (nižšie)‼
					if (!viditeľná)
					{
						viditeľná = true;
						Svet.automatickéPrekreslenie();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #ukáž() ukáž}.</p> */
				public void ukaz() { ukáž(); }

				/**
				 * <p>Zobrazí túto spojnicu. Alternatívou tejto metódy je
				 * metóda {@link #ukáž() ukáž}. Opačný efekt má metóda
				 * {@link #skry() skry}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda spúšťa
				 * automatické prekreslenie sveta, ale len v prípade, že sa
				 * stav viditeľnosti spojnice zmení.</p>
				 * 
				 * @see #viditeľná()
				 * @see #zobrazená()
				 * @see #skrytá()
				 * @see #ukáž()
				 * @see #skry()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 */
				public void zobraz()
				{
					// Toto nie je alias‼ Prípadné zmeny treba
					// vniesť aj do metódy ukáž (vyššie)‼
					if (!viditeľná)
					{
						viditeľná = true;
						Svet.automatickéPrekreslenie();
					}
				}

				/**
				 * <p>Skryje túto spojnicu. Opačný efekt majú metódy
				 * {@link #ukáž() ukáž} a {@link #zobraz() zobraz} (ktoré
				 * fungujú identicky – jedna je alternatívou druhej). Uvedené
				 * metódy majú definované aj verzie s parametrom, ktorého
				 * hodnota určuje, či má byť spojnica zobrazená alebo
				 * skrytá.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda spúšťa
				 * automatické prekreslenie sveta, ale len v prípade, že sa
				 * stav viditeľnosti spojnice zmení.</p>
				 * 
				 * @see #viditeľná()
				 * @see #zobrazená()
				 * @see #skrytá()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 */
				public void skry()
				{
					if (viditeľná)
					{
						viditeľná = false;
						Svet.automatickéPrekreslenie();
					}
				}

				/**
				 * <p>Zobrazí alebo skryje túto spojnicu podľa hodnoty
				 * parametra {@code ukáž}. Alternatívou tejto metódy je
				 * metóda {@link #zobraz(boolean) zobraz}. Okrem tejto
				 * dvojice metód je definovaná trojica bezparametrických
				 * metód: {@link #ukáž() ukáž}, {@link #zobraz() zobraz}
				 * a {@link #skry() skry}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda spúšťa
				 * automatické prekreslenie sveta, ale len v prípade, že sa
				 * stav viditeľnosti spojnice zmení.</p>
				 * 
				 * @param zobraz ak je hodnota tohto parametera rovná
				 *     {@code valtrue} a spojnica nie je viditeľná, tak bude
				 *     zobrazená;
				 *     ak je hodnota tohto parametera rovná {@code valfalse}
				 *     a spojnica je viditeľná, tak bude skrytá
				 * 
				 * @see #viditeľná()
				 * @see #zobrazená()
				 * @see #skrytá()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #zobraz(boolean)
				 */
				public void ukáž(boolean ukáž)
				{ if (ukáž) ukáž(); else skry(); }

				/** <p><a class="alias"></a> Alias pre {@link #ukáž(boolean) ukáž}.</p> */
				public void ukaz(boolean ukáž) { ukáž(ukáž); }

				/**
				 * <p>Zobrazí alebo skryje túto spojnicu podľa hodnoty
				 * parametra {@code zobraz}. Alternatívou tejto metódy je
				 * metóda {@link #ukáž(boolean) ukáž}. Okrem tejto
				 * dvojice metód je definovaná trojica bezparametrických
				 * metód: {@link #ukáž() ukáž}, {@link #zobraz() zobraz}
				 * a {@link #skry() skry}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto metóda spúšťa
				 * automatické prekreslenie sveta, ale len v prípade, že sa
				 * stav viditeľnosti spojnice zmení.</p>
				 * 
				 * @param zobraz ak je hodnota tohto parametera rovná
				 *     {@code valtrue} a spojnica nie je viditeľná, tak bude
				 *     zobrazená;
				 *     ak je hodnota tohto parametera rovná {@code valfalse}
				 *     a spojnica je viditeľná, tak bude skrytá
				 * 
				 * @see #viditeľná()
				 * @see #zobrazená()
				 * @see #skrytá()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #ukáž(boolean)
				 */
				public void zobraz(boolean zobraz)
				{ if (zobraz) zobraz(); else skry(); }
			}


			/*packagePrivate*/ final Vector<Spojnica> spojnice = new Vector<>();

		// Aktívne plátno robota

			// (predvolene podlaha, môže byť zvolený aj strop)
			/*packagePrivate*/ Plátno aktívnePlátno;
			/*packagePrivate*/ BufferedImage obrázokAktívnehoPlátna;
			/*packagePrivate*/ Graphics2D grafikaAktívnehoPlátna;

		// Vnútorná pamäť robota

			// Objekty na zálohovanie súčastí podlahy alebo stropu
			/*packagePrivate*/ BufferedImage obrázokZálohyPlátna = null;
			/*packagePrivate*/ int[] zálohaPlátna = null;
			/*packagePrivate*/ Plátno.ZálohaKonzoly zálohaKonzoly = null;

			// Cesta a dráha
			// private final Polygon cesta = new Polygon();
			private final Path2D.Double cesta = new Path2D.Double();
			private boolean záznamCesty = false;
			private boolean záznamCestyBezPolohyPera = true;

			private final Vector<Bod> dráha = new Vector<>();
			private final Vector<Double> mapaSmerov = new Vector<>();
			private final TreeSet<Integer> kľúčovéFázy = new TreeSet<>();
			private int fázaDráhy = -1;

			// Zamestanie
			/*packagePrivate*/ Oblasť zamestnanýPre = null;

		// Ďalšie príznaky

			// Aktuálny spôsob kreslenia obrázkov a písania textov
			/*packagePrivate*/ int spôsobKreslenia =
				KRESLI_NA_STRED | KRESLI_ROTOVANÉ;

			// Semafor, ktorý je okrem iného (explicitne naznačeného názvom),
			// použitý pri signalizácii (ne)zamestnanosti tohto robota pre
			// Oblasť
			/*packagePrivate*/ boolean kresliTvary = true;

			// Príznak meniaci správanie metód kresliacich tvary (buď sú
			// kreslené obrysy tvarov, alebo sú tvary vypĺňané)
			/*packagePrivate*/ boolean vypĺňajTvary = false;

			// Priehľadnosť robota
			private float priehľadnosť = 1.0f;

			// Poradové číslo (kresliacej) vrstvy, v ktorej sa robot nachádza
			private int vrstva = 0;

			// Príznak aktivácie interaktívneho režimu pre tento robot
			/*packagePrivate*/ boolean interaktívnyRežim = false;

			// Vymenovanie a atribút komunikujúci s SVG podporou
			/*packagePrivate*/ enum TypTvaru { NIČ, VÝPLŇ, OBRYS }
			/*packagePrivate*/ TypTvaru poslednýTypTvaru = TypTvaru.NIČ;


		// Vnútorné zoznamy

			// Zoznam robotov na účely ich vykresľovania

				/*packagePrivate*/ static boolean zoznamZmenený1 = false;
				/*packagePrivate*/ static boolean zoznamZmenený2 = false;

				/*packagePrivate*/ static boolean zámokZoznamuRobotov1 = false;
				/*packagePrivate*/ static boolean zámokZoznamuRobotov2 = false;

				/*packagePrivate*/ final static Vector<GRobot>
					zoznamRobotov = new Vector<>();
				/*packagePrivate*/ final static Vector<GRobot>
					záložnýZoznamRobotov = new Vector<>();

			// Zoznam vrstiev

				/*packagePrivate*/ final static TreeMap<Integer, Vrstva>
					zoznamVrstiev = new TreeMap<>();



	// ------------------------------- //
	//  *** Rôzne súkromné metódy ***  //
	// ------------------------------- //

		// Inicializácia robota

			private void registrujUdalostiRobota()
			{
				try
				{
					if (!getClass().getMethod("stlačenieKlávesu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("stlacenieKlavesu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("uvoľnenieKlávesu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("uvolnenieKlavesu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zadanieZnaku").
						getDeclaringClass().equals(GRobot.class))
						počúvajúciKlávesnicu.add(this);
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					if (!getClass().getMethod("klik").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("stlačenieTlačidlaMyši").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("stlacenieTlacidlaMysi").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("uvoľnenieTlačidlaMyši").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("uvolnenieTlacidlaMysi").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("pohybMyši").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("pohybMysi").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("ťahanieMyšou").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("tahanieMysou").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("rolovanieKolieskomMyši").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("rolovanieKolieskomMysi").
						getDeclaringClass().equals(GRobot.class))
						počúvajúciMyš.add(this);
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					if (!getClass().getMethod("potvrdenieÚdajov").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("potvrdenieUdajov").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("potvrdenieVstupu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zrušenieÚdajov").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zrusenieUdajov").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zrušenieVstupu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zrusenieVstupu").
						getDeclaringClass().equals(GRobot.class))
						počúvajúciVstupnýRiadok.add(this);
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					if (!getClass().getMethod("ťahanieSúborov").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("tahanieSuborov").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("pustenieSúboru", String.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("pustenieSuboru", String.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("farbaAktívnehoSlova",
							String.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("farbaAktivnehoSlova",
							String.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("aktiváciaOdkazu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("aktivaciaOdkazu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zobrazenieOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("skrytieOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("presunutieOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zmenaVeľkostiOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zmenaVelkostiOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("aktiváciaOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("aktivaciaOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("deaktiváciaOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("deaktivaciaOkna").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("maximalizovanie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("minimalizovanie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("obnovenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("otvorenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zavretie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zatvorenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("prekreslenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("dokreslenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("klávesováSkratka").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("klavesovaSkratka").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("vymazanie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("voľbaPoložkyPonuky").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("volbaPolozkyPonuky").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("voľbaKontextovejPoložky").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("volbaKontextovejPolozky").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("voľbaTlačidla").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("volbaTlacidla").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zmenaPosunuLišty").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zmenaPosunuListy").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("voľbaSystémovejIkony").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("volbaSystemovejIkony").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("voľbaSystémovejPoložky").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("volbaSystemovejPolozky").
						getDeclaringClass().equals(GRobot.class))
						počúvajúciRozhranie.add(this);
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					if (!getClass().getMethod("ukončenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("ukoncenie").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("spracovaniePríkazu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("spracovaniePrikazu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("tik").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zastavenieAnimácie",
							Obrázok.class).getDeclaringClass().
							equals(GRobot.class) ||
						!getClass().getMethod("zastavenieAnimacie",
							Obrázok.class).getDeclaringClass().
							equals(GRobot.class) ||

						// TODO: V režime ladenia to vypisovalo chybu. Overiť‼
						!getClass().getMethod("ukončenieProcesu",
							Svet.PríkazovýRiadok.class, int.class).
							getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("ukoncenieProcesu",
							Svet.PríkazovýRiadok.class, int.class).
							getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("spracujRiadokVstupu",
							String.class).getDeclaringClass().
							equals(GRobot.class) ||
						!getClass().getMethod("koniecVstupu").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("vzniklaChyba",
							GRobotException.Chyba.class).getDeclaringClass().
							equals(GRobot.class))
						počúvajúciSystém.add(this);
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					if (!getClass().getMethod("konfiguráciaZmenená").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("konfiguraciaZmenena").
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zapíšKonfiguráciu", Súbor.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("zapisKonfiguraciu", Súbor.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("čítajKonfiguráciu", Súbor.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("citajKonfiguraciu", Súbor.class).
						getDeclaringClass().equals(GRobot.class) ||
						!getClass().getMethod("sekvencia", int.class,
							Object.class, Object.class, long.class, long.class).
						getDeclaringClass().equals(GRobot.class))
						počúvajúciSúbory.add(this);
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }


				/* --- * /
				System.out.println("Overenie správnosti všetkých prekrytí:");

				try
				{
					System.out.println("stlačenieKlávesu: " +
						getClass().getMethod("stlačenieKlávesu").
						getDeclaringClass());
					System.out.println("stlacenieKlavesu: " +
						getClass().getMethod("stlacenieKlavesu").
						getDeclaringClass());
					System.out.println("uvoľnenieKlávesu: " +
						getClass().getMethod("uvoľnenieKlávesu").
						getDeclaringClass());
					System.out.println("uvolnenieKlavesu: " +
						getClass().getMethod("uvolnenieKlavesu").
						getDeclaringClass());
					System.out.println("zadanieZnaku: " +
						getClass().getMethod("zadanieZnaku").
						getDeclaringClass());
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					System.out.println("klik: " +
						getClass().getMethod("klik").
						getDeclaringClass());
					System.out.println("stlačenieTlačidlaMyši: " +
						getClass().getMethod("stlačenieTlačidlaMyši").
						getDeclaringClass());
					System.out.println("stlacenieTlacidlaMysi: " +
						getClass().getMethod("stlacenieTlacidlaMysi").
						getDeclaringClass());
					System.out.println("uvoľnenieTlačidlaMyši: " +
						getClass().getMethod("uvoľnenieTlačidlaMyši").
						getDeclaringClass());
					System.out.println("uvolnenieTlacidlaMysi: " +
						getClass().getMethod("uvolnenieTlacidlaMysi").
						getDeclaringClass());
					System.out.println("pohybMyši: " +
						getClass().getMethod("pohybMyši").
						getDeclaringClass());
					System.out.println("pohybMysi: " +
						getClass().getMethod("pohybMysi").
						getDeclaringClass());
					System.out.println("ťahanieMyšou: " +
						getClass().getMethod("ťahanieMyšou").
						getDeclaringClass());
					System.out.println("tahanieMysou: " +
						getClass().getMethod("tahanieMysou").
						getDeclaringClass());
					System.out.println("rolovanieKolieskomMyši: " +
						getClass().getMethod("rolovanieKolieskomMyši").
						getDeclaringClass());
					System.out.println("rolovanieKolieskomMysi: " +
						getClass().getMethod("rolovanieKolieskomMysi").
						getDeclaringClass());
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					System.out.println("potvrdenieÚdajov: " +
						getClass().getMethod("potvrdenieÚdajov").
						getDeclaringClass());
					System.out.println("potvrdenieUdajov: " +
						getClass().getMethod("potvrdenieUdajov").
						getDeclaringClass());
					System.out.println("potvrdenieVstupu: " +
						getClass().getMethod("potvrdenieVstupu").
						getDeclaringClass());
					System.out.println("zrušenieÚdajov: " +
						getClass().getMethod("zrušenieÚdajov").
						getDeclaringClass());
					System.out.println("zrusenieUdajov: " +
						getClass().getMethod("zrusenieUdajov").
						getDeclaringClass());
					System.out.println("zrušenieVstupu: " +
						getClass().getMethod("zrušenieVstupu").
						getDeclaringClass());
					System.out.println("zrusenieVstupu: " +
						getClass().getMethod("zrusenieVstupu").
						getDeclaringClass());
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					System.out.println("ťahanieSúborov: " +
						getClass().getMethod("ťahanieSúborov").
						getDeclaringClass());
					System.out.println("tahanieSuborov: " +
						getClass().getMethod("tahanieSuborov").
						getDeclaringClass());
					System.out.println("pustenieSúboru: " +
						getClass().getMethod("pustenieSúboru", String.class).
						getDeclaringClass());
					System.out.println("pustenieSuboru: " +
						getClass().getMethod("pustenieSuboru", String.class).
						getDeclaringClass());
					System.out.println("farbaAktívnehoSlova: " +
						getClass().getMethod("farbaAktívnehoSlova",
							String.class).getDeclaringClass());
					System.out.println("farbaAktivnehoSlova: " +
						getClass().getMethod("farbaAktivnehoSlova",
							String.class).getDeclaringClass());
					System.out.println("zobrazenieOkna: " +
						getClass().getMethod("zobrazenieOkna").
						getDeclaringClass());
					System.out.println("skrytieOkna: " +
						getClass().getMethod("skrytieOkna").
						getDeclaringClass());
					System.out.println("presunutieOkna: " +
						getClass().getMethod("presunutieOkna").
						getDeclaringClass());
					System.out.println("zmenaVeľkostiOkna: " +
						getClass().getMethod("zmenaVeľkostiOkna").
						getDeclaringClass());
					System.out.println("zmenaVelkostiOkna: " +
						getClass().getMethod("zmenaVelkostiOkna").
						getDeclaringClass());
					System.out.println("aktiváciaOkna: " +
						getClass().getMethod("aktiváciaOkna").
						getDeclaringClass());
					System.out.println("aktivaciaOkna: " +
						getClass().getMethod("aktivaciaOkna").
						getDeclaringClass());
					System.out.println("deaktiváciaOkna: " +
						getClass().getMethod("deaktiváciaOkna").
						getDeclaringClass());
					System.out.println("deaktivaciaOkna: " +
						getClass().getMethod("deaktivaciaOkna").
						getDeclaringClass());
					System.out.println("maximalizovanie: " +
						getClass().getMethod("maximalizovanie").
						getDeclaringClass());
					System.out.println("minimalizovanie: " +
						getClass().getMethod("minimalizovanie").
						getDeclaringClass());
					System.out.println("obnovenie: " +
						getClass().getMethod("obnovenie").
						getDeclaringClass());
					System.out.println("otvorenie: " +
						getClass().getMethod("otvorenie").
						getDeclaringClass());
					System.out.println("zavretie: " +
						getClass().getMethod("zavretie").
						getDeclaringClass());
					System.out.println("zatvorenie: " +
						getClass().getMethod("zatvorenie").
						getDeclaringClass());
					System.out.println("prekreslenie: " +
						getClass().getMethod("prekreslenie").
						getDeclaringClass());
					System.out.println("dokreslenie: " +
						getClass().getMethod("dokreslenie").
						getDeclaringClass());
					System.out.println("klávesováSkratka: " +
						getClass().getMethod("klávesováSkratka").
						getDeclaringClass());
					System.out.println("klavesovaSkratka: " +
						getClass().getMethod("klavesovaSkratka").
						getDeclaringClass());
					System.out.println("vymazanie: " +
						getClass().getMethod("vymazanie").
						getDeclaringClass());
					System.out.println("voľbaPoložkyPonuky: " +
						getClass().getMethod("voľbaPoložkyPonuky").
						getDeclaringClass());
					System.out.println("volbaPolozkyPonuky: " +
						getClass().getMethod("volbaPolozkyPonuky").
						getDeclaringClass());
					System.out.println("voľbaKontextovejPoložky: " +
						getClass().getMethod("voľbaKontextovejPoložky").
						getDeclaringClass());
					System.out.println("volbaKontextovejPolozky: " +
						getClass().getMethod("volbaKontextovejPolozky").
						getDeclaringClass());
					System.out.println("voľbaTlačidla: " +
						getClass().getMethod("voľbaTlačidla").
						getDeclaringClass());
					System.out.println("volbaTlacidla: " +
						getClass().getMethod("volbaTlacidla").
						getDeclaringClass());
					System.out.println("zmenaPosunuLišty: " +
						getClass().getMethod("zmenaPosunuLišty").
						getDeclaringClass());
					System.out.println("zmenaPosunuListy: " +
						getClass().getMethod("zmenaPosunuListy").
						getDeclaringClass());
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					System.out.println("ukončenie: " +
						getClass().getMethod("ukončenie").
						getDeclaringClass());
					System.out.println("ukoncenie: " +
						getClass().getMethod("ukoncenie").
						getDeclaringClass());
					System.out.println("spracovaniePríkazu: " +
						getClass().getMethod("spracovaniePríkazu").
						getDeclaringClass());
					System.out.println("spracovaniePrikazu: " +
						getClass().getMethod("spracovaniePrikazu").
						getDeclaringClass());
					System.out.println("tik: " +
						getClass().getMethod("tik").
						getDeclaringClass());
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				try
				{
					System.out.println("konfiguráciaZmenená: " +
						getClass().getMethod("konfiguráciaZmenená").
						getDeclaringClass());
					System.out.println("konfiguraciaZmenena: " +
						getClass().getMethod("konfiguraciaZmenena").
						getDeclaringClass());
					System.out.println("zapíšKonfiguráciu: " +
						getClass().getMethod("zapíšKonfiguráciu", Súbor.class).
						getDeclaringClass());
					System.out.println("zapisKonfiguraciu: " +
						getClass().getMethod("zapisKonfiguraciu", Súbor.class).
						getDeclaringClass());
					System.out.println("čítajKonfiguráciu: " +
						getClass().getMethod("čítajKonfiguráciu", Súbor.class).
						getDeclaringClass());
					System.out.println("citajKonfiguraciu: " +
						getClass().getMethod("citajKonfiguraciu", Súbor.class).
						getDeclaringClass());
					System.out.println("sekvencia: " +
						getClass().getMethod("sekvencia", int.class,
							Object.class, Object.class, long.class, long.class).
						getDeclaringClass());
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }
				/* --- */
			}

			private void inicializujRobot() // pôvodne: inicializujRobota()
			{
				if (null == Svet.hlavnýRobot)
				{
					Svet.hlavnýRobot = this;
					Svet.čítajVlastnúKonfiguráciu();

					Obrázok ikona = new Obrázok(32, 32);
					kresliNaObrázok(ikona);

					čiara = new BasicStroke(1.3f,
						BasicStroke.CAP_ROUND,
						BasicStroke.JOIN_ROUND);
					farbaRobota = predvolenáFarbaRobota;

					poslednéX = 0; poslednéY = 0;
					aktuálneX = aktuálneY = 0;
					poslednýUhol = 30;
					aktuálnyUhol = 30;

					double veľkosť = this.veľkosť;
					this.veľkosť = 14;
					trojzubec();
					this.veľkosť = veľkosť;

					Svet.ikona(ikona);
				}

				kresliNaPodlahu();
				predvolenáHrúbkaPera();
				predvolenáFarba();
				predvolenéPísmo();
				predvolenýTvar();

				// Najprv zaregistrujem robot, aby
				// sa po prechode domov zobrazil
				if (zámokZoznamuRobotov1 || zámokZoznamuRobotov2)
					záložnýZoznamRobotov.add(this);
				else
				{
					zoznamRobotov.add(this);
					Vrstva.vlož(this);
					if (viditeľný) zobrazenie();
					else skrytie();
					zoznamZmenený2 = zoznamZmenený1 = true;
				}
				domov();
			}

		// Zlúčenie zoznamov

			/*packagePrivate*/ static void zlúčiťZoznamy()
			{
				if (záložnýZoznamRobotov.size() > 0 &&
					!zámokZoznamuRobotov1 && !zámokZoznamuRobotov2)
				{
					zoznamRobotov.addAll(záložnýZoznamRobotov);
					for (GRobot robot : záložnýZoznamRobotov)
					{
						Vrstva.vlož(robot);
						if (robot.viditeľný) robot.zobrazenie();
						else robot.skrytie();
					}
					záložnýZoznamRobotov.clear();
					Svet.automatickéPrekreslenie();
				}
			}


		// Kreslenie úsečky medzi bodmi zadanými v súradnicovom priestore
		// frameworku

			private void úsečka(double x0, double y0, double x1, double y1)
			{
				boolean vráťKompozit = priehľadnosť < 1.0;
				Composite zálohaKompozitu = null;

				if (vráťKompozit)
				{
					zálohaKompozitu = grafikaAktívnehoPlátna.getComposite();

					if (priehľadnosť > 0.0)
						grafikaAktívnehoPlátna.setComposite(
							AlphaComposite.getInstance(
								AlphaComposite.SRC_OVER, priehľadnosť));
					else
						grafikaAktívnehoPlátna.setComposite(
							AlphaComposite.getInstance(
								AlphaComposite.SRC_OVER, 0.0f));
				}

				if (null != náter)
				{
					grafikaAktívnehoPlátna.setPaint(náter);
					grafikaAktívnehoPlátna.setStroke(čiara);

					grafikaAktívnehoPlátna.draw(new Line2D.Double(
						Svet.prepočítajX(x0), Svet.prepočítajY(y0),
						Svet.prepočítajX(x1), Svet.prepočítajY(y1)));
				}
				else if (null == cieľováFarba)
				{
					grafikaAktívnehoPlátna.setColor(farbaRobota);
					grafikaAktívnehoPlátna.setStroke(čiara);

					grafikaAktívnehoPlátna.draw(new Line2D.Double(
						Svet.prepočítajX(x0), Svet.prepočítajY(y0),
						Svet.prepočítajX(x1), Svet.prepočítajY(y1)));
				}
				else
				{
					double x0P = Svet.prepočítajX(x0); double y0P = Svet.prepočítajY(y0);
					double x1P = Svet.prepočítajX(x1); double y1P = Svet.prepočítajY(y1);

					grafikaAktívnehoPlátna.setPaint(new GradientPaint(
						(float)x0P, (float)y0P, farbaRobota,
						(float)x1P, (float)y1P, cieľováFarba));
					grafikaAktívnehoPlátna.setStroke(čiara);

					grafikaAktívnehoPlátna.draw(
						new Line2D.Double(x0P, y0P, x1P, y1P));
				}

				if (vráťKompozit)
					grafikaAktívnehoPlátna.setComposite(zálohaKompozitu);

				Svet.automatickéPrekreslenie();
			}

		// Kreslenie robota a spojníc

			// Nasledujúce atribúty (a k nim patriace metódy prepočítajPolygón
			// a starýPolygón – nižšie) slúžia na prepočítanie aktuálneho
			// (predvoleného) tvaru grafického robota. Systém postupne rástol
			// a komplexnel s rozvojom rámca. Medzi prvé patria cx, cy, fx
			// a fy. Cx a cy slúžia na uchovanie aktuálnych koeficientov,
			// z ktorých je prepočítaný polygón. Fx a fy slúžia na uchovanie
			// cieľového polygónu. Gx a gy slúžia na uchovanie súradníc, ktoré
			// budú transformované maticou mat, ktorú vyrobí inštancia
			// transformácie fat. Dohromady je výsledkom želaný polygón, ktorý
			// môže byť obkreslený alebo vyplnený.
			private final double[] cx = new double[5];
			private final double[] cy = new double[5];
			private final int[] fx = new int[7];
			private final int[] fy = new int[7];
			private final double[] gx = new double[7];
			private final double[] gy = new double[7];
			private final AffineTransform fat = new AffineTransform();
			private final double[] mat = new double[6];

			// Tento atribút je permanentné pole slúžiace na určenie
			// podielov kruhového náteru:
			private final float[] podiely = new float[] {0.0f, 1.0f};

			// Príznak návratu a záloha kompozitu vlastnosti grafiky. Tento
			// kompozit súvisí s priehľadnosťou.
			private boolean vráťKompozit_vlastnosťGrafiky = false;
			private Composite zálohaKompozitu_vlastnosťGrafiky = null;

			/*packagePrivate*/ void nastavVlastnostiGrafiky(Graphics2D grafika)
			{
				vráťKompozit_vlastnosťGrafiky = priehľadnosť < 1.0;
				zálohaKompozitu_vlastnosťGrafiky = null;

				if (vráťKompozit_vlastnosťGrafiky)
				{
					zálohaKompozitu_vlastnosťGrafiky = grafika.getComposite();
					if (priehľadnosť > 0.0)
						grafika.setComposite(AlphaComposite.getInstance(
							AlphaComposite.SRC_OVER, priehľadnosť));
					else
						grafika.setComposite(AlphaComposite.getInstance(
							AlphaComposite.SRC_OVER, 0.0f));
				}
			}

			/*packagePrivate*/ void nastavFarbuAleboVýplňPodľaRobota(
				Graphics2D grafika)
			{
				if (null != náter)
				{
					grafika.setPaint(náter);
				}
				else if (null == cieľováFarba)
				{
					grafika.setColor(farbaRobota);
				}
				else if (použiKruhovýNáter)
				{
					grafika.setPaint(new RadialGradientPaint(
						(float)Svet.prepočítajX(aktuálneX),
						(float)Svet.prepočítajY(aktuálneY),
						(float)veľkosť, podiely, new Color[]
						{farbaRobota, cieľováFarba}));
				}
				else
				{
					double α = toRadians(
						// 
						// Farebný prechod nie je správne ovplyvňovať
						// pootočením tvaru, pretože keď sa vlákno dostane
						// až sem, tak:
						// 
						//   1. pri kreslení tvaru (vlastného aj pôvodného)
						//      je už pootočenie tvaru započítané,
						//   2. pri generovaní (a/alebo kreslení a vypĺňaní)
						//      tvarov Javy (vrátane tých, ktoré sú prečítané
						//      z SVG formátu) sa pootočenie tvaru aj tak
						//      neberie do úvahy (takže vygenerovaná výplň by
						//      bola nesprávne pootočená)…
						// 
						//  NOPE: kreslímVlastnýTvar ? aktuálnyUhol :
						//        aktuálnyUhol + pootočenieTvaru
						// 
						aktuálnyUhol);
					double cosα = cos(α) * veľkosť;
					double sinα = sin(α) * veľkosť;
					double x0P = Svet.prepočítajX(aktuálneX - cosα);
					double y0P = Svet.prepočítajY(aktuálneY - sinα);
					double x1P = Svet.prepočítajX(aktuálneX + cosα);
					double y1P = Svet.prepočítajY(aktuálneY + sinα);

					grafika.setPaint(new GradientPaint(
						(float)x0P, (float)y0P, farbaRobota,
						(float)x1P, (float)y1P, cieľováFarba));
				}
			}

			/*packagePrivate*/ Paint dajNáterPodľaRobota()
			{
				if (null != náter) return náter;
				if (null == cieľováFarba) return farbaRobota;

				if (použiKruhovýNáter)
					return new RadialGradientPaint(
						(float)Svet.prepočítajX(aktuálneX),
						(float)Svet.prepočítajY(aktuálneY),
						(float)veľkosť, podiely, new Color[]
						{farbaRobota, cieľováFarba});

				double α = toRadians(aktuálnyUhol);
				double cosα = cos(α) * veľkosť;
				double sinα = sin(α) * veľkosť;
				double x0P = Svet.prepočítajX(aktuálneX - cosα);
				double y0P = Svet.prepočítajY(aktuálneY - sinα);
				double x1P = Svet.prepočítajX(aktuálneX + cosα);
				double y1P = Svet.prepočítajY(aktuálneY + sinα);

				return new GradientPaint(
					(float)x0P, (float)y0P, farbaRobota,
					(float)x1P, (float)y1P, cieľováFarba);
			}

			/*packagePrivate*/ void obnovVlastnostiGrafiky(Graphics2D grafika)
			{
				if (vráťKompozit_vlastnosťGrafiky)
					grafika.setComposite(zálohaKompozitu_vlastnosťGrafiky);
			}

			// (Pozri atribúty cx, cy, fx, fy, gx, gy, fat a mat vyššie.)
			private void prepočítajPolygón()
			{
				// double veľkosťX = veľkosť * pomerVeľkosti;
				double veľkosťY = veľkosť * pomerVeľkosti;
				cx[0] = veľkosť * -0.91;  cy[0] = veľkosťY * -0.91; // (negované)
				cx[1] = veľkosť * 1.91;   cy[1] = veľkosťY * 1.91;
				cx[2] = veľkosť * 0.6;    cy[2] = veľkosťY * 0.6;
				cx[3] = veľkosť * 1.405;  cy[3] = veľkosťY * 1.405;
				cx[4] = veľkosť * 0.415;  cy[4] = veľkosťY * 0.415;

				/* * /
				// Dva „neúspešné“ pokusy v jednom. Fungovali pre trojzubec,
				// ktorý sa celý zmestil do kružnice (a bol na jej báze
				// prepočítavaný), ale keď prišla vlastnosť šírky, prestalo
				// to platiť. Prvý v podstate reprezentuje mierne modifikovaný
				// pôvodný spôsob. Druhý bol pokus o nápravu…

				// Prvý mal všetky:
				// 	fx = x + cos(α) * cx // [1, 2, 3, 4, 4, 3, 2, 1]
				// 	fy = y + sin(α) * cy

				// double x = aktuálneX - cos(α) * cx[0];
				// double y = aktuálneY - sin(α) * cy[0];

				// Druhý vyzeral takto:

				double α = toRadians(aktuálnyUhol + pootočenieTvaru);
				double x = aktuálneX - cos(α) * cx[0] + sin(α) * cx[0];
				double y = aktuálneY - sin(α) * cx[0] - cos(α) * cy[0];

				// u1: 26.5°  —  0.4625122517784973  rad
				// u2: 18.5°  —  0.32288591161895097 rad
				// u3: 45°    —  0.7853981633974483  rad

				fx[0] = (int)Svet.prepočítajX(
					x + cos(α) * cx[1] - sin(α) * cy[1]);
				fy[0] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[1]
					y + sin(α) * cx[1] + cos(α) * cy[1]);

				α += 0.4625122517784973; // u1
				fx[1] = (int)Svet.prepočítajX(
					x + cos(α) * cx[2] - sin(α) * cy[2]);
				fy[1] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[2]
					y + sin(α) * cx[2] + cos(α) * cy[2]);

				α += 0.32288591161895097; // u2
				fx[2] = (int)Svet.prepočítajX(
					x + cos(α) * cx[3] - sin(α) * cy[3]);
				fy[2] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[3]
					y + sin(α) * cx[3] + cos(α) * cy[3]);

				α += 0.7853981633974483; // u3
				fx[3] = (int)Svet.prepočítajX(
					x + cos(α) * cx[4] - sin(α) * cy[4]);
				fy[3] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[4]
					y + sin(α) * cx[4] + cos(α) * cy[4]);

				α += 3.141592653589793;  // 180°
				fx[4] = (int)Svet.prepočítajX(
					x + cos(α) * cx[4] - sin(α) * cy[4]);
				fy[4] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[4]
					y + sin(α) * cx[4] + cos(α) * cy[4]);

				α += 0.7853981633974483; // u3
				fx[5] = (int)Svet.prepočítajX(
					x + cos(α) * cx[3] - sin(α) * cy[3]);
				fy[5] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[3]
					y + sin(α) * cx[3] + cos(α) * cy[3]);

				α += 0.32288591161895097; // u2
				fx[6] = (int)Svet.prepočítajX(
					x + cos(α) * cx[2] - sin(α) * cy[2]);
				fy[6] = (int)Svet.prepočítajY(
					// y + sin(α) * cy[2]
					y + sin(α) * cx[2] + cos(α) * cy[2]);
				/* */

				fat.setToTranslation(aktuálneX, aktuálneY);
				fat.rotate(toRadians(aktuálnyUhol + pootočenieTvaru));

				double α = 0;
				double x = cos(α) * cx[0];
				double y = sin(α) * cy[0];
				// Poznámka: Pozri cx, cy – sú negované…

				// u1: 26.5°  —  0.4625122517784973  rad
				// u2: 18.5°  —  0.32288591161895097 rad
				// u3: 45°    —  0.7853981633974483  rad

				gx[0] = x + cos(α) * cx[1]; gy[0] = y + sin(α) * cy[1];

				α += 0.4625122517784973; // u1
				gx[1] = x + cos(α) * cx[2]; gy[1] = y + sin(α) * cy[2];

				α += 0.32288591161895097; // u2
				gx[2] = x + cos(α) * cx[3]; gy[2] = y + sin(α) * cy[3];

				α += 0.7853981633974483; // u3
				gx[3] = x + cos(α) * cx[4]; gy[3] = y + sin(α) * cy[4];

				α += 3.141592653589793;  // 180°
				gx[4] = x + cos(α) * cx[4]; gy[4] = y + sin(α) * cy[4];

				α += 0.7853981633974483; // u3
				gx[5] = x + cos(α) * cx[3]; gy[5] = y + sin(α) * cy[3];

				α += 0.32288591161895097; // u2
				gx[6] = x + cos(α) * cx[2]; gy[6] = y + sin(α) * cy[2];

				fat.getMatrix(mat);
				double m00 = mat[0], m10 = mat[1], m01 = mat[2];
				double m11 = mat[3], m02 = mat[4], m12 = mat[5];

				for (int i = 0; i < 7; ++i)
				{
					double tx = gx[i] * m00 + gy[i] * m01 + m02;
					double ty = gx[i] * m10 + gy[i] * m11 + m12;
					fx[i] = (int)Svet.prepočítajX(tx);
					fy[i] = (int)Svet.prepočítajY(ty);
				}
			}

			// (Pozri atribúty cx, cy, fx a fy vyššie.)
			private void starýPolygón()
			{
				// double veľkosťX = veľkosť * pomerVeľkosti;
				double veľkosťY = veľkosť * pomerVeľkosti;
				cx[0] = veľkosť * 0.4;  cy[0] = veľkosťY * 0.4;
				cx[1] = veľkosť * -0.5; cy[1] = veľkosťY * -0.5; // (negované)
				cx[2] = veľkosť * 0.6;  cy[2] = veľkosťY * 0.6;
				cx[3] = veľkosť * 1.2;  cy[3] = veľkosťY * 1.2;
				cx[4] = veľkosť * 2.0;  cy[4] = veľkosťY * 2.0;

				/* * /
				// Po vzore metódy prepočítajPolygón bola najprv uchovaná
				// staršia verzia (ktorá deformovala polygón pri obdĺžnikových
				// proporciách tvaru) a nižšie implementovaná novšia verzia.

				double α = toRadians(aktuálnyUhol + pootočenieTvaru);
				double x = aktuálneX - cos(α) * cx[1];
				double y = aktuálneY - sin(α) * cy[1];

				fx[0] = (int)Svet.prepočítajX(x + cos(α) * cx[4]); // 20.0
				fy[0] = (int)Svet.prepočítajY(y + sin(α) * cy[4]);

				α += 0.3490658503988659; // 20°
				fx[1] = (int)Svet.prepočítajX(x + cos(α) * cx[2]); // 6.0
				fy[1] = (int)Svet.prepočítajY(y + sin(α) * cy[2]);

				α += 0.3490658503988659; // 20°
				fx[2] = (int)Svet.prepočítajX(x + cos(α) * cx[3]); // 12.0
				fy[2] = (int)Svet.prepočítajY(y + sin(α) * cy[3]);

				α += 0.8726646259971648; // 50°
				fx[3] = (int)Svet.prepočítajX(x + cos(α) * cx[0]); // 4.0
				fy[3] = (int)Svet.prepočítajY(y + sin(α) * cy[0]);

				α += 3.141592653589793;  // 180°
				fx[4] = (int)Svet.prepočítajX(x + cos(α) * cx[0]); // 4.0
				fy[4] = (int)Svet.prepočítajY(y + sin(α) * cy[0]);

				α += 0.8726646259971648; // 50°
				fx[5] = (int)Svet.prepočítajX(x + cos(α) * cx[3]); // 12.0
				fy[5] = (int)Svet.prepočítajY(y + sin(α) * cy[3]);

				α += 0.3490658503988659; // 20°
				fx[6] = (int)Svet.prepočítajX(x + cos(α) * cx[2]); // 6.0
				fy[6] = (int)Svet.prepočítajY(y + sin(α) * cy[2]);
				/* */

				fat.setToTranslation(aktuálneX, aktuálneY);
				fat.rotate(toRadians(aktuálnyUhol + pootočenieTvaru));

				double α = 0;
				double x = cos(α) * cx[1];
				double y = sin(α) * cy[1];
				// Poznámka: Pozri cx, cy – sú negované…

				gx[0] = x + cos(α) * cx[4]; // 20.0
				gy[0] = y + sin(α) * cy[4];

				α += 0.3490658503988659; // 20°
				gx[1] = x + cos(α) * cx[2]; // 6.0
				gy[1] = y + sin(α) * cy[2];

				α += 0.3490658503988659; // 20°
				gx[2] = x + cos(α) * cx[3]; // 12.0
				gy[2] = y + sin(α) * cy[3];

				α += 0.8726646259971648; // 50°
				gx[3] = x + cos(α) * cx[0]; // 4.0
				gy[3] = y + sin(α) * cy[0];

				α += 3.141592653589793;  // 180°
				gx[4] = x + cos(α) * cx[0]; // 4.0
				gy[4] = y + sin(α) * cy[0];

				α += 0.8726646259971648; // 50°
				gx[5] = x + cos(α) * cx[3]; // 12.0
				gy[5] = y + sin(α) * cy[3];

				α += 0.3490658503988659; // 20°
				gx[6] = x + cos(α) * cx[2]; // 6.0
				gy[6] = y + sin(α) * cy[2];

				fat.getMatrix(mat);
				double m00 = mat[0], m10 = mat[1], m01 = mat[2];
				double m11 = mat[3], m02 = mat[4], m12 = mat[5];

				for (int i = 0; i < 7; ++i)
				{
					double tx = gx[i] * m00 + gy[i] * m01 + m02;
					double ty = gx[i] * m10 + gy[i] * m11 + m12;
					fx[i] = (int)Svet.prepočítajX(tx);
					fy[i] = (int)Svet.prepočítajY(ty);
				}
			}

			/*packagePrivate*/ void kresliRobot( // pôvodne: kresliRobota
				BufferedImage obrázok, Graphics2D grafika)
			{
				boolean vráťKompozit = priehľadnosť < 1.0;
				Composite záloha = null;

				if (vráťKompozit)
				{
					záloha = grafika.getComposite();
					if (priehľadnosť > 0.0)
						grafika.setComposite(AlphaComposite.getInstance(
							AlphaComposite.SRC_OVER, priehľadnosť));
					else
						grafika.setComposite(AlphaComposite.getInstance(
							AlphaComposite.SRC_OVER, 0.0f));
				}

				if (null == vlastnýTvarObrázok &&
					null == vlastnýTvarKreslenie)
				{
					prepočítajPolygón();
					// grafika.setColor(farbaRobota);
					nastavFarbuAleboVýplňPodľaRobota(grafika);

					if (vyplnený)
					{
						grafika.fillPolygon(fx, fy, 7);
						// grafika.fill(new Ellipse2D.Double(
						// 	fx[2] - polomerPera / 2, fy[2] - polomerPera / 2,
						// 	polomerPera, polomerPera));
						// grafika.fill(new Ellipse2D.Double(
						// 	fx[5] - polomerPera / 2, fy[5] - polomerPera / 2,
						// 	polomerPera, polomerPera));
					}
					else
					{
						grafika.setStroke(čiara);
						grafika.drawPolygon(fx, fy, 7);
					}
				}
				else if (null == vlastnýTvarKreslenie)
				{
					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					int šírkaObrázka = vlastnýTvarObrázok.getWidth(null);
					int výškaObrázka = vlastnýTvarObrázok.getHeight(null);
					if (šírkaObrázka < 0 || výškaObrázka < 0) return;

					Image relevantný = Obrázok.
						dajRelevantnýRaster(vlastnýTvarObrázok);

					if (90.0 == (aktuálnyUhol + pootočenieTvaru) &&
						pôvodnáVeľkosť == veľkosť &&
						pôvodnýPomer == pomerVeľkosti)
					{
						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNaStred(
								(int)prepočítanéX, (int)prepočítanéY, grafika);
						else
							grafika.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
					else if (pôvodnáVeľkosť == veľkosť &&
						pôvodnýPomer == pomerVeľkosti)
					{
						double α = toRadians(aktuálnyUhol +
							pootočenieTvaru - 90);

						grafika.rotate(-α, prepočítanéX, prepočítanéY);

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNaStred(
								(int)prepočítanéX, (int)prepočítanéY, grafika);
						else
							grafika.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);

						grafika.rotate(α, prepočítanéX, prepočítanéY);
					}
					else
					{
						AffineTransform transformácie = grafika.getTransform();

						double α = toRadians(aktuálnyUhol +
							pootočenieTvaru - 90);
						double s = veľkosť / pôvodnáVeľkosť;
						double t = s * (pomerVeľkosti / pôvodnýPomer);

						/* Zlý spôsob
						prepočítanéX /= t;
						prepočítanéY /= s;

						grafika.scale(s, t);
						grafika.rotate(-α, prepočítanéX, prepočítanéY);

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNaStred(
								(int)prepočítanéX, (int)prepočítanéY, grafika);
						else
							grafika.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
						*/

						// TODO — poriadne otestuj všetky vetvy tohto kreslenia,
						// lebo táto vyzerá, že konečne funguje, ale „trafil“
						// som to „na náhodu“ a na otestovanie ostatných vetiev
						// nebol čas…

						grafika.translate(prepočítanéX, prepočítanéY);
						grafika.rotate(-α); grafika.scale(s, t);
						grafika.translate(šírkaObrázka / -2.0,
							výškaObrázka / -2.0);

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNa(0, 0, grafika);
						else
							grafika.drawImage(relevantný, 0, 0, null);

						grafika.setTransform(transformácie);
					}
				}
				else
				{
					kresliTvar(obrázok, grafika, this, vlastnýTvarKreslenie);
				}

				if (vráťKompozit) grafika.setComposite(záloha);
			}

			private static void kresliTvar(
				BufferedImage obrázok, Graphics2D grafika,
				GRobot robot, KreslenieTvaru tvar)
			{
				int spôsobKreslenia_Záloha = robot.spôsobKreslenia;

				Plátno aktívnePlátno_Záloha = robot.aktívnePlátno;
				BufferedImage obrázokAktívnehoPlátna_Záloha =
					robot.obrázokAktívnehoPlátna;
				Graphics2D grafikaAktívnehoPlátna_Záloha =
					robot.grafikaAktívnehoPlátna;

				boolean peroPoložené_Záloha = robot.peroPoložené;
				boolean viditeľný_Záloha = robot.viditeľný;
				boolean kresliTvary_Záloha = robot.kresliTvary;
				boolean vypĺňajTvary_Záloha = robot.vypĺňajTvary;

				double aktuálneX_Záloha = robot.aktuálneX;
				double aktuálneY_Záloha = robot.aktuálneY;
				double aktuálnyUhol_Záloha = robot.aktuálnyUhol;
				double domaX_Záloha = robot.domaX;
				double domaY_Záloha = robot.domaY;
				double uholDoma_Záloha = robot.uholDoma;

				Farba farbaDoma_Záloha = robot.farbaDoma;
				Farba cieľováFarbaDoma_Záloha = robot.cieľováFarbaDoma;
				boolean zrušCieľovúFarbuDoma_Záloha = robot.zrušCieľovúFarbuDoma;
				Double polomerPeraDoma_Záloha = robot.polomerPeraDoma;
				Boolean peroPoloženéDoma_Záloha = robot.peroPoloženéDoma;
				Boolean viditeľnýDoma_Záloha = robot.viditeľnýDoma;
				Double veľkosťDoma_Záloha = robot.veľkosťDoma;
				Double pomerDoma_Záloha = robot.pomerDoma;
				Float priehľadnosťDoma_Záloha = robot.priehľadnosťDoma;
				Písmo písmoDoma_Záloha = robot.písmoDoma;
				Double pootočenieTvaruDoma_Záloha = robot.pootočenieTvaruDoma;

				Písmo aktuálnePísmo_Záloha = robot.aktuálnePísmo;
				Stroke čiara_Záloha = robot.čiara;
				Farba farbaRobota_Záloha = robot.farbaRobota;
				Farba cieľováFarba_Záloha = robot.cieľováFarba;
				boolean použiKruhovýNáter_Záloha = robot.použiKruhovýNáter;
				double polomerPera_Záloha = robot.polomerPera;

				float priehľadnosť_Záloha = robot.priehľadnosť;
				double veľkosť_Záloha = robot.veľkosť;
				double pomer_Záloha = robot.pomerVeľkosti;
				double zaoblenieX_Záloha = robot.zaoblenieX;
				double zaoblenieY_Záloha = robot.zaoblenieY;
				double pôvodnáVeľkosť_Záloha = robot.pôvodnáVeľkosť;
				double pôvodnýPomer_Záloha = robot.pôvodnýPomer;
				double pootočenieTvaru_Záloha = robot.pootočenieTvaru;


				robot.aktívnePlátno = null;
				robot.obrázokAktívnehoPlátna = obrázok;
				robot.grafikaAktívnehoPlátna = grafika;

				robot.peroPoložené = true;
				robot.kresliTvary = true;

				robot.domaX = robot.aktuálneX;
				robot.domaY = robot.aktuálneY;
				robot.aktuálnyUhol += robot.pootočenieTvaru;
				robot.aktuálnyUhol %= 360;
				if (robot.aktuálnyUhol < 0) robot.aktuálnyUhol += 360;
				robot.uholDoma = robot.aktuálnyUhol;
				robot.pootočenieTvaruDoma = robot.pootočenieTvaru;


				// domov()
				robot.kreslímVlastnýTvar = true;
				tvar.kresli(robot);
				robot.kreslímVlastnýTvar = false;


				robot.aktívnePlátno = aktívnePlátno_Záloha;
				robot.obrázokAktívnehoPlátna = obrázokAktívnehoPlátna_Záloha;
				robot.grafikaAktívnehoPlátna = grafikaAktívnehoPlátna_Záloha;

				robot.peroPoložené = peroPoložené_Záloha;
				robot.viditeľný = viditeľný_Záloha;
				robot.kresliTvary = kresliTvary_Záloha;
				robot.vypĺňajTvary = vypĺňajTvary_Záloha;

				robot.aktuálneX = aktuálneX_Záloha;
				robot.aktuálneY = aktuálneY_Záloha;
				robot.aktuálnyUhol = aktuálnyUhol_Záloha;
				robot.domaX = domaX_Záloha;
				robot.domaY = domaY_Záloha;
				robot.uholDoma = uholDoma_Záloha;

				robot.farbaDoma = farbaDoma_Záloha;
				robot.cieľováFarbaDoma = cieľováFarbaDoma_Záloha;
				robot.zrušCieľovúFarbuDoma = zrušCieľovúFarbuDoma_Záloha;
				robot.polomerPeraDoma = polomerPeraDoma_Záloha;
				robot.peroPoloženéDoma = peroPoloženéDoma_Záloha;
				robot.viditeľnýDoma = viditeľnýDoma_Záloha;
				robot.veľkosťDoma = veľkosťDoma_Záloha;
				robot.pomerDoma = pomerDoma_Záloha;
				robot.priehľadnosťDoma = priehľadnosťDoma_Záloha;
				robot.písmoDoma = písmoDoma_Záloha;
				robot.pootočenieTvaruDoma = pootočenieTvaruDoma_Záloha;

				robot.aktuálnePísmo = aktuálnePísmo_Záloha;
				robot.čiara = čiara_Záloha;
				robot.farbaRobota = farbaRobota_Záloha;
				robot.cieľováFarba = cieľováFarba_Záloha;
				robot.použiKruhovýNáter = použiKruhovýNáter_Záloha;
				robot.polomerPera = polomerPera_Záloha;

				robot.priehľadnosť = priehľadnosť_Záloha;
				robot.veľkosť = veľkosť_Záloha;
				robot.pomerVeľkosti = pomer_Záloha;
				robot.zaoblenieX = zaoblenieX_Záloha;
				robot.zaoblenieY = zaoblenieY_Záloha;
				robot.pôvodnáVeľkosť = pôvodnáVeľkosť_Záloha;
				robot.pôvodnýPomer = pôvodnýPomer_Záloha;
				robot.pootočenieTvaru = pootočenieTvaru_Záloha;

				robot.spôsobKreslenia = spôsobKreslenia_Záloha;
			}

			/*packagePrivate*/ void kresliSpojnice(
				BufferedImage obrázok, Graphics2D grafika)
			{
				Color farba = null, farbaKonca = null;

				for (Spojnica s : spojnice)
				{
					if (s.viditeľná && s.cieľ.viditeľný())
					{
						// if (null != s.farba) grafika.setColor(s.farba);
						// else grafika.setColor(farbaRobota);

						if (null == s.farba)
							farba = farbaRobota;
						else
							farba = s.farba;

						if (null == s.farbaKonca)
							farbaKonca = s.cieľ.farbaRobota;
						else
							farbaKonca = s.farbaKonca;

						if (null != s.čiara) grafika.setStroke(s.čiara);
						else grafika.setStroke(čiara);

						if (null != s.orezanieZačiatku ||
							null != s.orezanieKonca)
						{
							Shape clip, záloha = grafika.getClip();
							if (null == záloha) clip = new Rectangle.
								Double(0, 0, obrázok.getWidth(),
									obrázok.getHeight());
							else
								clip = záloha;

							Area oblasťOrezania = new Area(clip);

							Area oblasťZačiatku;

							if (null != s.orezanieZačiatku)
							{
								oblasťZačiatku = new Area(s.orezanieZačiatku);

								if ((aktuálnyUhol + pootočenieTvaru) != 90 ||
									aktuálneX != 0 || aktuálneY != 0)
								{
									AffineTransform at = new AffineTransform();
									at.rotate(toRadians(
										90 - (aktuálnyUhol + pootočenieTvaru)),
										Svet.prepočítajX(aktuálneX),
										Svet.prepočítajY(aktuálneY));
									at.translate(aktuálneX, -aktuálneY);
									oblasťZačiatku = oblasťZačiatku.
										createTransformedArea(at);
								}

								oblasťOrezania.subtract(oblasťZačiatku);
							}
							else oblasťZačiatku = null;

							Area oblasťKonca;

							if (null != s.orezanieKonca)
							{
								oblasťKonca = new Area(s.orezanieKonca);

								if ((s.cieľ.aktuálnyUhol +
									s.cieľ.pootočenieTvaru) != 90 ||
									s.cieľ.aktuálneX != 0 ||
									s.cieľ.aktuálneY != 0)
								{
									AffineTransform at = new AffineTransform();
									at.rotate(toRadians(
										90 - (s.cieľ.aktuálnyUhol +
											s.cieľ.pootočenieTvaru)),
										Svet.prepočítajX(s.cieľ.aktuálneX),
										Svet.prepočítajY(s.cieľ.aktuálneY));
									at.translate(s.cieľ.aktuálneX,
										-s.cieľ.aktuálneY);
									oblasťKonca = oblasťKonca.
										createTransformedArea(at);
								}

								oblasťOrezania.subtract(oblasťKonca);
							}
							else oblasťKonca = null;

							grafika.setClip(oblasťOrezania);

							Line2D.Double čiaraSpojnice;

							if (0 == s.vysunutieZačiatku &&
								0 == s.vysunutieKonca)
								čiaraSpojnice = new Line2D.Double(
									Svet.prepočítajX(aktuálneX),
									Svet.prepočítajY(aktuálneY),
									Svet.prepočítajX(s.cieľ.aktuálneX),
									Svet.prepočítajY(s.cieľ.aktuálneY));
							else
							{
								double α = toRadians(
									s.robot.smerNa(s.cieľ) - 90);
								double Δx1 = cos(α) * s.vysunutieZačiatku;
								double Δy1 = sin(α) * s.vysunutieZačiatku;
								double Δx2 = cos(α) * s.vysunutieKonca;
								double Δy2 = sin(α) * s.vysunutieKonca;

								čiaraSpojnice = new Line2D.Double(
									Svet.prepočítajX(aktuálneX + Δx1),
									Svet.prepočítajY(aktuálneY + Δy1),
									Svet.prepočítajX(s.cieľ.aktuálneX + Δx2),
									Svet.prepočítajY(s.cieľ.aktuálneY + Δy2));
							}

							if (farba.equals(farbaKonca))
								grafika.setColor(farba);
							else
								grafika.setPaint(new GradientPaint(
									čiaraSpojnice.getP1(), farba,
									čiaraSpojnice.getP2(), farbaKonca));

							grafika.draw(čiaraSpojnice);

							if ((null != s.značkaZačiatku &&
								null != s.značkaZačiatku.vlastnéOrezanie) ||
								(null != s.značkaKonca &&
								null != s.značkaKonca.vlastnéOrezanie))
							{
								oblasťOrezania = new Area(clip);

								if (null != s.značkaZačiatku &&
									null != s.značkaZačiatku.vlastnéOrezanie)
								{
									Area vlastnáOblasťZačiatku =
										new Area(s.značkaZačiatku.
											vlastnéOrezanie);

									if ((aktuálnyUhol +
										pootočenieTvaru) != 90 ||
										aktuálneX != 0 || aktuálneY != 0)
									{
										AffineTransform at =
											new AffineTransform();
										at.rotate(toRadians(
											90 - (aktuálnyUhol +
												pootočenieTvaru)),
											Svet.prepočítajX(aktuálneX),
											Svet.prepočítajY(aktuálneY));
										at.translate(aktuálneX, -aktuálneY);
										vlastnáOblasťZačiatku =
											vlastnáOblasťZačiatku.
												createTransformedArea(at);
									}

									oblasťOrezania.subtract(
										vlastnáOblasťZačiatku);
								}
								else if (null != oblasťZačiatku)
									oblasťOrezania.subtract(oblasťZačiatku);

								if (null != s.značkaKonca &&
									null != s.značkaKonca.vlastnéOrezanie)
								{
									Area vlastnáOblasťKonca =
										new Area(s.značkaKonca.
											vlastnéOrezanie);

									if ((s.cieľ.aktuálnyUhol +
										s.cieľ.pootočenieTvaru) != 90 ||
										s.cieľ.aktuálneX != 0 ||
										s.cieľ.aktuálneY != 0)
									{
										AffineTransform at =
											new AffineTransform();
										at.rotate(toRadians(
											90 - (s.cieľ.aktuálnyUhol +
												s.cieľ.pootočenieTvaru)),
											Svet.prepočítajX(s.cieľ.aktuálneX),
											Svet.prepočítajY(s.cieľ.aktuálneY));
										at.translate(s.cieľ.aktuálneX,
											-s.cieľ.aktuálneY);
										vlastnáOblasťKonca =
											vlastnáOblasťKonca.
												createTransformedArea(at);
									}

									oblasťOrezania.subtract(
										vlastnáOblasťKonca);
								}
								else if (null != oblasťKonca)
									oblasťOrezania.subtract(oblasťKonca);

								grafika.setClip(oblasťOrezania);
							}

							if (null != s.značkaZačiatku)
							{
								s.značkaZačiatku.vypočítajPolohu(
									oblasťZačiatku, čiaraSpojnice);
								s.značkaZačiatku.kresliZnačku(obrázok, grafika);
							}

							if (null != s.značkaKonca)
							{
								s.značkaKonca.vypočítajPolohu(
									oblasťKonca, čiaraSpojnice);
								s.značkaKonca.kresliZnačku(obrázok, grafika);
							}

							grafika.setClip(clip);
						}
						else
						{
							Line2D.Double čiaraSpojnice;

							if (0 == s.vysunutieZačiatku &&
								0 == s.vysunutieKonca)
								čiaraSpojnice = new Line2D.Double(
									Svet.prepočítajX(aktuálneX),
									Svet.prepočítajY(aktuálneY),
									Svet.prepočítajX(s.cieľ.aktuálneX),
									Svet.prepočítajY(s.cieľ.aktuálneY));
							else
							{
								double α = toRadians(
									s.robot.smerNa(s.cieľ) - 90);
								double Δx1 = cos(α) * s.vysunutieZačiatku;
								double Δy1 = sin(α) * s.vysunutieZačiatku;
								double Δx2 = cos(α) * s.vysunutieKonca;
								double Δy2 = sin(α) * s.vysunutieKonca;

								čiaraSpojnice = new Line2D.Double(
									Svet.prepočítajX(aktuálneX + Δx1),
									Svet.prepočítajY(aktuálneY + Δy1),
									Svet.prepočítajX(s.cieľ.aktuálneX + Δx2),
									Svet.prepočítajY(s.cieľ.aktuálneY + Δy2));
							}

							if (farba.equals(farbaKonca))
								grafika.setColor(farba);
							else
								grafika.setPaint(new GradientPaint(
									čiaraSpojnice.getP1(), farba,
									čiaraSpojnice.getP2(), farbaKonca));

							grafika.draw(čiaraSpojnice);

							if (null != s.značkaZačiatku)
							{
								s.značkaZačiatku.vypočítajPolohu(null, null);
								s.značkaZačiatku.kresliZnačku(obrázok, grafika);
							}

							if (null != s.značkaKonca)
							{
								s.značkaKonca.vypočítajPolohu(null, null);
								s.značkaKonca.kresliZnačku(obrázok, grafika);
							}
						}
					}
				}
			}

			// Najjednoduchší spôsob zálohovania a obnovy väčšiny vlastností
			// robota. Rovnaké vlastnosti zálohuje a obnovuje kreslenie
			// vlastného tvaru, ale tam je kód vložený „inline“ (kreslenie
			// je aj bez toho výkonovo citlivá vec).
			/*packagePrivate*/ static class ZálohaVlastností
			{
				GRobot robot;

				ZálohaVlastností(GRobot robot)
				{
					this.robot = robot;
					zálohuj();
				}

				int spôsobKreslenia_Záloha;

				Plátno aktívnePlátno_Záloha;
				BufferedImage obrázokAktívnehoPlátna_Záloha;
				Graphics2D grafikaAktívnehoPlátna_Záloha;

				boolean peroPoložené_Záloha;
				boolean viditeľný_Záloha;
				boolean kresliTvary_Záloha;
				boolean vypĺňajTvary_Záloha;

				double aktuálneX_Záloha;
				double aktuálneY_Záloha;
				double aktuálnyUhol_Záloha;
				double domaX_Záloha;
				double domaY_Záloha;
				double uholDoma_Záloha;

				Farba farbaDoma_Záloha;
				Farba cieľováFarbaDoma_Záloha;
				boolean zrušCieľovúFarbuDoma_Záloha;
				Double polomerPeraDoma_Záloha;
				Boolean peroPoloženéDoma_Záloha;
				Boolean viditeľnýDoma_Záloha;
				Double veľkosťDoma_Záloha;
				Double pomerDoma_Záloha;
				Float priehľadnosťDoma_Záloha;
				Písmo písmoDoma_Záloha;
				Double pootočenieTvaruDoma_Záloha;

				Písmo aktuálnePísmo_Záloha;
				Stroke čiara_Záloha;
				Farba farbaRobota_Záloha;
				Farba cieľováFarba_Záloha;
				boolean použiKruhovýNáter_Záloha;
				double polomerPera_Záloha;

				float priehľadnosť_Záloha;
				double veľkosť_Záloha;
				double pomer_Záloha;
				double zaoblenieX_Záloha;
				double zaoblenieY_Záloha;
				double pôvodnáVeľkosť_Záloha;
				double pôvodnýPomer_Záloha;
				double pootočenieTvaru_Záloha;

				void zálohuj()
				{
					spôsobKreslenia_Záloha = robot.spôsobKreslenia;

					aktívnePlátno_Záloha = robot.aktívnePlátno;
					obrázokAktívnehoPlátna_Záloha =
						robot.obrázokAktívnehoPlátna;
					grafikaAktívnehoPlátna_Záloha =
						robot.grafikaAktívnehoPlátna;

					peroPoložené_Záloha = robot.peroPoložené;
					viditeľný_Záloha = robot.viditeľný;
					kresliTvary_Záloha = robot.kresliTvary;
					vypĺňajTvary_Záloha = robot.vypĺňajTvary;

					aktuálneX_Záloha = robot.aktuálneX;
					aktuálneY_Záloha = robot.aktuálneY;
					aktuálnyUhol_Záloha = robot.aktuálnyUhol;
					domaX_Záloha = robot.domaX;
					domaY_Záloha = robot.domaY;
					uholDoma_Záloha = robot.uholDoma;

					farbaDoma_Záloha = robot.farbaDoma;
					cieľováFarbaDoma_Záloha = robot.cieľováFarbaDoma;
					zrušCieľovúFarbuDoma_Záloha = robot.zrušCieľovúFarbuDoma;
					polomerPeraDoma_Záloha = robot.polomerPeraDoma;
					peroPoloženéDoma_Záloha = robot.peroPoloženéDoma;
					viditeľnýDoma_Záloha = robot.viditeľnýDoma;
					veľkosťDoma_Záloha = robot.veľkosťDoma;
					pomerDoma_Záloha = robot.pomerDoma;
					priehľadnosťDoma_Záloha = robot.priehľadnosťDoma;
					písmoDoma_Záloha = robot.písmoDoma;
					pootočenieTvaruDoma_Záloha = robot.pootočenieTvaruDoma;

					aktuálnePísmo_Záloha = robot.aktuálnePísmo;
					čiara_Záloha = robot.čiara;
					farbaRobota_Záloha = robot.farbaRobota;
					cieľováFarba_Záloha = robot.cieľováFarba;
					použiKruhovýNáter_Záloha = robot.použiKruhovýNáter;
					polomerPera_Záloha = robot.polomerPera;

					priehľadnosť_Záloha = robot.priehľadnosť;
					veľkosť_Záloha = robot.veľkosť;
					pomer_Záloha = robot.pomerVeľkosti;
					zaoblenieX_Záloha = robot.zaoblenieX;
					zaoblenieY_Záloha = robot.zaoblenieY;
					pôvodnáVeľkosť_Záloha = robot.pôvodnáVeľkosť;
					pôvodnýPomer_Záloha = robot.pôvodnýPomer;
					pootočenieTvaru_Záloha = robot.pootočenieTvaru;
				}

				void obnov()
				{
					robot.aktívnePlátno = aktívnePlátno_Záloha;
					robot.obrázokAktívnehoPlátna = obrázokAktívnehoPlátna_Záloha;
					robot.grafikaAktívnehoPlátna = grafikaAktívnehoPlátna_Záloha;

					robot.peroPoložené = peroPoložené_Záloha;
					robot.viditeľný = viditeľný_Záloha;
					robot.kresliTvary = kresliTvary_Záloha;
					robot.vypĺňajTvary = vypĺňajTvary_Záloha;

					robot.aktuálneX = aktuálneX_Záloha;
					robot.aktuálneY = aktuálneY_Záloha;
					robot.aktuálnyUhol = aktuálnyUhol_Záloha;
					robot.domaX = domaX_Záloha;
					robot.domaY = domaY_Záloha;
					robot.uholDoma = uholDoma_Záloha;

					robot.farbaDoma = farbaDoma_Záloha;
					robot.cieľováFarbaDoma = cieľováFarbaDoma_Záloha;
					robot.zrušCieľovúFarbuDoma = zrušCieľovúFarbuDoma_Záloha;
					robot.polomerPeraDoma = polomerPeraDoma_Záloha;
					robot.peroPoloženéDoma = peroPoloženéDoma_Záloha;
					robot.viditeľnýDoma = viditeľnýDoma_Záloha;
					robot.veľkosťDoma = veľkosťDoma_Záloha;
					robot.pomerDoma = pomerDoma_Záloha;
					robot.priehľadnosťDoma = priehľadnosťDoma_Záloha;
					robot.písmoDoma = písmoDoma_Záloha;
					robot.pootočenieTvaruDoma = pootočenieTvaruDoma_Záloha;

					robot.aktuálnePísmo = aktuálnePísmo_Záloha;
					robot.čiara = čiara_Záloha;
					robot.farbaRobota = farbaRobota_Záloha;
					robot.cieľováFarba = cieľováFarba_Záloha;
					robot.použiKruhovýNáter = použiKruhovýNáter_Záloha;
					robot.polomerPera = polomerPera_Záloha;

					robot.priehľadnosť = priehľadnosť_Záloha;
					robot.veľkosť = veľkosť_Záloha;
					robot.pomerVeľkosti = pomer_Záloha;
					robot.zaoblenieX = zaoblenieX_Záloha;
					robot.zaoblenieY = zaoblenieY_Záloha;
					robot.pôvodnáVeľkosť = pôvodnáVeľkosť_Záloha;
					robot.pôvodnýPomer = pôvodnýPomer_Záloha;
					robot.pootočenieTvaru = pootočenieTvaru_Záloha;

					robot.spôsobKreslenia = spôsobKreslenia_Záloha;
				}
			}


		// Práca s tvarom hviezdy

			// Inštancia produkujúca tvar a overujúca prítomnosť bodu v tvare
			private final Hviezda hviezda = new Hviezda();

			// Faktor na výpočet polomeru vpísanej kružnice (ten sa používa
			// len na zistenie prítomnosti bodu v hviezde):
			private final static double faktorHviezdy0 = 0.38196601125010504;
			// V skutočnosti je:
			//	faktorHviezdy0 = faktorHviezdy1 × sin 18° / sin 36°
			//	(36° je, evidentne, desatina z 360° – pretože päťcípa hviezda
			//	má 10 uhlov; v podstate to je desaťuholník s alternujúcimi
			//	uhlami pri stranách)

			// Faktor na výpočet dĺžky strany hviezdy (to jest dĺžky úsečiek,
			// z ktorých je hviezda vytvorená – všetky sú zhodou okolností
			// rovnaké):
			private final static double faktorHviezdy1 = 0.7265425280053608;
			// Vypočítané ako: √(5 − 2√5)
			//	(alebo v jazyku Javy: sqrt(5 - 2 * sqrt(5));)

			// Trieda zoskupujúca základné vnútorné činnosti s hviezdou
			private class Hviezda
			{
				private double bod[] = new double[2];
				private double tvar[][] = new double[11][2];

				private double znamienko(int a, int b)
				{
					return (bod[0] - tvar[b][0]) * (tvar[a][1] - tvar[b][1]) -
						(bod[1] - tvar[b][1]) * (tvar[a][0] - tvar[b][0]);
				}

				// http://stackoverflow.com/questions/2049582/how-to-determine-a-point-in-a-2d-triangle
				// http://totologic.blogspot.sk/2014/01/accurate-point-in-triangle-test.html
				private boolean bodVTrojuholníku(int a1, int a2, int a3)
				{
					boolean b1 = znamienko(a1, a2) < 0.0;
					boolean b2 = znamienko(a2, a3) < 0.0;
					boolean b3 = znamienko(a3, a1) < 0.0;
					return b1 == b2 && b2 == b3;
				}

				public Shape daj(double polomer)
				{
					double dĺžka = polomer * faktorHviezdy1;
					double uhol = aktuálnyUhol;
					double x1 = Svet.prepočítajX(aktuálneX +
						cos(toRadians(uhol)) * polomer);
					double y1 = Svet.prepočítajY(aktuálneY +
						sin(toRadians(uhol)) * polomer);

					Path2D.Double hviezda = new Path2D.Double();

					uhol += 162;
					x1 += cos(toRadians(uhol)) * dĺžka;
					y1 -= sin(toRadians(uhol)) * dĺžka;
					hviezda.moveTo(x1, y1);

					uhol -= 72;
					x1 += cos(toRadians(uhol)) * dĺžka;
					y1 -= sin(toRadians(uhol)) * dĺžka;
					hviezda.lineTo(x1, y1);

					for (int i = 1; i < 5; ++i)
					{
						uhol += 144;
						x1 += cos(toRadians(uhol)) * dĺžka;
						y1 -= sin(toRadians(uhol)) * dĺžka;
						hviezda.lineTo(x1, y1);

						uhol -= 72;
						x1 += cos(toRadians(uhol)) * dĺžka;
						y1 -= sin(toRadians(uhol)) * dĺžka;
						hviezda.lineTo(x1, y1);
					}

					hviezda.closePath();
					return hviezda;
				}

				public boolean bodV(double x, double y, double polomer)
				{
					double Δx = x - aktuálneX;
					double Δy = y - aktuálneY;

					if ((Δx * Δx + Δy * Δy) > polomer * polomer) return false;

					double polomer2 = polomer * faktorHviezdy0;

					if ((Δx * Δx + Δy * Δy) <= polomer2 * polomer2) return true;

					bod[0] = x;
					bod[1] = y;

					double dĺžka = polomer * faktorHviezdy1;
					double uhol = aktuálnyUhol;
					double x1 = aktuálneX + cos(toRadians(uhol)) * polomer;
					double y1 = aktuálneY + sin(toRadians(uhol)) * polomer;

					tvar[1][0] = x1;
					tvar[1][1] = y1;

					uhol -= 162;
					x1 += cos(toRadians(uhol)) * dĺžka;
					y1 += sin(toRadians(uhol)) * dĺžka;
					tvar[2][0] = x1;
					tvar[2][1] = y1;

					uhol += 72;
					x1 += cos(toRadians(uhol)) * dĺžka;
					y1 += sin(toRadians(uhol)) * dĺžka;
					tvar[3][0] = x1;
					tvar[3][1] = y1;

					for (int i = 2; i < 5; ++i)
					{
						uhol -= 144;
						x1 += cos(toRadians(uhol)) * dĺžka;
						y1 += sin(toRadians(uhol)) * dĺžka;
						tvar[i * 2][0] = x1;
						tvar[i * 2][1] = y1;

						uhol += 72;
						x1 += cos(toRadians(uhol)) * dĺžka;
						y1 += sin(toRadians(uhol)) * dĺžka;
						tvar[i * 2 + 1][0] = x1;
						tvar[i * 2 + 1][1] = y1;
					}

					uhol -= 144;
					x1 += cos(toRadians(uhol)) * dĺžka;
					y1 += sin(toRadians(uhol)) * dĺžka;
					tvar[10][0] = tvar[0][0] = x1;
					tvar[10][1] = tvar[0][1] = y1;

					for (int i = 0; i < 9; i += 2)
						if (bodVTrojuholníku(i, i + 1, i + 2)) return true;

					return false;
				}
			}

		// Pôsobisko

			// Činnosti s pôsobiskom

				private void aktualizujPôsobisko()
				{
					// System.out.println("XY1: " + aktuálneX + ", " +
					// 	aktuálneY);

					if ((aktuálneX - (polomerPera / 2)) < minimálneX)
						minimálneX = aktuálneX - (polomerPera / 2);
					if ((aktuálneX + (polomerPera / 2)) > maximálneX)
						maximálneX = aktuálneX + (polomerPera / 2);
					if ((aktuálneY - (polomerPera / 2)) < minimálneY)
						minimálneY = aktuálneY - (polomerPera / 2);
					if ((aktuálneY + (polomerPera / 2)) > maximálneY)
						maximálneY = aktuálneY + (polomerPera / 2);

					// System.out.println("  : " + minimálneX + ", " +
					// 	minimálneY + " – " + maximálneX + ", " + maximálneY);
				}

				private void aktualizujPôsobisko(double polomer)
				{
					// System.out.println("XY2: " + aktuálneX + ", " +
					// 	aktuálneY + ", " + polomer);

					if ((aktuálneX - polomer) < minimálneX)
						minimálneX = aktuálneX - polomer;
					if ((aktuálneX + polomer) > maximálneX)
						maximálneX = aktuálneX + polomer;
					if ((aktuálneY - polomer) < minimálneY)
						minimálneY = aktuálneY - polomer;
					if ((aktuálneY + polomer) > maximálneY)
						maximálneY = aktuálneY + polomer;

					// System.out.println("  : " + minimálneX + ", " +
					// 	minimálneY + " – " + maximálneX + ", " + maximálneY);
				}

				private void aktualizujPôsobisko(double x, double y)
				{
					// System.out.println("XY3: " + x + ", " + y);

					if (x < minimálneX) minimálneX = x;
					if (x > maximálneX) maximálneX = x;
					if (y < minimálneY) minimálneY = y;
					if (y > maximálneY) maximálneY = y;

					// System.out.println("  : " + minimálneX + ", " +
					// 	minimálneY + " – " + maximálneX + ", " + maximálneY);
				}

				private void aktualizujPôsobisko(double novéMinX,
					double novéMinY, double novéMaxX, double novéMaxY)
				{
					// System.out.println("minMax: " + novéMinX + ", " +
					// 	novéMinY + " – " + novéMaxX + ", " + novéMaxY);

					if (novéMinX < minimálneX) minimálneX = novéMinX;
					if (novéMaxX > maximálneX) maximálneX = novéMaxX;
					if (novéMinY < minimálneY) minimálneY = novéMinY;
					if (novéMaxY > maximálneY) maximálneY = novéMaxY;

					// System.out.println("  : " + minimálneX + ", " +
					// 	minimálneY + " – " + maximálneX + ", " + maximálneY);
				}

				private void aktualizujPôsobisko(Rectangle2D rozsah)
				{
					aktualizujPôsobisko(
						Svet.prepočítajSpäťX(rozsah.getX()),
						Svet.prepočítajSpäťY(rozsah.getY() + rozsah.getHeight()),
						Svet.prepočítajSpäťX(rozsah.getX() + rozsah.getWidth()),
						Svet.prepočítajSpäťY(rozsah.getY()));
				}

			// Kreslenie pôsobiska

				/*packagePrivate*/ void kresliPôsobisko(Graphics2D grafika)
				{
					grafika.setColor(farbaPôsobiska);
					grafika.fillRect(
						(int)Svet.prepočítajX(minimálneX),
						(int)(Svet.prepočítajY(minimálneY) -
							maximálneY + minimálneY),
						(int)(maximálneX - minimálneX),
						(int)(maximálneY - minimálneY));
				}


		// Kontrola ohraničenia

			// Trieda uchovávajúca opkujúcu sa aktivitu pri pretáčaní
			private interface PretočOhraničenie
			{
				public void pretoč();
			}

			// Ištancia triedy (vyššie)
			private PretočOhraničenie pretočOhraničenie = null;

			// Metóda registrujúca aktivitu pri pretáčaní
			private void registrujPretočOhraničenie(
				PretočOhraničenie pretočOhraničenie)
			{
				this.pretočOhraničenie = (PRETOČ == zálohaOhraničenia) ?
					pretočOhraničenie : null;
			}

			// Metóda spúšťaná pred zmenou súradníc v rámci procesu ohraničenia
			private void zálohujÚdajeOhraničenia()
			{
				if (ŽIADNE != aktuálneOhraničenie)
				{
					zálohaUhla = aktuálnyUhol;
					stavMimoHraníc[0].x = // zálohaX =
						aktuálneX;
					stavMimoHraníc[0].y = // zálohaY =
						aktuálneY;
				}
			}

			// Jadro – metóda zariaďujúca zmenu súradníc pri procese ohraničenia
			private boolean vykonajOhraničenie()
			{
				double Δx = 0.0, Δy = 0.0;
				boolean aplikuj = false;

				novýCieľX = aktuálneX;
				novýCieľY = aktuálneY;

				if (PRETOČ == zálohaOhraničenia)
				{
					if (aktuálneX < ľaváHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = ľaváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δx = praváHranica - ľaváHranica;
						aplikuj = true;
					}
					else if (aktuálneX > praváHranica)
					{
						stavMimoHraníc[2].x = praváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δx = ľaváHranica - praváHranica;
						aplikuj = true;
					}

					if (aktuálneY < dolnáHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = dolnáHranica;

						Δy = hornáHranica - dolnáHranica;
						aplikuj = true;
					}
					else if (aktuálneY > hornáHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = hornáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δy = dolnáHranica - hornáHranica;
						aplikuj = true;
					}

					if (aplikuj)
					{
						stavMimoHraníc[1].x = stavMimoHraníc[0].x + Δx;
						stavMimoHraníc[1].y = stavMimoHraníc[0].y + Δy;

						Bod[] poleBodov = new Bod[stavMimoHraníc.length];
						System.arraycopy(stavMimoHraníc, 0,
							poleBodov, 0, stavMimoHraníc.length);

						boolean mimoHraníc = mimoHraníc(
							poleBodov, zálohaUhla);
						boolean mimoHranic = mimoHranic(
							poleBodov, zálohaUhla);
						aplikuj = mimoHraníc && mimoHranic;
					}

					if (aplikuj)
					{
						novýCieľX += Δx;
						novýCieľY += Δy;
						skočNa(stavMimoHraníc[0].x += Δx,
							stavMimoHraníc[0].y += Δy);
						aktuálnyUhol = zálohaUhla; // môže ísť aj po oblúku
						mimoHraníc(); mimoHranic();
					}
				}
				else if (PLOT == zálohaOhraničenia)
				{
					if (aktuálneX < ľaváHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = ľaváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δx = ľaváHranica - aktuálneX;
						aplikuj = true;
					}
					else if (aktuálneX > praváHranica)
					{
						stavMimoHraníc[2].x = praváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δx = praváHranica - aktuálneX;
						aplikuj = true;
					}

					if (aktuálneY < dolnáHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = dolnáHranica;

						Δy = dolnáHranica - aktuálneY;
						aplikuj = true;
					}
					else if (aktuálneY > hornáHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = hornáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δy = hornáHranica - aktuálneY;
						aplikuj = true;
					}

					if (aplikuj)
					{
						stavMimoHraníc[1].x = novýCieľX + Δx;
						stavMimoHraníc[1].y = novýCieľY + Δy;

						Bod[] poleBodov = new Bod[stavMimoHraníc.length];
						System.arraycopy(stavMimoHraníc, 0,
							poleBodov, 0, stavMimoHraníc.length);

						boolean mimoHraníc = mimoHraníc(
							poleBodov, zálohaUhla);
						boolean mimoHranic = mimoHranic(
							poleBodov, zálohaUhla);
						aplikuj = mimoHraníc && mimoHranic;
					}

					if (aplikuj)
					{
						choďNa(novýCieľX += Δx, novýCieľY += Δy);
						mimoHraníc(); mimoHranic();
					}

					return false;
				}
				else if (ODRAZ == zálohaOhraničenia)
				{
					if (aktuálneX < ľaváHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = ľaváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δx = 2.0 * (ľaváHranica - aktuálneX);
						aplikuj = true;
					}
					else if (aktuálneX > praváHranica)
					{
						stavMimoHraníc[2].x = praváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δx = 2.0 * (praváHranica - aktuálneX);
						aplikuj = true;
					}

					if (aktuálneY < dolnáHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = dolnáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = dolnáHranica;

						Δy = 2.0 * (dolnáHranica - aktuálneY);
						aplikuj = true;
					}
					else if (aktuálneY > hornáHranica)
					{
						stavMimoHraníc[2].x = ľaváHranica;
						stavMimoHraníc[2].y = hornáHranica;
						stavMimoHraníc[3].x = praváHranica;
						stavMimoHraníc[3].y = hornáHranica;

						Δy = 2.0 * (hornáHranica - aktuálneY);
						aplikuj = true;
					}

					if (aplikuj)
					{
						stavMimoHraníc[1].x = novýCieľX + Δx;
						stavMimoHraníc[1].y = novýCieľY + Δy;

						Bod[] poleBodov = new Bod[stavMimoHraníc.length];
						System.arraycopy(stavMimoHraníc, 0,
							poleBodov, 0, stavMimoHraníc.length);

						boolean mimoHraníc = mimoHraníc(
							poleBodov, zálohaUhla);
						boolean mimoHranic = mimoHranic(
							poleBodov, zálohaUhla);
						aplikuj = mimoHraníc && mimoHranic;
					}

					if (aplikuj)
					{
						choďNa(novýCieľX += Δx, novýCieľY += Δy);
						mimoHraníc(); mimoHranic();
					}

					// return false;
				}

				return aplikuj;
			}

			// Metóda, ktorou sa začína proces ohraničenia
			private boolean vyriešOhraničenie()
			{
				if (ŽIADNE == aktuálneOhraničenie) return false;
				zálohaOhraničenia = aktuálneOhraničenie;
				aktuálneOhraničenie = ŽIADNE;
				if (vykonajOhraničenie()) return true;
				aktuálneOhraničenie = zálohaOhraničenia;
				return false;
			}

			// Metóda, ktorou sa pokračuje a končí pri procese ohraničenia
			private boolean doriešOhraničenie()
			{
				if (null != pretočOhraničenie)
				{
					// Rozhranie zabezpečujúce rekurzívne volanie
					// volajúcej metódy pri pretáčaní:
					if (Svet.nekresli)
						pretočOhraničenie.pretoč();
					else
					{
						Svet.nekresli = true;
						pretočOhraničenie.pretoč();
						Svet.nekresli = false;
					}
				}

				if (vykonajOhraničenie()) return true;
				aktuálneOhraničenie = zálohaOhraničenia;
				return false;
			}


		// Práca s oblasťami

			// Kreslenie oblastí

				/*packagePrivate*/ void kresli(Area oblasť)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(oblasť);
					// aktualizujPôsobisko(oblasť.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

			// Vypĺňanie oblastí

				/*packagePrivate*/ void vyplň(Area oblasť)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(oblasť);
					// aktualizujPôsobisko(oblasť.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				/*packagePrivate*/ void vyplň(Area oblasť, String súbor)
				{
					BufferedImage obrázok = Obrázok.súborNaObrázok(súbor);

					grafikaAktívnehoPlátna.setPaint(
						new TexturePaint(obrázok, new Rectangle2D.Double(
							Svet.posuňVýplňX, Svet.posuňVýplňY,
							obrázok.getWidth()  * Svet.mierkaVýplneX,
							obrázok.getHeight() * Svet.mierkaVýplneY)));

					if (0 == Svet.otočVýplňΑ)
						grafikaAktívnehoPlátna.fill(oblasť);
					else
					{
						double β = toRadians(Svet.otočVýplňΑ);
						grafikaAktívnehoPlátna.rotate(-β,
							Svet.otočVýplňX, Svet.otočVýplňY);
						Area a = oblasť.createTransformedArea(
							AffineTransform.getRotateInstance(β,
							Svet.otočVýplňX, Svet.otočVýplňY));

						grafikaAktívnehoPlátna.fill(a);

						grafikaAktívnehoPlátna.rotate(β,
							Svet.otočVýplňX, Svet.otočVýplňY);
					}

					// aktualizujPôsobisko(oblasť.getBounds2D());
					Svet.automatickéPrekreslenie();
				}

				/*packagePrivate*/ void vyplň(Area oblasť, Image výplň)
				{
					BufferedImage obrázok =
						Obrázok.preveďNaBufferedImage(výplň);
					BufferedImage relevantný =
						Obrázok.dajRelevantnýRaster(obrázok);

					float priehľadnosť = (obrázok instanceof Obrázok) ?
						((Obrázok)obrázok).priehľadnosť : 1.0f;

					if (priehľadnosť > 0)
					{
						grafikaAktívnehoPlátna.setPaint(
							new TexturePaint(relevantný, new Rectangle2D.Double(
								Svet.posuňVýplňX, Svet.posuňVýplňY,
								relevantný.getWidth(null)  * Svet.mierkaVýplneX,
								relevantný.getHeight(null) * Svet.mierkaVýplneY)));

						Area a = oblasť; double β = 0.0;

						if (0 != Svet.otočVýplňΑ)
						{
							β = toRadians(Svet.otočVýplňΑ);
							grafikaAktívnehoPlátna.rotate(-β,
								Svet.otočVýplňX, Svet.otočVýplňY);
							a = oblasť.createTransformedArea(
								AffineTransform.getRotateInstance(β,
								Svet.otočVýplňX, Svet.otočVýplňY));
						}

						if (priehľadnosť < 1)
						{
							Composite záloha =
								grafikaAktívnehoPlátna.getComposite();
							grafikaAktívnehoPlátna.setComposite(
								AlphaComposite.getInstance(
									AlphaComposite.SRC_OVER, priehľadnosť));
							grafikaAktívnehoPlátna.fill(a);
							grafikaAktívnehoPlátna.setComposite(záloha);
						}
						else
							grafikaAktívnehoPlátna.fill(a);

						if (0 != Svet.otočVýplňΑ)
						{
							grafikaAktívnehoPlátna.rotate(β,
								Svet.otočVýplňX, Svet.otočVýplňY);
						}

						// aktualizujPôsobisko(oblasť.getBounds2D());
						Svet.automatickéPrekreslenie();
					}
				}

		// Rotácia súradníc o uhol zadaný v radiánoch

			/*packagePrivate*/ static double rotovanéXRad(
				double x, double y, double α)
			{
				if (0 == α) return x;
				return (x * cos(α)) - (y * sin(α));
			}

			/*packagePrivate*/ static double rotovanéYRad(
				double x, double y, double α)
			{
				if (0 == α) return y;
				return (x * sin(α)) + (y * cos(α));
			}


	// ------------------------------- //
	//  *** Rôzne súkromné triedy ***  //
	// ------------------------------- //

		// Trieda vrstiev
		@SuppressWarnings("serial")
		/*packagePrivate*/ static class Vrstva extends TreeMap<Integer, GRobot>
		{
			/*
			Poznámky:

			Systém vrstiev je dvojitá stromová mapa (TreeMap), do ktorej sú
			prvky (objekty == roboty) vkladané podľa: čísla vrstvy a ďalej
			podľa poradového čísla robota v globálnom zozname robotov.

			Preradenie z vrstvy do vrstvy je vďaka tomu vykonané relatívne
			jednoducho:
				1. vymazanie zo stromovej mapy aktuálnej vrstvy;
				2. zmena vnútorného poradového čísla vrstvy;
				3. vloženie do stromovej mapy novej vrstvy podľa poradového
				   čísla v globálnom zozname robotov.

			Zaradenie nových robotov do vrstiev je vykonané buď okamžite (ak
			to je možné), alebo počas zlučovania záložného a globálneho
			zoznamu robotov (tesne po zlúčení zoznamov).

			Zmena poradia v rámci vrstvy musí byť vykonaná po každej zmene
			poradia robota v rámci globálneho zoznamu robotov. (Metódy:
			naVrch, naSpodok, vyššie, nižšie…)
			*/

			// Nájdenie alebo vytvorenie (a korektné vloženie) určenej vrstvy
				public static Vrstva daj(int číslo)
				{
					Vrstva vrstva = zoznamVrstiev.get(číslo);
					if (null == vrstva)
					{
						vrstva = new Vrstva();
						zoznamVrstiev.put(číslo, vrstva);
					}
					return vrstva;
				}

			// Vymazanie robotov z ich aktuálnej vrstvy
				public static void vymaž(GRobot robot)
				{
					int index = zoznamRobotov.indexOf(robot);
					if (-1 != index)
					{
						Vrstva vrstva = zoznamVrstiev.get(robot.vrstva);
						if (null != vrstva)
						{
							// Buď nájdem robot na určenej pozícii,
							if (robot == vrstva.get(index))
							{
								vrstva.remove(index);
								return;
							}

							// alebo ho budem hľadať v celej mape…
							for (Map.Entry<Integer, GRobot>
								hľadaj : vrstva.entrySet())
							{
								if (robot == hľadaj.getValue())
								{
									vrstva.remove(hľadaj.getKey());
									return;
								}
							}

							// (Ak zlyhá aj to, robot tam asi nebol…)
						}
					}
				}

				// Vymazanie rozsahu robotov…
				public static void vymaž(int začiatok, int koniec)
				{
					if (0 <= začiatok && 0 <= koniec)
					{
						if (začiatok > koniec)
						{
							int a = začiatok;
							začiatok = koniec;
							koniec = a;
						}

						for (int i = začiatok; i <= koniec; ++i)
							vymaž(zoznamRobotov.get(i));
					}
				}

			// Vloženie robotov do ich aktuálnej vrstvy
				public static void vlož(GRobot robot)
				{
					int index = zoznamRobotov.indexOf(robot);
					if (-1 != index)
					{
						Vrstva vrstva = daj(robot.vrstva);
						if (null != vrstva)
							vrstva.put(index, robot);
					}
				}

				// Vloženie rozsahu robotov…
				public static void vlož(int začiatok, int koniec)
				{
					if (0 <= začiatok && 0 <= koniec)
					{
						if (začiatok > koniec)
						{
							int a = začiatok;
							začiatok = koniec;
							koniec = a;
						}

						for (int i = začiatok; i <= koniec; ++i)
							vlož(zoznamRobotov.get(i));
					}
				}

			// Preradenie robota do inej vrstvy
				public static void preraď(GRobot robot, int vrstva)
				{
					vymaž(robot);
					robot.vrstva = vrstva;
					vlož(robot);
				}
		}


	// ---------------------- //
	//  *** Konštruktory ***  //
	// ---------------------- //

		/**
		 * <p>Predvolený konštruktor nastavujúci predvolené vlastnosti robota.
		 * Pri prvom robote sa zároveň vytvorí svet, čo zahŕňa okno
		 * aplikácie, podlahu a strop.</p>
		 * 
		 * <p class="remark"><b>Poznámka:</b> Každý vytvorený robot je
		 * automaticky zaradený na koniec vnútorného zoznamu robotov. Poradie
		 * v tomto zozname je možné dodatočne ovplyvniť metódami
		 * {@link GRobot#naVrch() naVrch}, {@link GRobot#naSpodok() naSpodok},
		 * {@link GRobot#vyššie() vyššie}, {@link GRobot#nižšie() nižšie},
		 * {@link GRobot#pred(GRobot) pred} a {@link GRobot#za(GRobot)
		 * za}.</p>
		 */
		public GRobot()
		{
			registrujUdalostiRobota();
			Svet.inicializujGrafiku();
			inicializujRobot();
		}

		// Nedá sa :--(
		// public GRobot(javax.swing.JApplet aplet)
		// {
		// 	???
		// 	// inicializujRobot();
		// }

		/**
		 * <p>Konštruktor umožňujúci zmenu titulku okna aplikácie sveta. Okrem
		 * zmeny titulku okna sa správa rovnako ako {@linkplain 
		 * GRobot#GRobot() predvolený konštruktor}.</p>
		 * 
		 * @param novýTitulok nový titulok hlavného okna
		 */
		public GRobot(String novýTitulok)
		{
			registrujUdalostiRobota();
			Svet.inicializujGrafiku();
			Svet.titulok(novýTitulok);
			inicializujRobot();
		}

		/**
		 * <p>Konštruktor umožňujúci stanovenie iných rozmerov kresliacich
		 * plátien (podlahy a stropu) než predvolená. Aby bol tento
		 * konštruktor použiteľný, svet ešte nesmie jestvovať. To znamená,
		 * že úprava rozmerov podlahy a stropu je možná len pri prvom
		 * vytvorenom robote, inak vznikne výnimka. (Častý spôsob je
		 * spustenie príkazu {@code valsuper}{@code (}<em>«rozmery
		 * plátna»</em>{@code )} na začiatku konštruktora
		 * {@linkplain Svet#hlavnýRobot() hlavného robota}.)
		 * Ostatné vlastnosti a správanie tohto konštruktora sú rovnaké ako
		 * pri {@linkplain GRobot#GRobot() predvolenom konštruktore}.</p>
		 * 
		 * <p class="attention"><b>Upozornenie:</b> Zväčšovanie rozmerov
		 * plátna znižuje výkonnosť aplikácie.</p>
		 * 
		 * <p>V súčasnej verzii programovacieho rámca jestvuje metóda
		 * {@link Svet#zmeňRozmeryPlátien(int, int) zmeňRozmeryPlátien}, avšak
		 * je nevyhnutné ju používať len v odôvodnených prípadoch, keďže zmena
		 * rozmerov plátien je komplexný proces.</p>
		 * 
		 * @param nováMaximálnaŠírka nová maximálna šírka kresliacich
		 *     plátien
		 * @param nováMaximálnaVýška nová maximálna výška kresliacich
		 *     plátien
		 * 
		 * @throws GRobotException ak svet už jestvuje
		 * 
		 * @see Svet#zmeňRozmeryPlátien(int, int)
		 */
		public GRobot(int nováMaximálnaŠírka, int nováMaximálnaVýška)
		{
			if (Svet.inicializované)
				throw new GRobotException("Svet už jestvuje!",
					"worldAlreadyExists");

			registrujUdalostiRobota();

			Plátno.šírkaPlátna = nováMaximálnaŠírka;
			Plátno.výškaPlátna = nováMaximálnaVýška;
			Svet.prepočítajParametreVýplne();

			podlaha.vytvorNovéPlátno(
				Plátno.šírkaPlátna, Plátno.výškaPlátna);
			strop.vytvorNovéPlátno(
				Plátno.šírkaPlátna, Plátno.výškaPlátna);
			Svet.obrázokSveta1 = new BufferedImage(Plátno.šírkaPlátna,
				Plátno.výškaPlátna, BufferedImage.TYPE_INT_ARGB);
			Svet.grafikaSveta1 = Svet.obrázokSveta1.createGraphics();

			if (null != Svet.vlnenie) Svet.odstráňVlnenie();
			Svet.obrázokSveta2 = new BufferedImage(Plátno.šírkaPlátna,
				Plátno.výškaPlátna, BufferedImage.TYPE_INT_ARGB);
			Svet.grafikaSveta2 = Svet.obrázokSveta2.createGraphics();
			for (Obrázok obrázok : Obrázok.zoznamObrázkovKnižnice)
				obrázok.upravPosun();

			Svet.inicializujGrafiku();
			inicializujRobot();
		}

		/**
		 * <p>Konštruktor umožňujúci stanovenie iných rozmerov kresliacich
		 * plátien (podlahy a stropu) než je predvolená a zmenu titulku
		 * hlavného okna aplikácie sveta. Aby bol tento konštruktor
		 * použiteľný, svet ešte nesmie jestvovať. To znamená, že úprava
		 * rozmerov podlahy a stropu je možná len pri prvom vytvorenom
		 * robote, inak vznikne výnimka. (Častý spôsob je spustenie
		 * príkazu {@code valsuper}{@code (}<em>«rozmery plátna a titulok
		 * okna»</em>{@code )} na začiatku konštruktora
		 * {@linkplain Svet#hlavnýRobot() hlavného robota}.)
		 * Ostatné vlastnosti a správanie tohto konštruktora sú podobné ako
		 * pri {@linkplain GRobot#GRobot(String) konštruktore prijímajúcom
		 * jeden argument (reťazec určujúci nvoý titulok hlavného okna)}.</p>
		 * 
		 * <p class="attention"><b>Upozornenie:</b> Zväčšovanie rozmerov
		 * plátna znižuje výkonnosť aplikácie.</p>
		 * 
		 * <p>V súčasnej verzii programovacieho rámca jestvuje metóda
		 * {@link Svet#zmeňRozmeryPlátien(int, int) zmeňRozmeryPlátien}, avšak
		 * je nevyhnutné ju používať len v odôvodnených prípadoch, keďže zmena
		 * rozmerov plátien je komplexný proces.</p>
		 * 
		 * @param nováMaximálnaŠírka nová maximálna šírka kresliacich
		 *     plátien
		 * @param nováMaximálnaVýška nová maximálna výška kresliacich
		 *     plátien
		 * @param novýTitulok nový titulok hlavného okna
		 * 
		 * @throws GRobotException ak svet už jestvuje
		 * 
		 * @see Svet#zmeňRozmeryPlátien(int, int)
		 */
		public GRobot(int nováMaximálnaŠírka, int nováMaximálnaVýška,
			String novýTitulok)
		{
			if (Svet.inicializované)
				throw new GRobotException("Svet už jestvuje!",
					"worldAlreadyExists");

			registrujUdalostiRobota();

			Plátno.šírkaPlátna = nováMaximálnaŠírka;
			Plátno.výškaPlátna = nováMaximálnaVýška;
			Svet.prepočítajParametreVýplne();

			podlaha.vytvorNovéPlátno(
				Plátno.šírkaPlátna, Plátno.výškaPlátna);
			strop.vytvorNovéPlátno(
				Plátno.šírkaPlátna, Plátno.výškaPlátna);
			Svet.obrázokSveta1 = new BufferedImage(Plátno.šírkaPlátna,
				Plátno.výškaPlátna, BufferedImage.TYPE_INT_ARGB);
			Svet.grafikaSveta1 = Svet.obrázokSveta1.createGraphics();

			if (null != Svet.vlnenie) Svet.odstráňVlnenie();
			Svet.obrázokSveta2 = new BufferedImage(Plátno.šírkaPlátna,
				Plátno.výškaPlátna, BufferedImage.TYPE_INT_ARGB);
			Svet.grafikaSveta2 = Svet.obrázokSveta2.createGraphics();
			for (Obrázok obrázok : Obrázok.zoznamObrázkovKnižnice)
				obrázok.upravPosun();

			Svet.inicializujGrafiku();
			Svet.titulok(novýTitulok);
			inicializujRobot();
		}


	// -------------------------------------------- //
	//  *** Verejné metódy rozdelené do sekcií ***  //
	// -------------------------------------------- //

		/*
		Sekcie verejných metód robota:

			Základné vlastnosti

				Hrúbka, farba a poloha pera
				Viditeľnosť
				Priehľadnosť
				Písmo
				Poloha a smer
				Domov
				Spôsob kreslenia
				Meno robota

			Základné aktivity

				Smer a krokový pohyb v smere
				Horizontálny a vertikálny krokový pohyb
				Špeciálny pohyb

			Aktivita

				Aktivácia a deaktivácia
				Rýchlosť
				Rýchlosť posunu
				Uhlová rýchlosť
				Zrýchlenie
				Zrýchlenie posunu
				Uhlové zrýchlenie
				Dynamický pohyb
				Sledovanie cieľa
				Metóda pracuj
				Výzvy
				Metódy aktivít na prekrytie

			Pôsobisko

			Farba bodu

			Vylej farbu

			Podlaha a strop

			Kreslenie na obrázky

			Tvary

			Kreslenie (pečiatkovanie) obrázkov

			Text

			Formát

			Cesta

			Oblasti

			Poradie

			Spojnice

			Veľkosť robota, kolízna oblasť a detekcia kolízií

			Meranie vzdialeností

			Vlastný tvar robota

			Obmedzenie kreslenia

			Interaktívny režim
		*/
		// Poznámka: Pojem „príkaz“ môže byť pri opise metód použitý vo
		// význame „použitie tejto metódy na zadanie príkazu robotu.“


		// Základné vlastnosti

			// Hrúbka, farba a poloha pera

				/**
				 * <p><a class="getter"></a> Čítaj hrúbku čiary pera robota.</p>
				 * 
				 * @return aktuálna hrúbka čiary pera robota
				 * 
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara()
				 * @see #čiara(Stroke)
				 * @see #hrúbkaPeraDoma() hrúbkaPeraDoma
				 */
				public double hrúbkaPera() { return polomerPera; }

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaPera() hrúbkaPera}.</p> */
				public double hrubkaPera() { return polomerPera; }

				/**
				 * <p><a class="getter"></a> Čítaj hrúbku čiary pera robota.</p>
				 * 
				 * @return aktuálna hrúbka čiary pera robota
				 * 
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara()
				 * @see #čiara(Stroke)
				 * @see #hrúbkaČiaryDoma() hrúbkaČiaryDoma
				 */
				public double hrúbkaČiary() { return polomerPera; }

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaČiary() hrúbkaČiary}.</p> */
				public double hrubkaCiary() { return polomerPera; }

				/**
				 * <p><a class="setter"></a> Nastav konkrétnu hrúbku čiary pera.</p>
				 * 
				 * @param nováHrúbka hrúbka čiary pera
				 * 
				 * @throws GRobotException ak je hrúbka čiary pera záporná
				 * 
				 * @see #hrúbkaPera()
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara()
				 * @see #čiara(Stroke)
				 * @see #hrúbkaPeraDoma(Double) hrúbkaPeraDoma
				 */
				public void hrúbkaPera(double nováHrúbka)
				{
					if (nováHrúbka < 0) throw new GRobotException(
						"Hrúbka čiary pera nesmie byť záporná!",
						"negativePenWidth", new IllegalArgumentException());

					polomerPera = nováHrúbka;
					čiara = new BasicStroke((float)polomerPera,
						BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
					// čiara = new BasicStroke((float)polomerPera);
					if (viditeľný && null == vlastnýTvarObrázok &&
						(null != vlastnýTvarKreslenie || !vyplnený))
						Svet.automatickéPrekreslenie();
				}

					/*TEST
						for (byte a = 0; a < 2; ++a)
						{
							boolean viditeľný = a != 0;
							for (byte tvarObrázok = 0; tvarObrázok < 2; ++tvarObrázok)
							{
								for (byte tvarKreslenie = 0; tvarKreslenie < 2; ++tvarKreslenie)
								{
									for (byte b = 0; b < 2; ++b)
									{
										boolean vyplnený = b != 0;

										boolean prekresli = viditeľný &&
											0.0 == tvarObrázok &&
											(0.0 != tvarKreslenie || !vyplnený);

										// prekresli = viditeľný &&
										// 	0.0 == tvarObrázok &&
										// 	0.0 == tvarKreslenie && !vyplnený;

										System.out.print(viditeľný ? "vidi\t" : "nevi\t");
										System.out.print(0.0 != tvarObrázok ? "obra\t" : "nobr\t");
										System.out.print(0.0 != tvarKreslenie ? "kres\t" : "nkre\t");
										System.out.print(vyplnený ? "vypln\t" : "nevyp\t");

										System.out.println(prekresli ? "= kres" : "= nekr");
									}
								}
							}
						}
					*/

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaPera(double) hrúbkaPera}.</p> */
				public void hrubkaPera(double nováHrúbka) { hrúbkaPera(nováHrúbka); }

				/**
				 * <p><a class="setter"></a> Nastav konkrétnu hrúbku čiary pera.</p>
				 * 
				 * @param nováHrúbka hrúbka čiary pera
				 * 
				 * @throws GRobotException ak je hrúbka čiary pera záporná
				 * 
				 * @see #hrúbkaPera()
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara()
				 * @see #čiara(Stroke)
				 * @see #hrúbkaČiaryDoma(Double) hrúbkaČiaryDoma
				 */
				public void hrúbkaČiary(double nováHrúbka)
				{
					if (nováHrúbka < 0) throw new GRobotException(
						"Hrúbka čiary pera nesmie byť záporná!",
						"negativePenWidth", new IllegalArgumentException());

					polomerPera = nováHrúbka;
					čiara = new BasicStroke((float)polomerPera,
						BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
					// čiara = new BasicStroke((float)polomerPera);
					if (viditeľný && null == vlastnýTvarObrázok &&
						(null != vlastnýTvarKreslenie || !vyplnený))
						Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaČiary(double) hrúbkaČiary}.</p> */
				public void hrubkaCiary(double nováHrúbka) { hrúbkaČiary(nováHrúbka); }

				/**
				 * <p>Nastaví hrúbku čiary pera na predvolenú.</p>
				 * 
				 * @see #hrúbkaPera()
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara()
				 * @see #čiara(Stroke)
				 */
				public void predvolenáHrúbkaPera() { hrúbkaPera(predvolenýPolomerPera); }

				/** <p><a class="alias"></a> Alias pre {@link #predvolenáHrúbkaPera() predvolenáHrúbkaPera}.</p> */
				public void predvolenaHrubkaPera() { hrúbkaPera(predvolenýPolomerPera); }

				/**
				 * <p>Nastaví hrúbku čiary pera na predvolenú.</p>
				 * 
				 * @see #hrúbkaPera()
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #čiara()
				 * @see #čiara(Stroke)
				 */
				public void predvolenáHrúbkaČiary() { hrúbkaPera(predvolenýPolomerPera); }

				/** <p><a class="alias"></a> Alias pre {@link #predvolenáHrúbkaČiary() predvolenáHrúbkaČiary}.</p> */
				public void predvolenaHrubkaCiary() { hrúbkaPera(predvolenýPolomerPera); }

				/**
				 * <p>Vráti objekt typu {@link Stroke Stroke} vyjadrujúci
				 * vlastnosti aktuálnej čiary, ktorou robot kreslí.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ide o objekt
				 * typu {@link BasicStroke BasicStroke}, ktorý definuje
				 * súvislú čiaru s aktuálnou hrúbkou pera robota.</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Pri každej {@linkplain 
				 * #hrúbkaPera(double) zmene hrúbky pera} je vytvorený
				 * nový objekt {@link BasicStroke BasicStroke}, ktorý
				 * nahradí prípadný objekt nastavený metódou {@link 
				 * #čiara(Stroke) čiara(nováČiara)}.</p>
				 * 
				 * @return aktuálna čiara robota (objekt typu {@link 
				 *     Stroke Stroke})
				 * 
				 * @see #hrúbkaPera()
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara(Stroke)
				 */
				public Stroke čiara() { return čiara; }

				/** <p><a class="alias"></a> Alias pre {@link #čiara() čiara}.</p> */
				public Stroke ciara() { return čiara; }

				/**
				 * <p>Podľa zadaného objekt typu {@link Stroke Stroke}
				 * nastaví novú čiaru, ktorou bude robot kresliť. Ak je
				 * zadaná hodnota {@code valnull}, tak je čiara resetovaná
				 * podľa naposledny nastavenej {@linkplain 
				 * #hrúbkaČiary(double) hrúbky čiary.}</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Nastavenie vlastnej
				 * čiary prostredníctvom tejto metódy nie je súčasťou
				 * {@linkplain Svet#použiKonfiguráciu(String) automatickej
				 * konfigurácie}. (Pozri napríklad metódu {@link 
				 * #registrujVKonfigurácii() registrujVKonfigurácii}.)</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Pri každej {@linkplain 
				 * #hrúbkaPera(double) zmene hrúbky pera} je vytvorený
				 * nový objekt {@link BasicStroke BasicStroke}, ktorý
				 * nahradí objekt nastavený touto metódou.</p>
				 * 
				 * <p> </p>
				 * 
				 * <p><b>Užitočné zdroje:</b></p>
				 * 
				 * <ul>
				 * <li><a
				 * href="https://docs.oracle.com/javase/tutorial/2d/geometry/strokeandfill.html"
				 * target="_blank"><em>Stroking and Filling Graphics
				 * Primitives (The Java™ Tutorials – 2D Graphics – Working
				 * with Geometry).</em></a> Copyright © 1995, 2019 Oracle
				 * and/or its affiliates. Citované: 9. apríla 2020.</li>
				 * 
				 * <li><a
				 * href="http://www.java2s.com/Tutorials/Java/Graphics/Graphics_Settings/Use_dashed_stroke_to_draw_dashed_line_in_Java.htm"
				 * target="_blank"><em>Use dashed stroke to draw dashed line
				 * in Java.</em></a> java2s.com – © Demo Source and Support.
				 * Citované: 9. apríla 2020.</li>
				 * 
				 * <li><a
				 * href="http://www.java2s.com/Code/Java/2D-Graphics-GUI/Dashedstroke.htm"
				 * target="_blank"><em>Dashed stroke : Stroke – 2D Graphics
				 * GUI – Java.</em></a> java2s.com – © Demo Source and
				 * Support. Citované: 9. apríla 2020.</li>
				 * 
				 * <li><a
				 * href="https://docstore.mik.ua/orelly/java-ent/jfc/ch04_05.htm"
				 * target="_blank">Flanagan, David: <em>Stroking Lines (Java
				 * Foundation Classes).</em></a> Copyright © 2001 O’Reilly
				 * and Associates. ISBN 1-56592-488-6. Published September
				 * 1999. Citované: 9. apríla 2020.</li>
				 * </ul>
				 * 
				 * <p> </p>
				 * 
				 * @param nováČiara objekt typu {@link Stroke Stroke}
				 *     vyjadrujúci vlastnosti novej čiary, ktorou bude robot
				 *     kresliť alebo hodnota {@code valnull}
				 * 
				 * @see #hrúbkaPera()
				 * @see #hrúbkaČiary()
				 * @see #hrúbkaPera(double)
				 * @see #hrúbkaČiary(double)
				 * @see #predvolenáHrúbkaPera()
				 * @see #predvolenáHrúbkaČiary()
				 * @see #čiara()
				 */
				public void čiara(Stroke nováČiara)
				{
					if (null == nováČiara)
						čiara = new BasicStroke((float)polomerPera,
							BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
					else
						čiara = nováČiara;

					if (viditeľný && null == vlastnýTvarObrázok &&
						(null != vlastnýTvarKreslenie || !vyplnený))
						Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #čiara(Stroke) čiara}.</p> */
				public void ciara(Stroke nováČiara) { čiara = nováČiara; }


				/**
				 * <p>Vyrobí zo zadaného tvaru nový tvar podľa aktuálneho typu
				 * ťahu. Nový tvar bude tvoriť obrys oblasti, ktorú by robot
				 * vyplnil kreslením zadaného tvaru svojím aktuálnym ťahom.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>S pomocou niekoľkých nasledujúcich príkazov sa dá
				 * vytvoriť jednoduchý tvar oválu, ktorý môže byť obkresľovaný
				 * (čiarou) alebo vypĺňaný. (Príklad používa triedu Javy
				 * {@link Shape Shape}.)</p>
				 * 
				 * <pre CLASS="example">
					{@code comm// Výroba cesty (iba čiarka dlhá 120 bodov – ovál z nej vytvorí až}
					{@code comm// veľmi hrubá čiara, ktorá je v tomto rámci predvolene zaoblená):}
					{@link GRobot#odskoč(double) odskoč}({@code num60});
					{@link GRobot#začniCestu() začniCestu}();
					{@link GRobot#skoč(double) skoč}({@code num120});

					{@code comm// Nastavenie hrúbky čiary a vyrobenie tvaru z cesty:}
					{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num150});
					{@link Shape java.awt.Shape} tvar = {@code currtvarPodľaČiary}({@link GRobot#cesta() cesta}());

					{@code comm// Vymazanie čiarky:}
					{@link Svet Svet}.{@link Svet#vymaž() vymaž}();

					{@code comm// Nastavenie tenšej čiary a nakreslenie vyrobeného oválu:}
					{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num15});
					{@link GRobot#kresliTvar(Shape) kresliTvar}(tvar);
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>tvar-podla-ciary.png<alt/>Výsledok kreslenia
				 * príkladu metódy tvarPodľaČiary.</image>Výsledok kreslenia
				 * príkladu.</p>
				 * 
				 * @param tvar tvar, z ktorého bude vytvorený nový tvar
				 *     podľa aktuálneho ťahu robota
				 * @return nový tvar vytvorený zo zadaného tvaru podľa
				 *     aktuálneho ťahu robota
				 */
				public Shape tvarPodľaČiary(Shape tvar)
				{
					poslednýTypTvaru = TypTvaru.NIČ;
					return čiara.createStrokedShape(tvar);
				}

				/** <p><a class="alias"></a> Alias pre {@link #tvarPodľaČiary(Shape) tvarPodľaČiary}.</p> */
				public Shape tvarPodlaCiary(Shape tvar)
				{ return tvarPodľaČiary(tvar); }


				/**
				 * <p><a class="getter"></a> Číta farbu robota. Farba robota
				 * ovplyvňuje farebnosť predvoleného tvaru robota a farbu
				 * kreslenia (čiar aj pečiatok).</p>
				 * 
				 * @return aktuálna farba robota (objekt typu {@link 
				 *     Farba Farba})
				 * 
				 * @see #farba(Color)
				 * @see #farba(Farebnosť)
				 * @see #farba(int, int, int)
				 * @see #farba(int, int, int, int)
				 * @see #predvolenáFarba()
				 * @see #farbaDoma() farbaDoma
				 */
				public Farba farba() { return farbaRobota; }

				/**
				 * <p><a class="setter"></a> Nastav farbu robota. Nastaví
				 * farbu a priehľadnosť robota podľa použitého objektu
				 * {@link Color Color} (alebo odvodeného napr. {@link Farba
				 * Farba}). Farba robota ovplyvňuje farebnosť predvoleného
				 * tvaru robota a farbu kreslenia (čiar aj pečiatok).</p>
				 * 
				 * @param nováFarba objekt farebného údajového typu určujúci
				 *     novú farbu robota; jestvuje paleta predvolených farieb
				 *     (pozri napríklad: {@link Farebnosť#biela biela}, {@link Farebnosť#červená
				 *     červená}, {@link Farebnosť#čierna čierna}…)
				 * 
				 * @see #farba()
				 * @see #farba(Farebnosť)
				 * @see #farba(int, int, int)
				 * @see #farba(int, int, int, int)
				 * @see #predvolenáFarba()
				 * @see #farbaDoma(Color) farbaDoma
				 */
				public void farba(Color nováFarba)
				{
					if (nováFarba instanceof Farba)
						farbaRobota = (Farba)nováFarba;
					else
						farbaRobota = new Farba(nováFarba);

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Nastaví farbu a priehľadnosť robota podľa zadaného
				 * objektu, ktorý musí byť implementáciou rozhrania {@link 
				 * Farebnosť Farebnosť}.
				 * (Farba robota ovplyvňuje farebnosť predvoleného tvaru robota
				 * a farbu kreslenia – čiar aj pečiatok.)</p>
				 * 
				 * @param podľaObjektu objekt, podľa ktorého má byť nastavená
				 *     farebnosť pera tohto robota
				 * 
				 * @see #farba()
				 * @see #farba(Color)
				 * @see #farba(int, int, int)
				 * @see #farba(int, int, int, int)
				 * @see #predvolenáFarba()
				 */
				public void farba(Farebnosť podľaObjektu)
				{ farba(podľaObjektu.farba()); }

				/* *
				 * <p>Toto je „klon“ metódy {@link #farba(Color)}. Farba je
				 * nastavená len v prípade, že v premennej typu {@link Object}
				 * (zadanej ako parameter) je uložená inštancia triedy {@link 
				 * Farba Farba} alebo {@link Color Color}.</p>
				 * /
				public void farba(Object nováFarba)
				{
					if (nováFarba instanceof Color)
						nováFarba = new Farba((Color)nováFarba);
					if (nováFarba instanceof Farba) farba((Farba)nováFarba);
				}*/

				/**
				 * <p>Nastav farbu robota. Nastaví farbu robota podľa zadaných
				 * farebných zložiek.
				 * (Farba robota ovplyvňuje farebnosť predvoleného tvaru robota
				 * a farbu kreslenia – čiar aj pečiatok.)</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @return objekt typu {@link Farba Farba} – nová farba robota
				 * 
				 * @see #farba()
				 * @see #farba(Color)
				 * @see #farba(Farebnosť)
				 * @see #farba(int, int, int, int)
				 * @see #predvolenáFarba()
				 */
				public Farba farba(int r, int g, int b)
				{
					farbaRobota = new Farba(r, g, b);
					if (viditeľný) Svet.automatickéPrekreslenie();
					return farbaRobota;
				}

				/**
				 * <p>Nastav farbu robota. Nastaví farbu a (ne)priehľadnosť robota
				 * podľa zadaných farebných zložiek a úrovne priehľadnosti.
				 * (Farba robota ovplyvňuje farebnosť predvoleného tvaru robota
				 * a farbu kreslenia – čiar aj pečiatok.)</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param a úroveň (ne)priehľadnosti novej farby; celé číslo
				 *     v rozsahu 0 – 255 (0 – neviditeľná farba; 255 –
				 *     nepriehľadná farba)
				 * @return objekt typu {@link Farba Farba} – nová farba robota
				 * 
				 * @see #farba()
				 * @see #farba(Color)
				 * @see #farba(Farebnosť)
				 * @see #farba(int, int, int)
				 * @see #predvolenáFarba()
				 */
				public Farba farba(int r, int g, int b, int a)
				{
					farbaRobota = new Farba(r, g, b, a);
					if (viditeľný) Svet.automatickéPrekreslenie();
					return farbaRobota;
				}

				/**
				 * <p>Nastaví farbu robota na predvolenú farbu.
				 * (Predvolenou farbou robota je {@linkplain Farebnosť#čierna čierna}.
				 * Farba robota ovplyvňuje farebnosť predvoleného tvaru robota
				 * a farbu kreslenia – čiar aj pečiatok.)</p>
				 * 
				 * @see #farba()
				 * @see #farba(Color)
				 * @see #farba(Farebnosť)
				 * @see #farba(int, int, int)
				 * @see #farba(int, int, int, int)
				 */
				public void predvolenáFarba()
				{
					farbaRobota = predvolenáFarbaRobota;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #predvolenáFarba() predvolenáFarba}.</p> */
				public void predvolenaFarba() { predvolenáFarba(); }


				/**
				 * <p><a class="getter"></a> Číta cieľovú farbu robota.
				 * Hodnota {@code valnull} znamená, že tento atribút
				 * nie je nastavený (to je predvolený stav).
				 * Podrobnosti o využití tohto atribútu nájdete v opise
				 * metódy {@link #cieľováFarba(Color) cieľováFarba}.</p>
				 * 
				 * @return aktuálna cieľová farba robota (objekt typu
				 *     {@link Farba Farba})
				 * 
				 * @see #cieľováFarba(Color)
				 * @see #cieľováFarba(Farebnosť)
				 * @see #cieľováFarba(int, int, int)
				 * @see #cieľováFarba(int, int, int, int)
				 * @see #zrušCieľovúFarbu()
				 * @see #cieľováFarbaDoma() cieľováFarbaDoma
				 * @see #použiKruhovýNáter()
				 */
				public Farba cieľováFarba() { return cieľováFarba; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarba() cieľováFarba}.</p> */
				public Farba cielovaFarba() { return cieľováFarba; }

				/**
				 * <p><a class="setter"></a> Nastaví cieľovú farbu
				 * (a priehľadnosť) robota podľa použitého objektu
				 * {@link Color Color} (alebo odvodeného napr.
				 * {@link Farba Farba}). Cieľová farba je použitá
				 * pri vytváraní farebných prechodov výplní alebo
				 * obrysových čiar objektov kreslených robotom
				 * a na vytvorenie farebného prechodu
				 * čiary kreslenej pri posune robota. Hodnota
				 * {@code valnull} zruší nastavenie cieľovej farby
				 * tohto robota.</p>
				 * 
				 * <!-- ZAMIETNUTÉ‼ To bola chyba!
				 * p class="caution"><b>Pozor!</b> Predvolene je hodnota
				 * tohto atribútu po prechode robota domov zrušená!
				 * (Pozri aj {@link #cieľováFarbaDoma(Color)
				 * cieľováFarbaDoma}.)</p -->
				 * 
				 * <p>Cieľová farba poskytuje najrýchlejší spôsob
				 * automatického definovania lineárneho farebného prechodu
				 * používaného robotom pri kreslení.
				 * Začiatok farebného prechodu je pri pečiatkovaní tvarov za
				 * robotom a pri kreslení perom v mieste aktuálnej pozície
				 * robota (pred presunom). Koniec prechodu je pri pečiatkovaní
				 * tvarov pred robotom a pri kreslení perom v mieste cieľovej
				 * pozície. Rozsah prechodu pri pečiatkovaní sa dá ovplyvniť
				 * veľkosťou robota. Pri kreslení perom je rozsah prechodu
				 * určený automaticky podľa dĺžky posunu robota.
				 * Pri pečiatkovaní je prechod použitý rovnako na vypĺňanie
				 * tvarov aj na farebný štýl čiary, ktorou sú tvary
				 * obkresľované. Na vytvorenie zložitejších prechodov je
				 * nevyhnutné použiť prislúchajúce triedy Javy spolu
				 * s vlastnosťou {@link #náter(Paint) náter}. (Príklady sú
				 * v opise metódy {@link #náter(Paint) náter(novýNáter)}.)</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@code valsuper}({@code num250}, {@code num250});
					{@link GRobot#skry() skry}();

					{@link Svet Svet}.{@link Svet#farbaPozadia(Color) farbaPozadia}({@link Farebnosť#tmavošedá tmavošedá});
					{@link GRobot#farba(Color) farba}({@link Farebnosť#svetlotyrkysová svetlotyrkysová});
					{@link GRobot#cieľováFarba(Color) cieľováFarba}({@link Farebnosť#svetlooranžová svetlooranžová});
					{@link GRobot#veľkosť(double) veľkosť}({@code num50});
					{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num5});

					{@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; {@code num10}; ++i)
					{
						{@link GRobot#skoč() skoč}();
						{@link GRobot#krúžok() krúžok}();
						{@link GRobot#odskoč() odskoč}();
						{@link GRobot#vpravo(double) vpravo}({@code num36});
					}
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>minimandala-s-prechodom.png<alt/>Minimandala
				 * s prechodom.</image>Výsledkom tohto príkladu je obrázok
				 * podobný miniatúrnej mandale.</p>
				 * 
				 * @param nováFarba objekt farebného údajového typu
				 *     určujúci cieľovú farbu robota; jestvuje paleta
				 *     predvolených farieb (pozri napríklad: {@link Farebnosť#biela
				 *     biela}, {@link Farebnosť#červená červená}, {@link Farebnosť#čierna
				 *     čierna}…)
				 * 
				 * @see #cieľováFarba()
				 * @see #cieľováFarba(Farebnosť)
				 * @see #cieľováFarba(int, int, int)
				 * @see #cieľováFarba(int, int, int, int)
				 * @see #zrušCieľovúFarbu()
				 * @see #cieľováFarbaDoma(Color) cieľováFarbaDoma
				 * @see #použiKruhovýNáter()
				 */
				public void cieľováFarba(Color nováFarba)
				{
					if (null == nováFarba)
						cieľováFarba = null;
					else if (nováFarba instanceof Farba)
						cieľováFarba = (Farba)nováFarba;
					else
						cieľováFarba = new Farba(nováFarba);

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarba(Color) cieľováFarba}.</p> */
				public void cielovaFarba(Color nováFarba)
				{ cieľováFarba(nováFarba); }

				/**
				 * <p>Nastaví cieľovú farbu a priehľadnosť robota podľa zadaného
				 * objektu, ktorý musí byť implementáciou rozhrania {@link 
				 * Farebnosť Farebnosť}.
				 * (Podrobnosti o využití tohto atribútu nájdete v opise
				 * metódy {@link #cieľováFarba(Color) cieľováFarba}.)</p>
				 * 
				 * @param podľaObjektu objekt, podľa ktorého má byť nastavená
				 *     cieľová farba tohto robota
				 * 
				 * @see #cieľováFarba()
				 * @see #cieľováFarba(Color)
				 * @see #cieľováFarba(int, int, int)
				 * @see #cieľováFarba(int, int, int, int)
				 * @see #zrušCieľovúFarbu()
				 * @see #použiKruhovýNáter()
				 */
				public void cieľováFarba(Farebnosť podľaObjektu)
				{
					if (null == podľaObjektu)
						cieľováFarba = null;
					else if (podľaObjektu instanceof GRobot)
						cieľováFarba(((GRobot)podľaObjektu).cieľováFarba());
					else
						cieľováFarba(podľaObjektu.farba());
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarba(Farebnosť) cieľováFarba}.</p> */
				public void cielovaFarba(Farebnosť podľaObjektu)
				{ cieľováFarba(podľaObjektu); }

				/**
				 * <p>Nastaví cieľovú farbu robota podľa zadaných
				 * farebných zložiek.
				 * (Podrobnosti o využití tohto atribútu nájdete v opise
				 * metódy {@link #cieľováFarba(Color) cieľováFarba}.)</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @return objekt typu {@link Farba Farba} – nová cieľová
				 *     farba robota
				 * 
				 * @see #cieľováFarba()
				 * @see #cieľováFarba(Color)
				 * @see #cieľováFarba(Farebnosť)
				 * @see #cieľováFarba(int, int, int, int)
				 * @see #zrušCieľovúFarbu()
				 * @see #použiKruhovýNáter()
				 */
				public Farba cieľováFarba(int r, int g, int b)
				{
					cieľováFarba = new Farba(r, g, b);
					if (viditeľný) Svet.automatickéPrekreslenie();
					return cieľováFarba;
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarba(int, int, int) cieľováFarba}.</p> */
				public Farba cielovaFarba(int r, int g, int b)
				{ return cieľováFarba(r, g, b); }

				/**
				 * <p>Nastaví cieľovú farbu robota a priehľadnosť robota podľa
				 * zadaných farebných zložiek a úrovne priehľadnosti.
				 * (Podrobnosti o využití tohto atribútu nájdete v opise
				 * metódy {@link #cieľováFarba(Color) cieľováFarba}.)</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param a úroveň (ne)priehľadnosti novej farby; celé číslo
				 *     v rozsahu 0 – 255 (0 – neviditeľná farba; 255 –
				 *     nepriehľadná farba)
				 * @return objekt typu {@link Farba Farba} – nová cieľová
				 *     farba robota
				 * 
				 * @see #cieľováFarba()
				 * @see #cieľováFarba(Color)
				 * @see #cieľováFarba(Farebnosť)
				 * @see #cieľováFarba(int, int, int)
				 * @see #zrušCieľovúFarbu()
				 * @see #použiKruhovýNáter()
				 */
				public Farba cieľováFarba(int r, int g, int b, int a)
				{
					cieľováFarba = new Farba(r, g, b, a);
					if (viditeľný) Svet.automatickéPrekreslenie();
					return cieľováFarba;
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarba(int, int, int, int) cieľováFarba}.</p> */
				public Farba cielovaFarba(int r, int g, int b, int a)
				{ return cieľováFarba(r, g, b, a); }

				/**
				 * <p>Zruší nastavenie cieľovej farby robota.
				 * (Podrobnosti o využití tohto atribútu nájdete v opise
				 * metódy {@link #cieľováFarba(Color) cieľováFarba}.)</p>
				 * 
				 * @see #cieľováFarba()
				 * @see #cieľováFarba(Color)
				 * @see #cieľováFarba(Farebnosť)
				 * @see #cieľováFarba(int, int, int)
				 * @see #cieľováFarba(int, int, int, int)
				 * @see #použiKruhovýNáter()
				 */
				public void zrušCieľovúFarbu()
				{
					cieľováFarba = null;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľovúFarbu() zrušCieľovúFarbu}.</p> */
				public void zrusCielovuFarbu() { zrušCieľovúFarbu(); }


				/**
				 * <p>Overí, či má robot v prípade nastavenia {@linkplain 
				 * #cieľováFarba(Color) cieľovej farby} vytvoriť kruhový
				 * náter na výplň tvarov.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@code comm// Prvý kruh bude vyplnený bez špeciálneho náteru – predvolenou}
					{@code comm// čiernou farbou.}
					{@link Svet Svet}.{@link Svet#farbaTextu(Color) farbaTextu}({@link Farebnosť#tyrkysová tyrkysová});
					{@link Svet Svet}.{@link Svet#vypíšRiadok(Object[]) vypíšRiadok}({@code srg"Použije kruhový náter: "}, {@code currpoužijeKruhovýNáter}());
					{@link GRobot#kruh(double) kruh}({@code num180});

					{@code comm// Druhý kruh bude vyplnený lineárnym náterom. Na náter má vplyv}
					{@code comm// aj veľkosť robota.}
					{@link GRobot#veľkosť(double) veľkosť}({@code num60});
					{@link GRobot#farba(Color) farba}({@link Farebnosť#červená červená});
					{@link GRobot#cieľováFarba(Color) cieľováFarba}({@link Farebnosť#žltá žltá});
					{@link Svet Svet}.{@link Svet#vypíšRiadok(Object[]) vypíšRiadok}({@code srg"Použije kruhový náter: "}, {@code currpoužijeKruhovýNáter}());
					{@link GRobot#kruh(double) kruh}({@code num120});

					{@code comm// Tretí kruh bude vyplnený kruhovým náterom.}
					{@link GRobot#použiKruhovýNáter() použiKruhovýNáter}();
					{@link Svet Svet}.{@link Svet#vypíšRiadok(Object[]) vypíšRiadok}({@code srg"Použije kruhový náter: "}, {@code currpoužijeKruhovýNáter}());
					{@link GRobot#kruh(double) kruh}({@code num60});
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>pouzije-kruhovy-nater.png<alt/>Výsledok príkladu
				 * metódy použijeKruhovýNáter.</image>Výsledok kreslenia
				 * príkladu.</p>
				 * 
				 * @return {@code valtrue} – áno; {@code valfalse} – nie
				 * 
				 * @see #použiKruhovýNáter()
				 * @see #nepoužiKruhovýNáter()
				 * @see #cieľováFarba()
				 */
				public boolean použijeKruhovýNáter()
				{
					return použiKruhovýNáter;
				}

				/** <p><a class="alias"></a> Alias pre {@link #použijeKruhovýNáter() použijeKruhovýNáter}.</p> */
				public boolean pouzijeKruhovyNater()
				{
					return použiKruhovýNáter;
				}

				/**
				 * <p>Prikáže, aby robot v prípade nastavenia {@linkplain 
				 * #cieľováFarba(Color) cieľovej farby} použil na výplň tvarov
				 * kruhový náter.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@code comm// Obmedzenie kreslenia:}
					{@link GRobot#kresliDo(Shape) kresliDo}({@link GRobot#kružnica(double) kružnica}({@code num50}));

					{@code comm// Nastavenia ovplyvňujúce náter:}
					{@link GRobot#veľkosť(double) veľkosť}({@code num80});
					{@link GRobot#farba(Color) farba}({@link Farebnosť#biela biela});
					{@link GRobot#cieľováFarba(Color) cieľováFarba}({@link Farebnosť#modrá modrá});
					{@code currpoužiKruhovýNáter}();

					{@code comm// Použitie náteru:}
					{@link GRobot#skoč(double, double) skoč}(-{@code num25}, {@code num30});
					{@link GRobot#kruh(double) kruh}({@code num100});

					{@code comm// Zrušenie obedzenia kreslenia a nakreslenie okrajovej čiary:}
					{@link GRobot#kresliVšade() kresliVšade}();
					{@link GRobot#skočNa(Poloha) skočNa}({@link Poloha#stred stred});
					{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num2});
					{@link GRobot#farba(Color) farba}({@link Farebnosť#čierna čierna});
					{@link GRobot#kružnica(double) kružnica}({@code num50});
					</pre>
				 * 
				 * <p>Predchádzajúca sekvencia príkazov nakreslí obrázok
				 * nižšie. Vysunutie kruhového náteru je realizované
				 * s použitím triku <a
				 * href="kategorie-metod.html#GRobot-Obmedzenie-kreslenia">obmedzenia
				 * kreslenia.</a></p>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>pouzi-kruhovy-nater.png<alt/></image>Výsledok
				 * kreslenia.</p>
				 * 
				 * 
				 * @see #použijeKruhovýNáter()
				 * @see #nepoužiKruhovýNáter()
				 * @see #cieľováFarba()
				 */
				public void použiKruhovýNáter()
				{
					použiKruhovýNáter = true;
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #použiKruhovýNáter() použiKruhovýNáter}.</p> */
				public void pouziKruhovyNater()
				{
					použiKruhovýNáter = true;
					Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Vypne používanie kruhového náteru výplne tvarov, ktorý
				 * by bol použitý v prípade nastavenia {@linkplain 
				 * #cieľováFarba(Color) cieľovej farby} robota.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@link GRobot#veľkosť(double) veľkosť}({@code num75});
					{@link GRobot#farba(Color) farba}({@link Farebnosť#červená červená});
					{@link GRobot#cieľováFarba(Color) cieľováFarba}({@link Farebnosť#žiadna žiadna});
					{@link GRobot#použiKruhovýNáter() použiKruhovýNáter}();
					{@link GRobot#kruh() kruh}();
					{@link GRobot#vpravo(double) vpravo}({@code num45});
					{@link GRobot#farba(Color) farba}({@link Farebnosť#žltá žltá});
					{@code currnepoužiKruhovýNáter}();
					{@link GRobot#vyplňŠtvorec() vyplňŠtvorec}();
					</pre>
				 * 
				 * <p>Krátka sekvencia príkazov vyššie nakreslí obrázok nižšie.
				 * Štvorec prekrýva kruh, ktorý je vyplnený kruhovým náterom.
				 * Vypnutie kruhového náteru je použité na vyplnenie štvorca
				 * lineárnym náterom.</p>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>nepouzi-kruhovy-nater.png<alt/></image>Výsledok.</p>
				 * 
				 * 
				 * @see #použijeKruhovýNáter()
				 * @see #použiKruhovýNáter()
				 * @see #cieľováFarba()
				 */
				public void nepoužiKruhovýNáter()
				{
					použiKruhovýNáter = false;
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #nepoužiKruhovýNáter() nepoužiKruhovýNáter}.</p> */
				public void nepouziKruhovyNater()
				{
					použiKruhovýNáter = false;
					Svet.automatickéPrekreslenie();
				}


				/**
				 * <p>Vráti objekt s aktuálnym druhom náteru, ktorý grafický
				 * robot používa na kreslenie (kreslenie čiar pera, vypĺňanie
				 * plôch a kreslenie obrysových čiar ním generovaných
				 * pečiatkových tvarov, kreslenie svojho predvoleného tvaru,
				 * prípadne iné). Ak náter nie je nastavený, tak táto metóda
				 * vráti hodnotu {@code valnull}.
				 * Ďalšie podrobnosti o tejto vlastnosti nájdete v opise metódy
				 * {@link #náter(Paint) náter(novýNáter)}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto vlastnosť robota sa
				 * pôvodne mala volať výplň, ale tento názov kolidoval
				 * s príkazom vyplň, preto bolo potrebné hľadať iné
				 * pomenovanie. Nakoniec sa autor priklonil k názvu náter
				 * a popri tom sa ukázalo, že s týmto pomenovaním vlastnosť
				 * lepšie zapadá do kategórie farebnosti a viditeľnosti,
				 * do ktorej principiálne patrí.</p>
				 * 
				 * @return aktuálny druh náteru, to jest druh výplne
				 *     a obrysových čiar kreslených tvarov alebo {@code valnull}
				 * 
				 * @see #náter(Paint)
				 * @see #zrušNáter()
				 */
				public Paint náter() { return náter; }

				/** <p><a class="alias"></a> Alias pre {@link #náter() náter}.</p> */
				public Paint nater() { return náter; }


				/**
				 * <p>Upraví druh náteru, ktorý grafický robot používa na kreslenie
				 * (kreslenie čiar pera, vypĺňanie plôch a kreslenie obrysových
				 * čiar ním generovaných pečiatkových tvarov, kreslenie svojho
				 * predvoleného tvaru, prípadne iné).
				 * Ak je namiesto parametra {@code novýNáter} zadaná hodnota
				 * {@code valnull}, tak bude definícia náteru zrušená a robot
				 * bude kresliť objekty a čiary podľa svojich farebných
				 * nastavení – pozri vlastnosti {@link #farba() farba}
				 * a {@link #cieľováFarba() cieľováFarba}.
				 * Použitie tejto vlastnosti lepšie ukazujú dva príklady
				 * nižšie.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Táto vlastnosť robota sa
				 * pôvodne mala volať výplň, ale tento názov kolidoval
				 * s príkazom vyplň, preto bolo potrebné hľadať iné
				 * pomenovanie. Nakoniec sa autor priklonil k názvu náter
				 * a popri tom sa ukázalo, že s týmto pomenovaním vlastnosť
				 * lepšie zapadá do kategórie farebnosti a viditeľnosti,
				 * do ktorej principiálne patrí.</p>
				 * 
				 * <p class="attention"><b>Upozornenie:</b> Obidva nasledujúce
				 * príklady vyžadujú importovanie týchto dvoch tried Javy:
				 * {@link java.awt.RadialGradientPaint}
				 * a {@link java.awt.MultipleGradientPaint.CycleMethod}.
				 * Druhý príklad navyše vyžaduje aj importovanie týchto troch
				 * tried Javy:
				 * {@link java.awt.MultipleGradientPaint.ColorSpaceType},
				 * {@link java.awt.geom.Point2D}
				 * a {@link java.awt.geom.AffineTransform}.</p>
				 * 
				 * <p><b>Príklad 1:</b></p>
				 * 
				 * <p>Tento príklad ukazuje použitie triedy Javy
				 * {@link java.awt.RadialGradientPaint RadialGradientPaint}
				 * na výrobu opakujúceho sa excentrického náteru s kruhovým
				 * farebným prechodom. Náter je použitý na vyplnenie kruhu
				 * generovaného robotom. Rozdielnosť súradnicových priestorov
				 * Javy a programovacieho rámca je vyriešená s pomocou
				 * prislúchajúcich metód triedy {@link Svet Svet}.</p>
				 * 
				 * <pre CLASS="example">
					{@code valsuper}({@code num250}, {@code num250});
					{@link GRobot#skry() skry}();

					{@code comm// Príprava polí kotiev:}
					{@code typefloat}[] polohy = {{@code num0.0f}, {@code num0.33f}, {@code num1.0f}};
					{@link Farba Farba}[] farby  = {{@link Farebnosť#svetlošedá svetlošedá}, {@link Farebnosť#biela biela}, {@link Farebnosť#svetlotyrkysová svetlotyrkysová}};

					{@code comm// Vytvorenie náteru kruhového farebného prechodu:}
					{@link java.awt.RadialGradientPaint RadialGradientPaint} náter = {@code kwdnew} {@link java.awt.RadialGradientPaint#RadialGradientPaint(float, float, float, float, float, float[], Color[], java.awt.MultipleGradientPaint.CycleMethod) RadialGradientPaint}(
						({@code typefloat}){@link Svet Svet}.{@link Svet#prepočítajX(double) prepočítajX}({@code num0}),
							({@code typefloat}){@link Svet Svet}.{@link Svet#prepočítajY(double) prepočítajY}({@code num5}), {@code num30}, {@code comm// stred a polomer}
						({@code typefloat}){@link Svet Svet}.{@link Svet#prepočítajX(double) prepočítajX}({@code num20}),
							({@code typefloat}){@link Svet Svet}.{@link Svet#prepočítajY(double) prepočítajY}({@code num10}),   {@code comm// ohnisko}
						polohy, {@code comm// polohy farebných kotiev}
						farby,  {@code comm// farby farebných kotiev}
						{@link java.awt.MultipleGradientPaint.CycleMethod CycleMethod}.{@link java.awt.MultipleGradientPaint.CycleMethod#REFLECT REFLECT}); {@code comm// metóda opakovania prechodu zrkadlením}

					{@code comm// Nastavenie (aktivovanie) náteru a nakreslenie kruhu:}
					{@link GRobot#náter(java.awt.Paint) náter}(náter);
					{@link GRobot#kruh(double) kruh}({@code num100});
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>kruhovy-nater.png<alt/>Excentrický kruhový
				 * náter.</image>Excentrický kruhový náter vypĺňajúci
				 * kruhovú oblasť.</p>
				 * 
				 * <p><b>Príklad 2:</b></p>
				 * 
				 * <p>V tomto príklade je ukázané, ako sa dá trieda Javy
				 * {@link java.awt.RadialGradientPaint RadialGradientPaint}
				 * použiť na výrobu náteru simulujúceho tieň objektu. Príklad
				 * zároveň ukazuje spôsob umiestnenia farebného prechodu
				 * (gradientu) s ohľadom na rozdielnosť súradnicových
				 * priestorov Javy a programovacieho rámca GRobot a tiež
				 * spôsob transformácie kruhového gradientu na elipsový.</p>
				 * 
				 * <pre CLASS="example">
					{@code valsuper}({@code num250}, {@code num250});
					{@link GRobot#skry() skry}();

					{@code comm// Faktor veľkosti (polovica polomeru) gule:}
					{@code kwdfinal} {@code typedouble} rozmer = {@code num40.0};

					{@code comm// Príprava polí kotiev:}
					{@code typefloat}[] polohy = {{@code num0.0f}, {@code num1.0f}};
					{@link Farba Farba}[] farby  = {{@link Farebnosť#čierna čierna}, {@link Farebnosť#žiadna žiadna}};

					{@code comm// Vytvorenie inštancie stredu tieňa s prepočítanými súradnicami:}
					{@link java.awt.geom.Point2D Point2D}.{@link java.awt.geom.Point2D.Double Double} polohaStredu = {@code kwdnew} {@link java.awt.geom.Point2D.Double#Point2D.Double(double, double) Point2D.Double}(
						{@link Svet Svet}.{@link Svet#prepočítajX(double) prepočítajX}({@code num0}), {@link Svet Svet}.{@link Svet#prepočítajY(double) prepočítajY}(-(rozmer * {@code num1.75})));

					{@code comm// Príprava transformácie tieňa:}
					{@link java.awt.geom.AffineTransform AffineTransform} transformácia = {@code kwdnew} {@link java.awt.geom.AffineTransform#AffineTransform() AffineTransform}();
					transformácia.{@link java.awt.geom.AffineTransform#concatenate(java.awt.geom.AffineTransform) concatenate}({@code kwdnew} {@link SVGPodpora SVGPodpora}.{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, Double...) Transformácia}(
						{@link SVGPodpora SVGPodpora}.{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, Double...) Transformácia}.{@link SVGPodpora.Transformácia#POSUN POSUN},
						polohaStredu.{@link java.awt.geom.Point2D#getX() getX}(), polohaStredu.{@link java.awt.geom.Point2D#getY() getY}()).{@link SVGPodpora.Transformácia#daj() daj}());
					transformácia.{@link java.awt.geom.AffineTransform#concatenate(java.awt.geom.AffineTransform) concatenate}({@code kwdnew} {@link SVGPodpora SVGPodpora}.{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, Double...) Transformácia}(
						{@link SVGPodpora SVGPodpora}.{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, Double...) Transformácia}.{@link SVGPodpora.Transformácia#MIERKA_Y MIERKA_Y}, {@code num0.5}).{@link SVGPodpora.Transformácia#daj() daj}());
					transformácia.{@link java.awt.geom.AffineTransform#concatenate(java.awt.geom.AffineTransform) concatenate}({@code kwdnew} {@link SVGPodpora SVGPodpora}.{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, Double...) Transformácia}(
						{@link SVGPodpora SVGPodpora}.{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, Double...) Transformácia}.{@link SVGPodpora.Transformácia#POSUN POSUN},
						-polohaStredu.{@link java.awt.geom.Point2D#getX() getX}(), -polohaStredu.{@link java.awt.geom.Point2D#getY() getY}()).{@link SVGPodpora.Transformácia#daj() daj}());

					{@code comm// Vytvorenie náteru tieňa:}
					{@link java.awt.RadialGradientPaint RadialGradientPaint} náter = {@code kwdnew} {@link java.awt.RadialGradientPaint#RadialGradientPaint(java.awt.geom.Point2D, float, java.awt.geom.Point2D, float[],
					Color[], java.awt.MultipleGradientPaint.CycleMethod, java.awt.MultipleGradientPaint.ColorSpaceType, AffineTransform) RadialGradientPaint}(
						polohaStredu, ({@code typefloat})(rozmer * {@code num2}), polohaStredu, polohy, farby,
						{@link java.awt.MultipleGradientPaint.CycleMethod CycleMethod}.{@link java.awt.MultipleGradientPaint.CycleMethod#NO_CYCLE NO_CYCLE}, {@link java.awt.MultipleGradientPaint.ColorSpaceType ColorSpaceType}.{@link java.awt.MultipleGradientPaint.ColorSpaceType#LINEAR_RGB LINEAR_RGB},
						transformácia);

					{@code comm// Nakreslenie tieňa:}
					{@link GRobot#odskoč(double) odskoč}(rozmer * {@code num1.75});
					{@link GRobot#náter(java.awt.Paint) náter}(náter);
					{@link GRobot#vyplňElipsu(double, double) vyplňElipsu}(rozmer * {@code num2}, rozmer);
					{@link Plátno podlaha}.{@link Plátno#rozmaž(int, int) rozmaž}({@code num12}, {@code num3});
					{@link Svet Svet}.{@link Svet#farbaPozadia(Color) farbaPozadia}({@link Farebnosť#svetlošedá svetlošedá}.{@link Farba#bledšia() bledšia}());
					{@link GRobot#náter(java.awt.Paint) náter}({@code valnull});
					{@link GRobot#skoč(double) skoč}(rozmer * {@code num1.75});

					{@code comm// Nakreslenie lúčov nad guľou:}
					{@link GRobot#skoč(double) skoč}(rozmer);
					{@link GRobot#farba(Color) farba}({@link Farebnosť#žltá žltá});
					{@link GRobot#vyplňHviezdu(double) vyplňHviezdu}(rozmer * {@code num2});
					{@link GRobot#vpravo(double) vpravo}({@code num36});
					{@link GRobot#vyplňHviezdu(double) vyplňHviezdu}(rozmer * {@code num2});
					{@link GRobot#vľavo(double) vľavo}({@code num36});
					{@link GRobot#odskoč(double) odskoč}(rozmer);

					{@code comm// Nakreslenie gule:}
					{@link GRobot#farba(Color) farba}({@link Farebnosť#svetlomodrá svetlomodrá});
					{@link GRobot#kruh(double) kruh}(rozmer * {@code num2});
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>nater-ako-tien.png<alt/>Náter v úlohe
				 * tieňa.</image>Scéna, v ktorej plní kruhový prechod
				 * úlohu tieňa.</p>
				 * 
				 * @param novýNáter nový druh náteru, to jest druhu výplne
				 *     a obrysových čiar kreslených tvarov
				 * 
				 * @see #náter()
				 * @see #zrušNáter()
				 */
				public void náter(Paint novýNáter)
				{
					// …
					náter = novýNáter;
				}

				/** <p><a class="alias"></a> Alias pre {@link #náter(Paint) náter}.</p> */
				public void nater(Paint novýNáter) { náter(novýNáter); }

				/**
				 * <p>Zruší definíciu náteru grafického robota. Volanie tejto metódy
				 * je ekvivalentné volaniu metódy:
				 * {@link #náter(Paint) náter}{@code (}{@code valnull}{@code )}.</p>
				 * 
				 * @see #náter()
				 * @see #náter(Paint)
				 */
				public void zrušNáter() { náter(null); }

				/** <p><a class="alias"></a> Alias pre {@link #zrušNáter() zrušNáter}.</p> */
				public void zrusNater() { náter(null); }


				/**
				 * <p>Zistí aktuálnu polohu pera.</p>
				 * 
				 * @return {@code valtrue} ak je pero položené,
				 *     {@code valfalse} v opačnom prípade
				 * 
				 * @see #polohaPera(boolean)
				 * @see #peroZdvihnuté()
				 * @see #peroPoložené()
				 * @see #zdvihniPero()
				 * @see #položPero()
				 * @see #polohaPeraDoma() polohaPeraDoma
				 * @see #kreslenieTvarovPovolené() kreslenieTvarovPovolené
				 */
				public boolean polohaPera() { return peroPoložené; }

				/**
				 * <p>Zistí aktuálnu polohu pera.</p>
				 * 
				 * @return {@code valtrue} ak je pero zdvihnuté z plátna,
				 *     {@code valfalse} v opačnom prípade
				 * 
				 * @see #polohaPera()
				 * @see #polohaPera(boolean)
				 * @see #peroPoložené()
				 * @see #zdvihniPero()
				 * @see #položPero()
				 */
				public boolean peroZdvihnuté() { return !peroPoložené; }

				/** <p><a class="alias"></a> Alias pre {@link #peroZdvihnuté() peroZdvihnuté}.</p> */
				public boolean peroZdvihnute() { return !peroPoložené; }

				/**
				 * <p>Zistí aktuálnu polohu pera.</p>
				 * 
				 * @return {@code valtrue} ak je pero položené,
				 *     {@code valfalse} v opačnom prípade
				 * 
				 * @see #polohaPera()
				 * @see #polohaPera(boolean)
				 * @see #peroZdvihnuté()
				 * @see #zdvihniPero()
				 * @see #položPero()
				 */
				public boolean peroPoložené() { return peroPoložené; }

				/** <p><a class="alias"></a> Alias pre {@link #peroPoložené() peroPoložené}.</p> */
				public boolean peroPolozene() { return peroPoložené; }

				/**
				 * <p>Zdvihne alebo položí pero na základe zadanej pravdivostnej
				 * hodnoty – {@code valtrue} položí pero, {@code valfalse}
				 * zdvihne pero.</p>
				 * 
				 * @param polož {@code valtrue}/&#8203;{@code valfalse}
				 * 
				 * @see #polohaPera()
				 * @see #peroZdvihnuté()
				 * @see #peroPoložené()
				 * @see #zdvihniPero()
				 * @see #položPero()
				 * @see #polohaPeraDoma(Boolean) polohaPeraDoma
				 */
				public void polohaPera(boolean polož) { peroPoložené = polož; }

				/**
				 * <p>Zdvihne pero tohto robota z plátna podlahy alebo stropu.
				 * Robot sa bude presúvať bez kreslenia čiary. Opačný efekt
				 * má metóda {@link #položPero() položPero}.</p>
				 * 
				 * @see #polohaPera()
				 * @see #polohaPera(boolean)
				 * @see #peroZdvihnuté()
				 * @see #peroPoložené()
				 * @see #položPero()
				 * @see #dopredu(double) dopredu
				 * @see #vzad(double) vzad
				 * @see #choďNa(double, double) choďNa
				 * @see #choďPoOblúku(double, double) choďPoOblúku
				 * @see #zdvihniPeroDoma() zdvihniPeroDoma
				 * @see #nekresliTvary() nekresliTvary
				 */
				public void zdvihniPero() { peroPoložené = false; }

				/**
				 * <p>Položí pero tohto robota na plátno podlahy alebo stropu.
				 * Robot bude pri presune kresliť čiaru. Opačný efekt má
				 * metóda {@link #zdvihniPero() zdvihniPero}.</p>
				 * 
				 * @see #polohaPera()
				 * @see #polohaPera(boolean)
				 * @see #peroZdvihnuté()
				 * @see #peroPoložené()
				 * @see #zdvihniPero()
				 * @see #dopredu(double) dopredu
				 * @see #vzad(double) vzad
				 * @see #choďNa(double, double) choďNa
				 * @see #choďPoOblúku(double, double) choďPoOblúku
				 * @see #položPeroDoma() položPeroDoma
				 * @see #kresliTvary() kresliTvary
				 */
				public void položPero() { peroPoložené = true; }

				/** <p><a class="alias"></a> Alias pre {@link #položPero() položPero}.</p> */
				public void polozPero() { peroPoložené = true; }


			// Viditeľnosť

				/**
				 * <p>Zistí, či je robot viditeľný alebo skrytý. Metóda nezistí,
				 * či skutočne robot vidno, iba vráti stav zobrazenia určený
				 * metódami {@link #zobraz() zobraz} a {@link #skry() skry}.
				 * (To znamená, že ak je napríklad robot skrytý za nejakým
				 * objektom, táto metóda to nezistí.) Alternatívou tejto
				 * metódy je metóda {@link #zobrazený() zobrazený}.</p>
				 * 
				 * @return {@code valtrue} ak je robot viditeľný, {@code 
				 *     valfalse} v opačnom prípade
				 * 
				 * @see #zobrazený()
				 * @see #skrytý()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #viditeľnýDoma() viditeľnýDoma
				 */
				public boolean viditeľný() { return viditeľný; }

				/** <p><a class="alias"></a> Alias pre {@link #viditeľný() viditeľný}.</p> */
				public boolean viditelny() { return viditeľný; }

				/**
				 * <p>Zistí, či je robot viditeľný alebo skrytý. Metóda nezistí,
				 * či je skutočne robot vidno, iba vráti stav zobrazenia určený
				 * metódami {@link #zobraz() zobraz} a {@link #skry() skry}.
				 * (To znamená, že ak je napríklad robot skrytý za nejakým
				 * objektom, táto metóda to nezistí.)</p>
				 * 
				 * @return {@code valtrue} ak je robot zobrazený, {@code 
				 *     valfalse} v opačnom prípade
				 * 
				 * @see #viditeľný()
				 * @see #skrytý()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #zobrazenýDoma() zobrazenýDoma
				 */
				public boolean zobrazený() { return viditeľný; }

				/** <p><a class="alias"></a> Alias pre {@link #zobrazený() zobrazený}.</p> */
				public boolean zobrazeny() { return viditeľný; }

				/**
				 * <p>Zistí, či je robot viditeľný alebo skrytý. Metóda nezistí,
				 * či skutočne robot nevidno, iba vráti stav zobrazenia
				 * určený metódami {@link #zobraz() zobraz} a {@link #skry()
				 * skry}. (To znamená, že ak je napríklad robot skrytý za
				 * nejakým objektom, táto metóda to nezistí.) Alternatívou
				 * tejto metódy je metóda {@link #viditeľný() viditeľný}.</p>
				 * 
				 * @return {@code valtrue} ak je robot skrytý, {@code 
				 *     valfalse} v opačnom prípade
				 * 
				 * @see #viditeľný()
				 * @see #zobrazený()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #skry()
				 * @see #skrytýDoma() skrytýDoma
				 */
				public boolean skrytý() { return !viditeľný; }

				/** <p><a class="alias"></a> Alias pre {@link #skrytý() skrytý}.</p> */
				public boolean skryty() { return !viditeľný; }

				/**
				 * <p>Zobrazí tento robot. Alternatívou tejto metódy je
				 * metóda {@link #zobraz() zobraz}. Opačný efekt má metóda
				 * {@link #skry() skry}. Ak robot nebol viditeľný, tak je
				 * spustená reakcia {@link #zobrazenie() zobrazenie}.</p>
				 * 
				 * @see #viditeľný()
				 * @see #zobrazený()
				 * @see #skrytý()
				 * @see #zobraz()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 * @see #skry()
				 * @see #ukážDoma() ukážDoma
				 */
				public void ukáž()
				{
					// Toto nie je alias‼ Prípadné zmeny treba
					// vniesť aj do metódy zobraz (nižšie)‼
					if (!viditeľný)
					{
						viditeľný = true;
						zobrazenie();
					}
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #ukáž() ukáž}.</p> */
				public void ukaz() { ukáž(); }

				/**
				 * <p>Zobrazí tento robot. Alternatívou tejto metódy je
				 * metóda {@link #ukáž() ukáž}. Opačný efekt má metóda
				 * {@link #skry() skry}. Ak robot nebol viditeľný, tak je
				 * spustená reakcia {@link #zobrazenie() zobrazenie}.</p>
				 * 
				 * @see #viditeľný()
				 * @see #zobrazený()
				 * @see #skrytý()
				 * @see #ukáž()
				 * @see #ukáž(boolean)
				 * @see #zobraz(boolean)
				 * @see #skry()
				 * @see #zobrazDoma() zobrazDoma
				 */
				public void zobraz()
				{
					// Toto nie je alias‼ Prípadné zmeny treba
					// vniesť aj do metódy ukáž (vyššie)‼
					if (!viditeľný)
					{
						viditeľný = true;
						zobrazenie();
					}
					Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Skryje tento robot. Ak bol robot pred volaním tejto
				 * metódy viditeľný, tak je spustená reakcia
				 * {@link #skrytie() skrytie}. Opačný efekt majú metódy
				 * {@link #ukáž() ukáž} a {@link #zobraz() zobraz} (ktoré
				 * fungujú identicky – jedna je alternatívou druhej). Uvedené
				 * metódy majú definované aj verzie s parametrom, ktorého
				 * hodnota určuje, či má byť robot zobrazený alebo skrytý.</p>
				 * 
				 * @see #viditeľný()
				 * @see #zobrazený()
				 * @see #skrytý()
				 * @see #ukáž()
				 * @see #ukáž(boolean)
				 * @see #zobraz()
				 * @see #zobraz(boolean)
				 * @see #skryDoma() skryDoma
				 */
				public void skry()
				{
					if (viditeľný)
					{
						viditeľný = false;
						skrytie();
					}
					Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Zobrazí alebo skryje tento robot podľa hodnoty
				 * parametra {@code ukáž}. Alternatívou tejto metódy je
				 * metóda {@link #zobraz(boolean) zobraz}. Okrem tejto
				 * dvojice metód je definovaná trojica bezparametrických
				 * metód: {@link #ukáž() ukáž}, {@link #zobraz() zobraz}
				 * a {@link #skry() skry}.</p>
				 * 
				 * @param zobraz ak je hodnota tohto parametera rovná
				 *     {@code valtrue} a robot nie je viditeľný, tak bude
				 *     zobrazený (čo bude mať za následok automatické
				 *     spustenie reakcie {@link #zobrazenie() zobrazenie});
				 *     ak je hodnota tohto parametera rovná {@code valfalse}
				 *     a robot je viditeľný, tak bude skrytý (čo bude mať za
				 *     následok automatické spustenie reakcie
				 *     {@link #skrytie() skrytie})
				 * 
				 * @see #viditeľný()
				 * @see #zobrazený()
				 * @see #skrytý()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #zobraz(boolean)
				 * @see #skry()
				 * @see #ukážDoma() ukážDoma
				 */
				public void ukáž(boolean ukáž)
				{
					// Toto riešenie zároveň zabezpečí prípadné spustenie
					// reakcií zobrazenie/skrytie:
					if (ukáž) ukáž(); else skry();
				}

				/** <p><a class="alias"></a> Alias pre {@link #ukáž(boolean) ukáž}.</p> */
				public void ukaz(boolean ukáž) { ukáž(ukáž); }

				/**
				 * <p>Zobrazí alebo skryje tento robot podľa hodnoty
				 * parametra {@code zobraz}. Alternatívou tejto metódy je
				 * metóda {@link #ukáž(boolean) ukáž}. Okrem tejto
				 * dvojice metód je definovaná trojica bezparametrických
				 * metód: {@link #ukáž() ukáž}, {@link #zobraz() zobraz}
				 * a {@link #skry() skry}.</p>
				 * 
				 * @param zobraz ak je hodnota tohto parametera rovná
				 *     {@code valtrue} a robot nie je viditeľný, tak bude
				 *     zobrazený (čo bude mať za následok automatické
				 *     spustenie reakcie {@link #zobrazenie() zobrazenie});
				 *     ak je hodnota tohto parametera rovná {@code valfalse}
				 *     a robot je viditeľný, tak bude skrytý (čo bude mať za
				 *     následok automatické spustenie reakcie
				 *     {@link #skrytie() skrytie})
				 * 
				 * @see #viditeľný()
				 * @see #zobrazený()
				 * @see #skrytý()
				 * @see #ukáž()
				 * @see #zobraz()
				 * @see #ukáž(boolean)
				 * @see #skry()
				 * @see #zobrazDoma() zobrazDoma
				 */
				public void zobraz(boolean zobraz)
				{
					// Toto riešenie zároveň zabezpečí prípadné spustenie
					// reakcií zobrazenie/skrytie:
					if (zobraz) zobraz(); else skry();
				}


			// Priehľadnosť

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu úroveň
				 * (ne)priehľadnosti tvaru tohto robota.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> <!--Táto vlastnosť sa
				 * vzťahuje len na zobrazenie (kreslenie) tvaru robota. Nemá
				 * vplyv na priehľadnosť priehľadnosť objektov (čiary, výplne
				 * atď.), ktoré robot kreslí na plátno.-->
				 * Kreslenie priehľadných tvarov so sebou prináša jeden efekt,
				 * ktorý je vhodné vziať do úvahy. Pozri podrobnejšiu poznámku
				 * v opise metódy {@link #priehľadnosť(double)
				 * priehľadnosť(priehľadnosť)}.</p>
				 * 
				 * @return aktuálna úroveň priehľadnosti tvaru tohto robota
				 * 
				 * @see #priehľadnosť(double)
				 * @see #upravPriehľadnosť(double)
				 * @see #priehľadnosťDoma()
				 */
				public double priehľadnosť() { return priehľadnosť; }

				/** <p><a class="alias"></a> Alias pre {@link #priehľadnosť() priehľadnosť}.</p> */
				public double priehladnost() { return priehľadnosť; }

				/**
				 * <p><a class="setter"></a> Nastaví novú úroveň
				 * (ne)priehľadnosti tohto robota použitú pri kreslení
				 * (zobrazení) jeho tvaru. Ak chceme, aby bola táto vlastnosť
				 * korektne použitá, musíme vopred upraviť jej hodnotu, to
				 * znamená, že ešte pred samotným kreslením (tvaru) robota.
				 * Počas kreslenia {@linkplain #vlastnýTvar(KreslenieTvaru)
				 * vlastného tvaru} je už neskoro. Rovnako {@linkplain Obrázok
				 * obrázky} použité namiesto {@linkplain #vlastnýTvar(Image)
				 * vlastného tvaru} by nemali mať nastavenú {@linkplain 
				 * Obrázok#priehľadnosť(double) vlastnú úroveň priehľadnosti},
				 * ak nechceme, aby ich úroveň {@linkplain 
				 * Obrázok#priehľadnosť(double) priehľadnosti} prekryla
				 * nastavenie priehľadnosti tohto robota (vlastnou úrovňou
				 * priehľadnosti obrázka máme na mysli inú hodnotu, než
				 * {@code num1.0}).</p>
				 * 
				 * <p>Úroveň 0.0 znamená, že robot by nemal byť zobrazený,
				 * avšak vždy dôjde minimálne k pokusu o jeho nakreslenie.
				 * Keď chceme robot skutočne skryť, použijeme metódu
				 * {@link #skry() skry}. Úroveň 1.0 znamená, že robot bude
				 * zobrazený bez úpravy priehľadnosti.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> <!-- Táto vlastnosť sa
				 * vzťahuje len na zobrazenie (kreslenie) tvaru robota. Nemá
				 * vplyv na priehľadnosť priehľadnosť objektov (čiary, výplne
				 * atď.), ktoré robot kreslí na plátno.<br /> <br / -->Pri
				 * kreslení vlastného tvaru robota treba popri uvedenom vziať
				 * do úvahy ešte jeden kľúčový fakt – počas kreslenia
				 * vlastného tvaru pôjde o zmenu priehľadnosti kreslenia
				 * jednotlivých prvkov, z ktorých tento tvar pozostáva.
				 * To znamená, že ak je tvar robota tvorený viacerými
				 * prvkami (čiarami alebo vyplnenými tvarmi), ktoré sa
				 * prekrývajú, tak (ne)priehľadnosť prekrývajúcich sa častí
				 * sa „sčíta“ (dalo by sa povedať, že v častiach, ktoré sa
				 * prekrývajú sa bude „kumulovať nepriehľadnosť“). Ukazuje
				 * to táto animácia:<br /> <br /><image>slnecny-kriz-priehladnost.gif<alt/>Slnečný
				 * kríž.</image></p>
				 * 
				 * @param priehľadnosť nová úroveň priehľadnosti tvaru tohto
				 *     robota (0.0 – 1.0)
				 * 
				 * @see #priehľadnosť()
				 * @see #upravPriehľadnosť(double)
				 * @see #priehľadnosťDoma(Double)
				 */
				public void priehľadnosť(double priehľadnosť)
				{
					this.priehľadnosť = (float)priehľadnosť;
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #priehľadnosť(double) priehľadnosť}.</p> */
				public void priehladnost(double priehľadnosť)
				{ priehľadnosť(priehľadnosť); }

				/**
				 * <p>Skopíruje úroveň (ne)priehľadnosti zo zadaného objektu.</p>
				 * 
				 * @param objekt objekt určujúci novú úroveň priehľadnosti
				 * 
				 * @see #priehľadnosť()
				 * @see #upravPriehľadnosť(double)
				 */
				public void priehľadnosť(Priehľadnosť objekt)
				{
					this.priehľadnosť = (float)objekt.priehľadnosť();
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #priehľadnosť(Priehľadnosť) priehľadnosť}.</p> */
				public void priehladnost(Priehľadnosť objekt)
				{ priehľadnosť(objekt); }

				/**
				 * <p>Upraví úroveň (ne)priehľadnosti tohto robota. Viac
				 * informácií o priehľadnosti je v opise metódy {@link 
				 * #priehľadnosť(double) priehľadnosť}.</p>
				 * 
				 * @param zmena hodnota, ktorou bude násobená aktuálna
				 *     hodnota priehľadnosti; príklady: 0.5 – priehľadnosť
				 *     bude znížená o polovicu, 2.0 – úroveň priehľadnosti
				 *     bude zdvojnásobená
				 * 
				 * @see #priehľadnosť(double)
				 * @see #priehľadnosť()
				 */
				public void upravPriehľadnosť(double zmena)
				{
					if (0 == priehľadnosť) priehľadnosť = 0.1f;
					else priehľadnosť *= (float)zmena;
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravPriehľadnosť(double) upravPriehľadnosť}.</p> */
				public void upravPriehladnost(double zmena)
				{ upravPriehľadnosť(zmena); }


			// Písmo

				/**
				 * <p><a class="getter"></a> Vráti aktuálny typ písma, ktorým
				 * robot píše.</p>
				 * 
				 * @return objekt typu {@link Písmo} – aktuálny typ písma
				 * 
				 * @see #písmo(Font)
				 * @see #písmo(String, double)
				 * @see #predvolenéPísmo()
				 * @see #písmoDoma()
				 */
				public Písmo písmo() { return aktuálnePísmo; }

				/** <p><a class="alias"></a> Alias pre {@link #písmo() písmo}.</p> */
				public Pismo pismo() { return new Pismo(aktuálnePísmo); }

				/**
				 * <p><a class="setter"></a> Nastaví nový typ písma, ktorým bude
				 * robot písať.</p>
				 * 
				 * @param novéPísmo objekt typu {@link Písmo} alebo
				 *     {@link java.awt.Font} určujúci nový typ písma robota
				 * 
				 * @see #písmo()
				 * @see #písmo(Font)
				 * @see #písmo(String, double)
				 * @see #predvolenéPísmo()
				 * @see #písmoDoma(Font)
				 */
				public void písmo(Font novéPísmo)
				{
					if (novéPísmo instanceof Písmo)
						aktuálnePísmo = (Písmo)novéPísmo;
					else
						aktuálnePísmo = new Písmo(novéPísmo);
				}

				/** <p><a class="alias"></a> Alias pre {@link #písmo(Font) písmo}.</p> */
				public void pismo(Font novéPísmo) { písmo(novéPísmo); }

				/**
				 * <p>Nastaví nový typ písma, ktorým bude robot písať.</p>
				 * 
				 * @param názov názov písma; môže byť všeobecný názov
				 *     logického písma (Dialog, DialogInput, Monospaced,
				 *     Serif, SansSerif…) alebo názov
				 *     konkrétneho písma (Times New Roman, Arial…)
				 * @param veľkosť veľkosť písma v bodoch (hodnota je
				 *     zaokrúhlená na typ {@code typefloat})
				 * @return objekt typu {@link Písmo} určujúci nový typ písma
				 *     robota
				 * 
				 * @see #písmo()
				 * @see #písmo(Font)
				 * @see #predvolenéPísmo()
				 */
				public Písmo písmo(String názov, double veľkosť)
				{
					return aktuálnePísmo = new Písmo(názov, Písmo.PLAIN, veľkosť);
				}

				/** <p><a class="alias"></a> Alias pre {@link #písmo(String, double) písmo}.</p> */
				public Pismo pismo(String názov, double veľkosť)
				{ return new Pismo(písmo(názov, veľkosť)); }

				/**
				 * <p>Vráti nastavenie typu písma robota na predvolené.</p>
				 * 
				 * @see #písmo()
				 * @see #písmo(Font)
				 * @see #písmo(String, double)
				 */
				public void predvolenéPísmo() { písmo(predvolenéPísmo); }

				/** <p><a class="alias"></a> Alias pre {@link #predvolenéPísmo() predvolenéPísmo}.</p> */
				public void predvolenePismo() { písmo(predvolenéPísmo); }


				/**
				 * <p>Zistí výšku riadka textu v bodoch pri použití aktuálneho
				 * typu písma. Ak metóda z nejakého dôvodu nedokáže získať
				 * kontext grafiky, tak vráti nulu – {@code num0}.</p>
				 * 
				 * @return výška riadka textu v bodocj pri použití aktuálneho
				 *     písma
				 */
				public int výškaRiadka()
				{
					if (null != Svet.grafikaSveta1)
					{
						Svet.grafikaSveta1.setFont(aktuálnePísmo);
						return Svet.grafikaSveta1.getFontMetrics().getHeight();
					}
					return 0;
				}

				/** <p><a class="alias"></a> Alias pre {@link #výškaRiadka() výškaRiadka}.</p> */
				public int vyskaRiadka() { return výškaRiadka(); }

				/**
				 * <p>Zistí šírku zadaného reťazca v bodoch pri použití aktuálneho
				 * typu písma. Ak metóda z nejakého dôvodu nedokáže získať
				 * kontext grafiky, tak vráti nulu – {@code num0}.</p>
				 * 
				 * @param reťazec reťazec, ktorého šírka má byť vrátená
				 * @return šírka zadaného reťazca v bodoch pri použití
				 *     aktuálneho písma
				 */
				public int šírkaReťazca(String reťazec)
				{
					if (null != Svet.grafikaSveta1)
					{
						Svet.grafikaSveta1.setFont(aktuálnePísmo);
						return Svet.grafikaSveta1.getFontMetrics().
							stringWidth(reťazec);
					}
					return 0;
				}

				/** <p><a class="alias"></a> Alias pre {@link #šírkaReťazca(String) šírkaReťazca}.</p> */
				public int sirkaRetazca(String reťazec)
				{ return šírkaReťazca(reťazec); }

				/**
				 * <p>Zistí šírku medzery v bodoch pri použití aktuálneho typu
				 * písma. Ak metóda z nejakého dôvodu nedokáže získať kontext
				 * grafiky, tak vráti nulu – {@code num0}.</p>
				 * 
				 * @return šírka medzery v bodoch pri použití aktuálneho písma
				 */
				public int šírkaMedzery()
				{
					if (null != Svet.grafikaSveta1)
					{
						Svet.grafikaSveta1.setFont(aktuálnePísmo);
						return Svet.grafikaSveta1.getFontMetrics().
							stringWidth(" ");
					}
					return 0;
				}

				/** <p><a class="alias"></a> Alias pre {@link #šírkaMedzery() šírkaMedzery}.</p> */
				public int sirkaMedzery() { return šírkaMedzery(); }

				/**
				 * <p>Zistí najväčšiu šírku znaku v bodoch pri použití aktuálneho
				 * typu písma. Ak metóda z nejakého dôvodu nedokáže získať
				 * kontext grafiky, tak vráti nulu – {@code num0}.</p>
				 * 
				 * @return najväčšia šírka znaku v bodoch pri použití
				 *     aktuálneho písma
				 */
				public int najväčšiaŠírkaZnaku()
				{
					if (null != Svet.grafikaSveta1)
					{
						Svet.grafikaSveta1.setFont(aktuálnePísmo);
						return Svet.grafikaSveta1.getFontMetrics().
							getMaxAdvance();
					}
					return 0;
				}

				/** <p><a class="alias"></a> Alias pre {@link #najväčšiaŠírkaZnaku() najväčšiaŠírkaZnaku}.</p> */
				public int najvacsiaSirkaZnaku() { return najväčšiaŠírkaZnaku(); }


			// Poloha a smer

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu x-ovú súradnicu robota.</p>
				 * 
				 * @return aktuálna x-ová súradnica robota
				 */
				public double polohaX() { return aktuálneX; }

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu y-ovú súradnicu robota.</p>
				 * 
				 * @return aktuálna y-ová súradnica robota
				 */
				public double polohaY() { return aktuálneY; }

				/** <p><a class="alias"></a> Alias pre {@link #polohaX() polohaX}.</p> */
				public double súradnicaX() { return aktuálneX; }

				/** <p><a class="alias"></a> Alias pre {@link #súradnicaX() súradnicaX}.</p> */
				public double suradnicaX() { return aktuálneX; }

				/** <p><a class="alias"></a> Alias pre {@link #polohaY() polohaY}.</p> */
				public double súradnicaY() { return aktuálneY; }

				/** <p><a class="alias"></a> Alias pre {@link #súradnicaY() súradnicaY}.</p> */
				public double suradnicaY() { return aktuálneY; }

				/**
				 * <p><a class="setter"></a> Prikáže robotu, aby preskočil na
				 * konkrétnu súradnicu na podlahe (strope) v smere osi x. Robot
				 * nekreslí čiaru, ani nezmení smer.</p>
				 * 
				 * @param novéX nová x-ová súradnica
				 */
				public void polohaX(double novéX)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
					}

					aktuálneX = novéX;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(aktuálneY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(aktuálneY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> polohaX(novýCieľX));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/**
				 * <p><a class="setter"></a> Prikáže robotu, aby preskočil na
				 * konkrétnu súradnicu na podlahe (strope) v smere osi y. Robot
				 * nekreslí čiaru, ani nezmení smer.</p>
				 * 
				 * @param novéY nová y-ová súradnica
				 */
				public void polohaY(double novéY)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéY = aktuálneY;
					}

					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(novéY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> polohaY(novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #polohaX(double) polohaX}.</p> */
				public void súradnicaX(double novéX) { polohaX(novéX); }

				/** <p><a class="alias"></a> Alias pre {@link #súradnicaX(double) súradnicaX}.</p> */
				public void suradnicaX(double novéX) { polohaX(novéX); }

				/** <p><a class="alias"></a> Alias pre {@link #polohaY(double) polohaY}.</p> */
				public void súradnicaY(double novéY) { polohaY(novéY); }

				/** <p><a class="alias"></a> Alias pre {@link #súradnicaY(double) súradnicaY}.</p> */
				public void suradnicaY(double novéY) { polohaY(novéY); }

				/**
				 * <p><a class="getter"></a> Vráti aktuálne súradnice robota
				 * v objekte typu {@link Bod Bod}.
				 * Vrátený objekt bude obsahovať súradnice robota,
				 * ktoré sú aktuálne v čase volania metódy. V budúcnosti
				 * tieto hodnoty súradníc nie sú aktualizované.
				 * To znamená, že vždy keď potrebujete získať aktuálne
				 * súradnice robota, tak musíte znova volať túto metódu
				 * a získať nový objekt typu {@link Bod Bod} s aktuálnymi
				 * súradnicami.</p>
				 * 
				 * @return objekt typu {@link Bod Bod} obsahujúci aktuálne
				 *     súradnice robota
				 */
				public Bod poloha()
				{
					return new Bod(aktuálneX, aktuálneY);
				}

				/**
				 * <p><a class="setter"></a> Nastaví nové súradnice robota.
				 * Nové súradnice
				 * sú očakávané v inštancii triedy, ktorá implementuje
				 * rozhranie {@link Poloha Poloha}, takže môže ísť o rôzne
				 * objekty programovacieho rámca GRobot. Robot sa presunie
				 * na zadané súradnice, nekreslí pri tom čiaru, ani nezmení
				 * svoju aktuálnu orientáciu (smer).</p>
				 * 
				 * @param poloha objekt typu {@link Poloha Poloha}
				 *     obsahujúci nové súradnice robota
				 */
				public void poloha(Poloha poloha)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					aktuálneX = poloha.polohaX();
					aktuálneY = poloha.polohaY();

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
						else
							cesta.moveTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							skočNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}


				/**
				 * <p>Overí, či sa poloha tohto robota dokonale zhoduje so
				 * zadanými súradnicami. Ak je zistená zhoda, tak táto metóda
				 * vráti hodnotu {@code valtrue}, v opačnom prípade vráti
				 * hodnotu {@code valfalse}.</p>
				 * 
				 * @param x x-ová súradnica, s ktorou má byť porovnaná poloha
				 *     tohto robota
				 * @param y y-ová súradnica, s ktorou má byť porovnaná poloha
				 *     tohto robota
				 * @return {@code valtrue} ak sa poloha tohto robota zhoduje
				 *     so zadanými súradnicami, {@code valfalse} v opačnom
				 *     prípade
				 */
				public boolean jeNa(double x, double y)
				{
					return aktuálneX == x && aktuálneY == y;
				}

				/**
				 * <p>Overí, či sa poloha tohto robota a poloha zadaného
				 * objektu dokonale zhodujú. Ak je zistená zhoda, tak táto
				 * metóda vráti hodnotu {@code valtrue}, v opačnom prípade
				 * je vrátená hodnota {@code valfalse}.</p>
				 * 
				 * @param poloha objekt, ktorého poloha má byť porovnaná
				 *     s polohou tohto robota
				 * @return {@code valtrue} ak sa poloha tohto robota zhoduje
				 *     s polohou zadaného objektu, {@code valfalse}
				 *     v opačnom prípade
				 */
				public boolean jeNa(Poloha poloha)
				{
					if (poloha instanceof GRobot)
						return ((GRobot)poloha).aktuálneX == aktuálneX &&
							((GRobot)poloha).aktuálneY == aktuálneY;
					return poloha.polohaX() == aktuálneX &&
					poloha.polohaY() == aktuálneY;
				}


				/**
				 * <p><a class="getter"></a> Zistí aktuálny uhol (smer) robota.</p>
				 * 
				 * @return aktuálny uhol otočenia robota
				 * 
				 * @see #uhol(double)
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #uholDoma()
				 * @see #smer()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 */
				public double uhol() { return aktuálnyUhol; }

				/**
				 * <p><a class="getter"></a> Zistí aktuálny uhol (smer) robota.</p>
				 * 
				 * @return aktuálny uhol otočenia robota
				 * 
				 * @see #smer(double)
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #uhol()
				 * @see #smerDoma()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 */
				public double smer() { return aktuálnyUhol; }


				/**
				 * <p><a class="setter"></a> Nasmeruje robot podľa zadaného uhla.</p>
				 * 
				 * @param uhol uhol smeru robota (nula znamená vpravo,
				 *     deväťdesiat hore a tak ďalej)
				 * 
				 * @see #smer(double)
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #otočNa(double, double)
				 */
				public void uhol(double uhol)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol = uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/**
				 * <p><a class="setter"></a> Nasmeruje robot podľa zadaného uhla.</p>
				 * 
				 * @param uhol uhol smeru robota (nula znamená vpravo,
				 *     deväťdesiat hore a tak ďalej)
				 * 
				 * @see #uhol(double)
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #otočNa(double, double)
				 */
				public void smer(double uhol)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol = uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Nasmeruje (otočí) robot rovnakým smerom, ako určuje
				 * zadaný uhol. Má v podstate rovnaký efekt ako
				 * <a class="setter"></a> {@link #uhol(double) uhol} alebo
				 * <a class="setter"></a> {@link #smer(double) smer}. Jej
				 * implementácia je v súlade s dodržaním názvoslovia metód
				 * programovacieho rámca a jej použitie by mohlo byť
				 * napríklad nasledujúce:</p>
				 * 
				 * <pre CLASS="example">
					{@code currotoč}(inýRobot.{@link #smer() smer}());
					</pre>
				 * 
				 * <p>Táto metóda nemá verziu obmedzujúcu maximálny uhol
				 * pootočenia (ako napríklad: {@link #otoč(Smer, double)}),
				 * pretože by pri definícii nastal konflikt s metódou {@link 
				 * #otoč(double, double) otoč(Δx, Δy)}. Ak chcete obmedziť
				 * maximálny uhol pootočenia, použite metódu {@link #otoč(Smer,
				 * double)}, ktorú odporúčame použiť v každom prípade.</p>
				 * 
				 * @param uhol uhol smeru robota (nula znamená vpravo,
				 *     deväťdesiat hore a tak ďalej)
				 * 
				 * @see #smer(double)
				 * @see #uhol(double)
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #otočNa(double, double)
				 * @see #otoč(double, double)
				 * @see #otoč(double, double, double)
				 * @see #otočO(double)
				 */
				public void otoč(double uhol)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol = uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otoč(double) otoč}.</p> */
				public void otoc(double uhol) { otoč(uhol); }


				/**
				 * <p><a class="setter"></a> Nasmeruje robot podľa zadaného
				 * objektu.</p>
				 * 
				 * @param objekt objekt určujúci uhol smeru robota (nula
				 *     znamená vpravo, deväťdesiat hore a tak ďalej)
				 */
				public void uhol(Smer objekt)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol = objekt.uhol();
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/**
				 * <p><a class="setter"></a> Nasmeruje robot podľa zadaného
				 * objektu.</p>
				 * 
				 * @param objekt objekt určujúci uhol smeru robota (nula
				 *     znamená vpravo, deväťdesiat hore a tak ďalej)
				 */
				public void smer(Smer objekt)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol = objekt.uhol();
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}


				/**
				 * <p><a class="getter"></a> Zistí aktuálnu hodnotu otáčania
				 * robota pri použití bezparametrických verzií metód
				 * {@link #vpravo() vpravo}, {@link #vľavo() vľavo} a iných.</p>
				 * 
				 * @return aktuálny uhol pootočenia robota pri použití metód
				 *     {@link #vpravo() vpravo}{@code ()},
				 *     {@link #vľavo() vľavo}{@code ()} a iných
				 * 
				 * @see #uholOtáčania(double)
				 * @see #vpravo()
				 * @see #vľavo()
				 * @see #choďNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 */
				public double uholOtáčania()
				{
					return uholOtáčania;
				}

				/** <p><a class="alias"></a> Alias pre {@link #uholOtáčania() uholOtáčania}.</p> */
				public double uholOtacania() { return uholOtáčania(); }

				/**
				 * <p><a class="setter"></a> Zmení hodnotu otáčania robota pri
				 * použití bezparametrických verzií metód
				 * {@link #vpravo() vpravo}, {@link #vľavo() vľavo} a iných.</p>
				 * 
				 * @param uhol nový uhol pootočenia robota pre metódy
				 *     {@link #vpravo() vpravo}{@code ()},
				 *     {@link #vľavo() vľavo}{@code ()} iných
				 * 
				 * @see #uholOtáčania()
				 * @see #vpravo()
				 * @see #vľavo()
				 * @see #choďNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 */
				public void uholOtáčania(double uhol)
				{
					uholOtáčania = uhol % 360;
					if (uholOtáčania < -180) uholOtáčania += 360;
					if (uholOtáčania > 180) uholOtáčania -= 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #uholOtáčania(double) uholOtáčania}.</p> */
				public void uholOtacania(double uhol) { uholOtáčania(uhol); }


				/**
				 * <p><a class="getter"></a> Vráti aktuálnu hodnotu pootočenia
				 * tvaru robota. Ďalšie informácie o pootočení tvaru sú
				 * v opise metódy {@link #pootočenieTvaru(double)
				 * pootočenieTvaru(pootočenie)}.</p>
				 * 
				 * @return hodnota pootočenia tvaru robota
				 * 
				 * @see #pootočenieTvaru(double)
				 * @see #otáčanieTvaru()
				 * @see #otáčajTvar(double)
				 * @see #pootočenieTvaruDoma()
				 * @see #pootočenieTvaruDoma(Double)
				 */
				public double pootočenieTvaru() { return pootočenieTvaru; }

				/** <p><a class="alias"></a> Alias pre {@link #pootočenieTvaru() pootočenieTvaru}.</p> */
				public double pootocenieTvaru() { return pootočenieTvaru; }

				/**
				 * <p><a class="setter"></a> Nastaví pootočenie tvaru robota podľa
				 * zadanej hodnoty. Pootočenie tvaru je uhol, o ktorý je
				 * pootočené kreslenie tvaru robota voči jeho skutočnému smeru
				 * (smeru, v ktorom sa pohybuje). Pri
				 * {@linkplain KreslenieTvaru#kresli(GRobot) kreslení
				 * vlastného tvaru robota} je hodnota aktuálneho uhla
				 * pozmenená o túto hodnotu.</p>
				 * 
				 * @param pootočenie nová hodnota pootočenia tvaru robota
				 * 
				 * @see #pootočenieTvaru()
				 * @see #otáčanieTvaru()
				 * @see #otáčajTvar(double)
				 * @see #pootočenieTvaruDoma()
				 * @see #pootočenieTvaruDoma(Double)
				 */
				public void pootočenieTvaru(double pootočenie)
				{
					pootočenieTvaru = pootočenie % 360;
					if (pootočenieTvaru < 0) pootočenieTvaru += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #pootočenieTvaru(double) pootočenieTvaru}.</p> */
				public void pootocenieTvaru(double pootočenie)
				{ pootočenieTvaru(pootočenie); }

				/**
				 * <p>Zistí aktuálnu hodnotu rovnomerného otáčania tvaru robota.</p>
				 * 
				 * @return hodnota rovnomerného otáčania tvaru robota
				 * 
				 * @see #pootočenieTvaru()
				 * @see #pootočenieTvaru(double)
				 * @see #otáčajTvar(double)
				 * @see #pootočenieTvaruDoma()
				 * @see #pootočenieTvaruDoma(Double)
				 */
				public double otáčanieTvaru() { return otáčanieTvaru; }

				/** <p><a class="alias"></a> Alias pre {@link #otáčanieTvaru() otáčanieTvaru}.</p> */
				public double otacanieTvaru() { return otáčanieTvaru; }

				/**
				 * <p><a class="setter"></a> Nastaví novú hodnotu rovnomerného
				 * otáčania tvaru robota a aktivuje robot ak je to potrebné.</p>
				 * 
				 * @param otáčanie nová hodnota rovnomerného otáčania tvaru
				 *     robota
				 * 
				 * @see #pootočenieTvaru()
				 * @see #pootočenieTvaru(double)
				 * @see #otáčanieTvaru()
				 */
				public void otáčajTvar(double otáčanie)
				{ otáčajTvar(otáčanie, true); }

				/** <p><a class="alias"></a> Alias pre {@link #otáčajTvar(double) otáčajTvar}.</p> */
				public void otacajTvar(double otáčanie)
				{ otáčajTvar(otáčanie, true); }

				/**
				 * <p><a class="setter"></a> Nastaví novú hodnotu rovnomerného
				 * otáčania tvaru robota.</p>
				 * 
				 * @param otáčanie nová hodnota rovnomerného otáčania tvaru
				 *     robota
				 * @param aktivuj určí, či sa má robot zároveň aktivovať
				 * 
				 * @see #pootočenieTvaru()
				 * @see #pootočenieTvaru(double)
				 * @see #otáčanieTvaru()
				 */
				public void otáčajTvar(double otáčanie, boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						otáčanieTvaru = otáčanie % 360;
						if (otáčanieTvaru < 0) otáčanieTvaru += 360;
					}

					if (aktivuj && otáčanieTvaru != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otáčajTvar(double, boolean) otáčajTvar}.</p> */
				public void otacajTvar(double otáčanie, boolean aktivuj)
				{ otáčajTvar(otáčanie, aktivuj); }


				/**
				 * <p>Zistí aktuálny stav gyroskopického vyvažovania. Ak je
				 * vyvažovanie vypnuté, tak metóda vráti hodnotu
				 * {@code valnull}.</p>
				 * 
				 * @return aktuálna hodnota gyroskopického vyvažovania, alebo
				 *     {@code valnull} ak je vyvažovanie vypnuté
				 * 
				 * @see #gyroskop(Double)
				 * @see #vypniGyroskop()
				 */
				public Double gyroskop() { return gyroskop; }

				/**
				 * <p>Nastaví novú hodnotu gyroskopického vyvažovania. Táto
				 * aktivita spôsobí automatické prepočítavanie {@linkplain 
				 * #pootočenieTvaru(double) pootočenia tvaru} tak, aby
				 * výsledný uhol na zobrazenie zodpovedal hodnote gyroskopu.
				 * Ak je súčasne zapnuté automatické {@linkplain 
				 * #otáčajTvar(double, boolean) otáčanie tvaru} aj
				 * gyroskopické vyvažovanie, tak dôjde k automatickému
				 * prepočítavaniu gyroskopického vyvažovania podľa hodnoty
				 * otáčania tvaru.</p>
				 * 
				 * @param hodnota nová hodnota gyroskopického vyvažovania,
				 *     alebo {@code valnull} ak má byť vyvažovanie vypnuté
				 * 
				 * @see #gyroskop()
				 * @see #vypniGyroskop()
				 */
				public void gyroskop(Double hodnota)
				{
					if (null == hodnota)
					{
						gyroskop = hodnota;
					}
					else
					{
						gyroskop = hodnota % 360;
						if (gyroskop < 0) gyroskop += 360;
					}
				}

				/**
				 * <p>Vypne gyroskopické vyvažovanie kreslenia tvaru.</p>
				 * 
				 * @see #gyroskop()
				 * @see #gyroskop(Double)
				 */
				public void vypniGyroskop() { gyroskop = null; }

				// Toto je definované inde:
				// public void otoč(Smer objekt)


				/**
				 * <p>Umiestni robot na náhodnú pozíciu na aktívnom plátne
				 * alebo obrázku. To znamená, že náhodné súradnice sú
				 * vygenerované podľa toho, či robot kreslí na podlahu,
				 * strop alebo obrázok s inými rozmermi. Na výslednú polohu
				 * má vplyv aj {@linkplain #ohranič(double, double,
				 * double, double, int) definícia ohraničenia}.</p>
				 */
				public void náhodnáPoloha()
				{
					if (obrázokAktívnehoPlátna == podlaha.obrázokPlátna ||
						obrázokAktívnehoPlátna == strop.obrázokPlátna)
					{
						skočNa(
							Svet.náhodnéCeléČíslo(
								(long)Svet.najmenšieX(),
								(long)Svet.najväčšieX()),
							Svet.náhodnéCeléČíslo(
								(long)Svet.najmenšieY(),
								(long)Svet.najväčšieY()));
					}
					else if (obrázokAktívnehoPlátna instanceof Obrázok)
					{
						Obrázok obrázok = (Obrázok)obrázokAktívnehoPlátna;
						skočNa(
							Svet.náhodnéCeléČíslo(
								(long)obrázok.najmenšieX(),
								(long)obrázok.najväčšieX()),
							Svet.náhodnéCeléČíslo(
								(long)obrázok.najmenšieY(),
								(long)obrázok.najväčšieY()));
					}
					else
					{
						int šírka = obrázokAktívnehoPlátna.getWidth();
						int výška = obrázokAktívnehoPlátna.getHeight();
						double najmenšieX = -šírka / 2;
						double najmenšieY = -(výška - 1) / 2;
						double najväčšieX = (šírka - 1) / 2;
						double najväčšieY = výška / 2;
						skočNa(
							Svet.náhodnéCeléČíslo(
								(long)najmenšieX, (long)najväčšieX),
							Svet.náhodnéCeléČíslo(
								(long)najmenšieY, (long)najväčšieY));
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnáPoloha() náhodnáPoloha}.</p> */
				public void nahodnaPoloha() { náhodnáPoloha(); }

				/** <p><a class="alias"></a> Alias pre {@link #náhodnáPoloha() náhodnáPoloha}.</p> */
				public void náhodnáPozícia() { náhodnáPoloha(); }

				/** <p><a class="alias"></a> Alias pre {@link #náhodnáPoloha() náhodnáPoloha}.</p> */
				public void nahodnaPozicia() { náhodnáPoloha(); }

				/**
				 * <p>Otočí robot náhodným smerom.</p>
				 */
				public void náhodnýSmer()
				{
					smer(Svet.náhodnéCeléČíslo(0, 360));
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnýSmer() náhodnýSmer}.</p> */
				public void nahodnySmer() { náhodnýSmer(); }

				/** <p><a class="alias"></a> Alias pre {@link #náhodnýSmer() náhodnýSmer}.</p> */
				public void náhodnýUhol() { náhodnýSmer(); }

				/** <p><a class="alias"></a> Alias pre {@link #náhodnýSmer() náhodnýSmer}.</p> */
				public void nahodnyUhol() { náhodnýSmer(); }


				/**
				 * <p>Zmení farbu robota na náhodnú. Farby sú vybrané
				 * z {@linkplain Farebnosť#preddefinovanéFarby preddefinovanej
				 * množiny farieb}.</p>
				 */
				public void náhodnáFarba()
				{
					farba(preddefinovanéFarby[(int)Svet.
						náhodnéCeléČíslo(0, preddefinovanéFarby.
							length - 1)]);
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnáFarba() náhodnáFarba}.</p> */
				public void nahodnaFarba() { náhodnáFarba(); }


				/**
				 * <p>Zmení veľkosť robota na náhodnú hodnotu v rozmedzí
				 * veľkosti, ktorú by mal pri hodnote mierky {@code num1.0}
				 * a násobkom tejto hodnoty o zadanú mieru.</p>
				 * 
				 * @param miera miera zmeny veľkosti v porovnaní s takou
				 *     hodnotou veľkosti, ktorú by mal robot pri hodnote
				 *     mierky {@code num1.0}
				 */
				public void náhodnáVeľkosť(double miera)
				{
					veľkosť = Svet.náhodnéCeléČíslo((long)pôvodnáVeľkosť,
						(long)(pôvodnáVeľkosť * miera));
					if (viditeľný) Svet.automatickéPrekreslenie();
					// veľkosť = pôvodnáVeľkosť + (Svet.generátor.nextDouble() *
					// 	(Svet.pôvodnáVeľkosť * (miera - 1.0)));
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnáVeľkosť(double miera) náhodnáVeľkosť}.</p> */
				public void nahodnaVelkost(double miera)
				{ náhodnáVeľkosť(miera); }

				// TODO – otestuj!!

				/**
				 * <p>Zmení pomer veľkosti robota na náhodnú hodnotu
				 * v rozmedzí pomeru veľkosti, ktorú by mal pri hodnote
				 * mierky pomeru {@code num1.0} a násobkom tejto hodnoty
				 * o zadanú mieru.</p>
				 * 
				 * @param miera miera zmeny pomeru veľkosti v porovnaní
				 *     s takou hodnotou pomeru veľkosti, ktorú by mal robot
				 *     pri hodnote mierky pomeru {@code num1.0}
				 */
				public void náhodnýPomer(double miera)
				{
					pomerVeľkosti = Svet.náhodnéCeléČíslo((long)pôvodnýPomer,
						(long)(pôvodnýPomer * miera));
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnýPomer(double miera) náhodnýPomer}.</p> */
				public void nahodnyPomer(double miera) { náhodnýPomer(miera); }

				/**
				 * <p>Zmení rozmer robota na náhodnú hodnotu v rozmedzí
				 * veľkosti a pomeru veľkosti, ktoré by mal pri hodnotách
				 * mierok veľkosti a pomeru veľkosti {@code num1.0}
				 * a násobkov týchto hodnôt o zadanú mieru.</p>
				 * 
				 * @param miera miera zmeny rozmeru veľkosti v porovnaní
				 *     s takou hodnotou rozmeru veľkosti, ktorú by mal robot
				 *     pri hodnote mierky rozmeru {@code num1.0}
				 */
				public void náhodnýRozmer(double miera)
				{
					veľkosť = Svet.náhodnéCeléČíslo((long)pôvodnáVeľkosť,
						(long)(pôvodnáVeľkosť * miera));
					pomerVeľkosti = Svet.náhodnéCeléČíslo((long)pôvodnýPomer,
						(long)(pôvodnýPomer * miera));
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnýRozmer(double miera) náhodnýRozmer}.</p> */
				public void nahodnyRozmer(double miera) { náhodnýRozmer(miera); }

				/**
				 * <p>Zmení rozmer robota na náhodnú hodnotu v rozmedzí
				 * veľkosti a pomeru veľkosti, ktoré by mal pri hodnotách
				 * mierok veľkosti a pomeru veľkosti {@code num1.0}
				 * a násobkov týchto hodnôt o zadané miery prislúchajúcich
				 * údajov.</p>
				 * 
				 * @param mieraVeľkosti miera zmeny veľkosti v porovnaní
				 *     s takou hodnotou veľkosti, ktorú by mal robot pri
				 *     hodnote mierky {@code num1.0}
				 * @param mieraPomeru miera zmeny pomeru veľkosti v porovnaní
				 *     s takou hodnotou pomeru veľkosti, ktorú by mal robot
				 *     pri hodnote mierky pomeru {@code num1.0}
				 */
				public void náhodnýRozmer(double mieraVeľkosti,
					double mieraPomeru)
				{
					veľkosť = Svet.náhodnéCeléČíslo((long)pôvodnáVeľkosť,
						(long)(pôvodnáVeľkosť * mieraVeľkosti));
					pomerVeľkosti = Svet.náhodnéCeléČíslo((long)pôvodnýPomer,
						(long)(pôvodnýPomer * mieraPomeru));
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #náhodnýRozmer(double mieraVeľkosti, double mieraPomeru) náhodnýRozmer}.</p> */
				public void nahodnyRozmer(double mieraVeľkosti,
					double mieraPomeru)
				{ náhodnýRozmer(mieraVeľkosti, mieraPomeru); }


				/**
				 * <p>Zistí poslednú x-ovú súradnicu robota. Táto hodnota sa
				 * automaticky zálohuje pri každej zmene a nedá sa nastaviť
				 * ručne.</p>
				 * 
				 * @return posledná x-ová súradnica robota
				 * 
				 * @see #polohaX()
				 * @see #poslednáPolohaY()
				 * @see #poslednáPoloha()
				 */
				public double poslednáPolohaX() { return poslednéX; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednáPolohaX() poslednáPolohaX}.</p> */
				public double poslednaPolohaX() { return poslednéX; }

				/**
				 * <p>Zistí poslednú y-ovú súradnicu robota. Táto hodnota sa
				 * automaticky zálohuje pri každej zmene a nedá sa nastaviť
				 * ručne.</p>
				 * 
				 * @return posledná y-ová súradnica robota
				 * 
				 * @see #polohaY()
				 * @see #poslednáPolohaX()
				 * @see #poslednáPoloha()
				 */
				public double poslednáPolohaY() { return poslednéY; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednáPolohaY() poslednáPolohaY}.</p> */
				public double poslednaPolohaY() { return poslednéY; }


				/** <p><a class="alias"></a> Alias pre {@link #poslednáPolohaX() poslednáPolohaX}.</p> */
				public double poslednáSúradnicaX() { return poslednéX; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednáSúradnicaX() poslednáSúradnicaX}.</p> */
				public double poslednaSuradnicaX() { return poslednéX; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednáPolohaY() poslednáPolohaY}.</p> */
				public double poslednáSúradnicaY() { return poslednéY; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednáSúradnicaY() poslednáSúradnicaY}.</p> */
				public double poslednaSuradnicaY() { return poslednéY; }



				/**
				 * <p>Vráti posledné súradnice robota v objekte typu
				 * {@link Bod Bod}. Vrátený objekt bude obsahovať posledné
				 * (zálohované) súradnice robota. Poloha tohto bodu nie je
				 * ďalej aktualizovaná podľa novších záloh polohy robota.
				 * To znamená, že vždy keď potrebujete získať posledné
				 * súradnice robota, tak musíte znova volať túto metódu
				 * a získať nový objekt typu {@link Bod Bod} s poslednými
				 * súradnicami.</p>
				 * 
				 * @return objekt typu {@link Bod Bod} obsahujúci posledné
				 *     súradnice robota
				 * 
				 * @see #poloha()
				 * @see #poslednáPolohaX()
				 * @see #poslednáPolohaY()
				 * @see #poslednáPoloha()
				 */
				public Bod poslednáPoloha()
				{
					return new Bod(poslednéX, poslednéY);
				}

				/** <p><a class="alias"></a> Alias pre {@link #poslednáPoloha() poslednáPoloha}.</p> */
				public Bod poslednaPoloha() { return poslednáPoloha(); }


				/**
				 * <p>Zistí posledný uhol (smer) robota.</p>
				 * 
				 * @return posledný uhol otočenia robota
				 * 
				 * @see #uhol()
				 * @see #poslednýSmer()
				 */
				public double poslednýUhol() { return poslednýUhol; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednýUhol() poslednýUhol}.</p> */
				public double poslednyUhol() { return poslednýUhol; }

				/**
				 * <p>Zistí posledný uhol (smer) robota.</p>
				 * 
				 * @return posledný uhol otočenia robota
				 * 
				 * @see #uhol()
				 * @see #poslednýUhol()
				 */
				public double poslednýSmer() { return poslednýUhol; }

				/** <p><a class="alias"></a> Alias pre {@link #poslednýSmer() poslednýSmer}.</p> */
				public double poslednySmer() { return poslednýUhol; }


			// Domov

				/**
				 * <p>Presunie robot „domov“ – na štartovaciu pozíciu
				 * a obráti ho predvoleným smerom. Akcia presunu robota
				 * domov môže ovplyvňovať aj iné vlastnosti robota.
				 * Napríklad metódy {@link #zdvihniPeroDoma()
				 * zdvihniPeroDoma}, {@link #položPeroDoma()
				 * položPeroDoma}, {@link #zobrazDoma() zobrazDoma}
				 * a {@link #skryDoma() skryDoma} určujú, že pri presune
				 * domov sa má zdvihnúť/&#8203;položiť pero alebo
				 * skryť/&#8203;zobraziť robot. Ďalej sú do úvahy
				 * brané aj ďalšie nastaviteľné informácie: domovská
				 * {@linkplain #farbaDoma(Color) farba}, {@linkplain 
				 * #veľkosťDoma(Double) veľkosť}, {@linkplain 
				 * #pomerDoma(Double) pomer} a {@linkplain 
				 * #hrúbkaČiaryDoma(Double) hrúbka čiary}.</p>
				 * 
				 * <p>Použitie tejto metódy a všetkých jej „klonov“ má za
				 * následok vymazanie pôsobiska – pozri opisy metód
				 * {@link #vymažPôsobisko() vymažPôsobisko}
				 * a {@link #kresliPôsobisko() kresliPôsobisko}.</p>
				 * 
				 * <p class="attention"><b>Upozornenie:</b> Všetky „klony“
				 * metód, ktoré slúžia na návrat na domovskú pozíciu robota
				 * ignorujú v metódach kreslenia vlastného tvaru robota
				 * ({@link KreslenieTvaru#kresli(GRobot) kresli}
				 * a {@link #kresliTvar() kresliTvar}) skutočnú domovskú
				 * polohu a smer robota a pracujú výhradne s údajmi jeho
				 * polohy a smeru, ktoré boli platné pred začatím kreslenia
				 * vlastného tvaru. To zároveň znamená, že žiadne ďalšie
				 * vlastnosti nie sú počas kreslenia vlastného tvaru
				 * pri návrate na domovskú pozíciu ovplyvňované, ani pôsobisko
				 * nie je v tejto situácii vymazané.
				 * Preto je možné metódy návratu na domovskú pozíciu robota
				 * využívať v rámci metód kreslenia vlastných tvarov robota
				 * na rýchly návrat a otočenie grafického robota na aktuálnu
				 * pozíciu a smer (v zmysle pozície a smeru platných pred
				 * začatím kreslenia vlastného tvaru).</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ovplyvňuje
				 * príkaz {@link #domov() domov} tri vlastnosti:
				 * {@linkplain #poloha() polohu}, {@linkplain #smer() smer},
				 * a {@linkplain #pootočenieTvaru() pootočenieTvaru}.</p>
				 * 
				 * @see #vymažPôsobisko()
				 * @see #kresliPôsobisko()
				 * @see #domov(double)
				 * @see #domov(Smer)
				 * @see #domov(double, double)
				 * @see #domov(double, double, double)
				 * @see #domov(double, double, Smer)
				 * @see #domov(Poloha)
				 * @see #domov(Poloha, double)
				 * @see #domov(Poloha, Smer)
				 * @see #domov(Častica)
				 * @see #domov(GRobot)
				 */
				public void domov()
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX;
					aktuálneY = domaY;
					aktuálnyUhol = uholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví nový štartovací smer.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru je nový štartovací smer platný len do skončenia
				 * kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param novýUholDoma nový domovský smer robota
				 */
				public void domov(double novýUholDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX;
					aktuálneY = domaY;
					novýUholDoma %= 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví nový štartovací smer.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru je nový štartovací smer platný len do skončenia
				 * kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param novýSmerDoma objekt určujúci nový domovský
				 *     smer robota
				 */
				public void domov(Smer novýSmerDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX;
					aktuálneY = domaY;
					double novýUholDoma = novýSmerDoma.uhol() % 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví novú štartovaciu pozíciu.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru je nová štartovacia pozícia platná len do skončenia
				 * kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param novéXDoma nová x-ová súradnica domovskej pozície
				 * @param novéYDoma nová y-ová súradnica domovskej pozície
				 */
				public void domov(double novéXDoma, double novéYDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = novéXDoma;
					aktuálneY = domaY = novéYDoma;
					aktuálnyUhol = uholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví novú štartovaciu pozíciu a smer.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru sú nový štartovací smer a pozícia platné len do
				 * skončenia kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param novéXDoma nová x-ová súradnica domovskej pozície
				 * @param novéYDoma nová y-ová súradnica domovskej pozície
				 * @param novýUholDoma nový domovský smer robota
				 */
				public void domov(double novéXDoma, double novéYDoma,
					double novýUholDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = novéXDoma;
					aktuálneY = domaY = novéYDoma;
					novýUholDoma %= 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví novú štartovaciu pozíciu a smer.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru sú nový štartovací smer a pozícia platné len do
				 * skončenia kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param novéXDoma nová x-ová súradnica domovskej pozície
				 * @param novéYDoma nová y-ová súradnica domovskej pozície
				 * @param novýSmerDoma objekt určujúci nový domovský
				 *     smer robota
				 */
				public void domov(double novéXDoma, double novéYDoma,
					Smer novýSmerDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = novéXDoma;
					aktuálneY = domaY = novéYDoma;
					double novýUholDoma = novýSmerDoma.uhol() % 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom,
				 * že robotu nastaví novú štartovaciu pozíciu.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru je nová štartovacia pozícia platná len do skončenia
				 * kreslenia vlastného tvaru. (Pozri aj informácie pri metóde
				 * {@link #domov() domov()}.)</p>
				 * 
				 * @param nováPolohaDoma bod určujúci nové súradnice
				 *     domovskej pozície v súradnicovom priestore rámca
				 */
				public void domov(Poloha nováPolohaDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = nováPolohaDoma.polohaX();
					aktuálneY = domaY = nováPolohaDoma.polohaY();
					aktuálnyUhol = uholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví novú štartovaciu pozíciu a smer.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru sú nový štartovací smer a pozícia platné len do
				 * skončenia kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param nováPolohaDoma objekt určujúci nové súradnice
				 *     domovskej pozície v súradnicovom priestore rámca
				 * @param novýUholDoma nový domovský smer robota
				 */
				public void domov(Poloha nováPolohaDoma, double novýUholDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = nováPolohaDoma.polohaX();
					aktuálneY = domaY = nováPolohaDoma.polohaY();
					novýUholDoma %= 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom, že
				 * robotu nastaví novú štartovaciu pozíciu a smer.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia vlastného
				 * tvaru sú nový štartovací smer a pozícia platné len do
				 * skončenia kreslenia vlastného tvaru.
				 * (Pozri aj informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * @param nováPolohaDoma objekt určujúci nové súradnice
				 *     domovskej pozície v súradnicovom priestore rámca
				 * @param novýSmerDoma objekt určujúci nový smer domovskej
				 *     pozície robota
				 */
				public void domov(Poloha nováPolohaDoma, Smer novýSmerDoma)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = nováPolohaDoma.polohaX();
					aktuálneY = domaY = nováPolohaDoma.polohaY();
					double novýUholDoma = novýSmerDoma.uhol() % 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Presne ako {@link #domov() domov}, len s tým rozdielom,
				 * že robotu nastaví novú štartovaciu pozíciu, smer
				 * a rozmer (resp. domovskú veľkosť a domovský pomer veľkosti
				 * robota).</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Počas kreslenia
				 * vlastného tvaru sú nový štartovací smer a pozícia platné
				 * len do skončenia kreslenia vlastného tvaru. (Pozri aj
				 * informácie pri metóde {@link #domov() domov()}.)</p>
				 * 
				 * <!--p class="remark"><b>Poznámka:</b> {@linkplain Častica
				 * Častica} a robot majú ešte jednu spoločnú vlastnosť –
				 * {@linkplain #rozmery(double, double) rozmery.} Táto
				 * vlastnosť nie je touto metódou braná do úvahy.
				 * V skutočnosti sú rozmery triedy {@link GRobot GRobot} iba
				 * „tieňovou“ vlastnosťou – sú prepočítavané podľa vlastností
				 * {@linkplain #veľkosť() veľkosti}
				 * a {@linkplain #pomer() pomeru.}</p-->
				 * 
				 * <p class="remark"><b>Poznámka:</b> V súvislosti
				 * s vlastnosťou rozmeru venujte pozornosť upozorneniu
				 * v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}. To znamená, že volanie
				 * tejto metódy zmení nastavenia {@linkplain 
				 * #veľkosťDoma(Double) veľkosti doma} a {@linkplain 
				 * #pomerDoma(Double) pomeru veľkosti doma.}</p>
				 * 
				 * @param častica častica určujúca nové súradnice
				 *     domovskej pozície (v súradnicovom priestore rámca)
				 *     a nový smer robota
				 */
				public void domov(Častica častica)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = častica.polohaX();
					aktuálneY = domaY = častica.polohaY();
					double novýUholDoma = častica.uhol() % 360;
					if (novýUholDoma < 0) novýUholDoma += 360;
					aktuálnyUhol = uholDoma = novýUholDoma;
					if (kreslímVlastnýTvar) return;

					veľkosť = veľkosťDoma = častica.výška() / 2.0;
					if (0 == veľkosť) pomerVeľkosti = 0;
					else pomerVeľkosti = pomerDoma =
						(častica.šírka() / 2.0) / veľkosť;

					vymažPôsobisko();
					zrušCestu();
					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					/* if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma); */
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}

				/**
				 * <p>Prevezme všetky parametre domovskej pozície od zadaného
				 * robota a zároveň ich aplikuje. Dotýka sa to domovskej
				 * pozície, smeru, veľkosti, viditeľnosti a farby robota
				 * a hrúbky a polohy pera pri prechode na domovskú pozíciu.</p>
				 * 
				 * <div class="remark"><p><b>Poznámka:</b> Počas kreslenia
				 * vlastného tvaru platí, že:</p>
				 * <ol>
				 * <li>od iného robota nie sú prevzaté žiadne údaje o jeho
				 * veľkosti, viditeľnosti a farbe, ani o veľkosti a polohe
				 * pera;</li>
				 * <li>nový štartovací smer a pozícia sú platné len do
				 * skončenia kreslenia vlastného tvaru.</li>
				 * </ol>
				 * <p>Pozri aj informácie pri metóde {@link #domov()
				 * domov()}.</p>
				 * </div>
				 * 
				 * @param iný iný robot
				 */
				public void domov(GRobot iný)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					aktuálneX = domaX = iný.domaX;
					aktuálneY = domaY = iný.domaY;
					aktuálnyUhol = uholDoma = iný.uholDoma;
					if (kreslímVlastnýTvar) return;

					// Ostatné veci sa nemenia ak práve kreslím vlastný tvar
					vymažPôsobisko();
					zrušCestu();
					peroPoloženéDoma = iný.viditeľnýDoma;
					viditeľnýDoma = iný.viditeľnýDoma;
					polomerPeraDoma = iný.polomerPeraDoma;
					veľkosťDoma = iný.veľkosťDoma;
					pomerDoma = iný.pomerDoma;
					priehľadnosťDoma = iný.priehľadnosťDoma;
					písmoDoma = iný.písmoDoma;
					pootočenieTvaruDoma = iný.pootočenieTvaruDoma;

					farbaDoma = iný.farbaDoma;
					cieľováFarbaDoma = iný.cieľováFarbaDoma;
					zrušCieľovúFarbuDoma = iný.zrušCieľovúFarbuDoma;

					if (null != peroPoloženéDoma)
						peroPoložené = peroPoloženéDoma.booleanValue();
					if (null != viditeľnýDoma)
					{
						if (viditeľný != viditeľnýDoma.booleanValue())
						{
							viditeľný = viditeľnýDoma.booleanValue();
							if (viditeľný) zobrazenie();
							else skrytie();
						}
					}
					if (null != farbaDoma)
						farbaRobota = farbaDoma;
					if (zrušCieľovúFarbuDoma)
						cieľováFarba = null;
					else if (null != cieľováFarbaDoma)
						cieľováFarba = cieľováFarbaDoma;
					if (null != polomerPeraDoma)
						hrúbkaČiary(polomerPeraDoma);
					if (null != veľkosťDoma)
						veľkosť(veľkosťDoma);
					if (null != pomerDoma)
						pomer(pomerDoma);
					if (null != priehľadnosťDoma)
						priehľadnosť(priehľadnosťDoma);
					if (null != písmoDoma)
						písmo(písmoDoma);
					if (null != pootočenieTvaruDoma)
						pootočenieTvaru(pootočenieTvaruDoma);

					// Kontrola ohraničenia
					if (vyriešOhraničenie())
					{
						registrujPretočOhraničenie(null);
						while (doriešOhraničenie());
					}

					if (viditeľný || (null != viditeľnýDoma))
						Svet.automatickéPrekreslenie();
				}


				/**
				 * <p>Zapamätá si aktuálnu pozíciu a smer ako nový domov.</p>
				 */
				public void novýDomov()
				{
					domaX = aktuálneX;
					domaY = aktuálneY;
					uholDoma = aktuálnyUhol;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov() novýDomov}.</p> */
				public void novyDomov() { novýDomov(); }

				/**
				 * <p>Nastaví robotu nový domovský smer.</p>
				 * 
				 * @param novýUholDoma nový domovský smer robota
				 */
				public void novýDomov(double novýUholDoma)
				{
					uholDoma = novýUholDoma;
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(double) novýDomov}.</p> */
				public void novyDomov(double novýUholDoma)
				{ novýDomov(novýUholDoma); }

				/**
				 * <p>Nastaví robotu nový domovský smer.</p>
				 * 
				 * @param novýSmerDoma nový domovský smer robota
				 */
				public void novýDomov(Smer novýSmerDoma)
				{
					uholDoma = novýSmerDoma.uhol();
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(Smer) novýDomov}.</p> */
				public void novyDomov(Smer novýSmerDoma) { novýDomov(novýSmerDoma); }

				/**
				 * <p>Nastaví robotu novú domovskú pozíciu.</p>
				 * 
				 * @param novéXDoma nová x-ová súradnica domovskej pozície
				 * @param novéYDoma nová y-ová súradnica domovskej pozície
				 */
				public void novýDomov(double novéXDoma, double novéYDoma)
				{
					domaX = novéXDoma;
					domaY = novéYDoma;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(double, double) novýDomov}.</p> */
				public void novyDomov(double novéXDoma, double novéYDoma)
				{ novýDomov(novéXDoma, novéYDoma); }

				/**
				 * <p>Nastaví robotu novú domovskú pozíciu a smer.</p>
				 * 
				 * @param novéXDoma nová x-ová súradnica domovskej pozície
				 * @param novéYDoma nová y-ová súradnica domovskej pozície
				 * @param novýUholDoma nový domovský smer robota
				 */
				public void novýDomov(double novéXDoma, double novéYDoma,
					double novýUholDoma)
				{
					domaX = novéXDoma;
					domaY = novéYDoma;
					uholDoma = novýUholDoma;
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(double, double, double) novýDomov}.</p> */
				public void novyDomov(double novéXDoma, double novéYDoma,
					double novýUholDoma)
				{ novýDomov(novéXDoma, novéYDoma, novýUholDoma); }

				/**
				 * <p>Nastaví robotu novú domovskú pozíciu a smer.</p>
				 * 
				 * @param novéXDoma nová x-ová súradnica domovskej pozície
				 * @param novéYDoma nová y-ová súradnica domovskej pozície
				 * @param novýSmerDoma nový domovský smer robota
				 */
				public void novýDomov(double novéXDoma, double novéYDoma,
					Smer novýSmerDoma)
				{
					domaX = novéXDoma;
					domaY = novéYDoma;
					uholDoma = novýSmerDoma.uhol();
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(double, double, Smer) novýDomov}.</p> */
				public void novyDomov(double novéXDoma, double novéYDoma,
					Smer novýSmerDoma)
				{ novýDomov(novéXDoma, novéYDoma, novýSmerDoma); }

				/**
				 * <p>Nastaví robotu novú domovskú pozíciu.</p>
				 * 
				 * @param nováPolohaDoma nová domovská pozícia
				 *     (v súradnicovom priestore rámca)
				 */
				public void novýDomov(Poloha nováPolohaDoma)
				{
					domaX = nováPolohaDoma.polohaX();
					domaY = nováPolohaDoma.polohaY();
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(Poloha) novýDomov}.</p> */
				public void novyDomov(Poloha nováPolohaDoma)
				{ novýDomov(nováPolohaDoma); }

				/**
				 * <p>Nastaví robotu novú domovskú pozíciu a smer.</p>
				 * 
				 * @param nováPolohaDoma nová domovská pozícia
				 *     (v súradnicovom priestore rámca)
				 * @param novýUholDoma nový domovský smer robota
				 */
				public void novýDomov(Poloha nováPolohaDoma,
					double novýUholDoma)
				{
					domaX = nováPolohaDoma.polohaX();
					domaY = nováPolohaDoma.polohaY();
					uholDoma = novýUholDoma;
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(Poloha, double) novýDomov}.</p> */
				public void novyDomov(Poloha nováPolohaDoma,
					double novýUholDoma)
				{ novýDomov(nováPolohaDoma, novýUholDoma); }

				/**
				 * <p>Nastaví robotu novú domovskú pozíciu a smer.</p>
				 * 
				 * @param nováPolohaDoma nová domovská pozícia
				 *     (v súradnicovom priestore rámca)
				 * @param novýSmerDoma nový domovský smer robota
				 */
				public void novýDomov(Poloha nováPolohaDoma,
					Smer novýSmerDoma)
				{
					domaX = nováPolohaDoma.polohaX();
					domaY = nováPolohaDoma.polohaY();
					uholDoma = novýSmerDoma.uhol();
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(Poloha, Smer) novýDomov}.</p> */
				public void novyDomov(Poloha nováPolohaDoma,
					Smer novýSmerDoma)
				{ novýDomov(nováPolohaDoma, novýSmerDoma); }


				// novýDomov(Poloha) – nemali by sa miešať metódy prijímajúce
				// argument typu GRobot a Poloha, lebo by mohlo dochádzať ku
				// kompilačným chybám typu “ambiguous method call”…

				/**
				 * <p>Nastaví domovskú polohu a smer robota podľa polohy
				 * a smeru zadanej častice.</p>
				 * 
				 * @param častica častica, ktorej poloha a smer určia
				 *     domovskú polohu a smer pre tento robot
				 */
				public void novýDomov(Častica častica)
				{
					domaX = častica.polohaX();
					domaY = častica.polohaY();
					uholDoma = častica.uhol();
					uholDoma %= 360;
					if (uholDoma < 0) uholDoma += 360;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(Častica) novýDomov}.</p> */
				public void novyDomov(Častica častica) { novýDomov(častica); }

				/**
				 * <p>Prevezme všetky parametre domovskej pozície od zadaného
				 * robota. Dotýka sa to všetkých aspektov domovskej pozície:
				 * polohy, smeru, pootočenia tvaru, priehľadnosti,
				 * viditeľnosti, farby, cieľovej farby, veľkosti pera
				 * (hrúbky čiary), polohy pera, písma a veľkosti robota pri
				 * prechode na domovskú pozíciu. Pri väčšine týchto vlastností
				 * sa dá určiť, či majú alebo nemajú byť pri prechode na
				 * domovskú pozíciu ovplyvňované. Aj všetky tieto nastavenia
				 * sa touto metódou kopírujú zo zadaného (iného) robota do
				 * tohto robota.</p>
				 * 
				 * @param iný iný robot
				 */
				public void novýDomov(GRobot iný)
				{
					domaX = iný.domaX;
					domaY = iný.domaY;
					uholDoma = iný.uholDoma;
					peroPoloženéDoma = iný.viditeľnýDoma;
					viditeľnýDoma = iný.viditeľnýDoma;
					farbaDoma = iný.farbaDoma;
					cieľováFarbaDoma = iný.cieľováFarbaDoma;
					zrušCieľovúFarbuDoma = iný.zrušCieľovúFarbuDoma;
					polomerPeraDoma = iný.polomerPeraDoma;
					veľkosťDoma = iný.veľkosťDoma;
					pomerDoma = iný.pomerDoma;
					priehľadnosťDoma = iný.priehľadnosťDoma;
					písmoDoma = iný.písmoDoma;
					pootočenieTvaruDoma = iný.pootočenieTvaruDoma;
				}

				/** <p><a class="alias"></a> Alias pre {@link #novýDomov(GRobot) novýDomov}.</p> */
				public void novyDomov(GRobot iný) { novýDomov(iný); }


				/**
				 * <p><a class="getter"></a> Zistí aktuálnu x-ovú súradnicu
				 * domovskej pozície robota.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ovplyvňuje príkaz
				 * {@link #domov() domov} tri vlastnosti:
				 * {@linkplain #poloha() polohu}, {@linkplain #smer() smer},
				 * a {@linkplain #pootočenieTvaru() pootočenieTvaru}.</p>
				 * 
				 * @return domovská x-ová súradnica robota
				 */
				public double domaX() { return domaX; }

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu y-ovú súradnicu
				 * domovskej pozície robota.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ovplyvňuje príkaz
				 * {@link #domov() domov} tri vlastnosti:
				 * {@linkplain #poloha() polohu}, {@linkplain #smer() smer},
				 * a {@linkplain #pootočenieTvaru() pootočenieTvaru}.</p>
				 * 
				 * @return domovská y-ová súradnica robota
				 */
				public double domaY() { return domaY; }

				/**
				 * <p><a class="getter"></a> Zistí aktuálny smer (uhol)
				 * domovskej pozície robota.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ovplyvňuje príkaz
				 * {@link #domov() domov} tri vlastnosti:
				 * {@linkplain #poloha() polohu}, {@linkplain #smer() smer},
				 * a {@linkplain #pootočenieTvaru() pootočenieTvaru}.</p>
				 * 
				 * @return domovský smer (uhol) robota
				 * 
				 * @see #uhol()
				 * @see #smerDoma()
				 * @see #uholDoma(double)
				 * @see #smerDoma(double)
				 */
				public double uholDoma() { return uholDoma; }

				/**
				 * <p><a class="getter"></a> Zistí aktuálny smer (uhol)
				 * domovskej pozície robota.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ovplyvňuje príkaz
				 * {@link #domov() domov} tri vlastnosti:
				 * {@linkplain #poloha() polohu}, {@linkplain #smer() smer},
				 * a {@linkplain #pootočenieTvaru() pootočenieTvaru}.</p>
				 * 
				 * @return domovský smer (uhol) robota
				 * 
				 * @see #smer()
				 * @see #uholDoma()
				 * @see #uholDoma(double)
				 * @see #smerDoma(double)
				 */
				public double smerDoma() { return uholDoma; }

				/**
				 * <p><a class="setter"></a> Nastaví aktuálnu x-ovú súradnicu
				 * domovskej pozície robota.</p>
				 * 
				 * @param x nová domovská x-ová súradnica robota
				 */
				public void domaX(double x) { domaX = x; }

				/**
				 * <p><a class="setter"></a> Nastaví aktuálnu y-ovú súradnicu
				 * domovskej pozície robota.</p>
				 * 
				 * @param y nová domovská y-ová súradnica robota
				 */
				public void domaY(double y) { domaY = y; }

				/**
				 * <p><a class="setter"></a> Nastaví aktuálny smer (uhol)
				 * domovskej pozície robota.</p>
				 * 
				 * @param uhol nový domovský smer (uhol) robota
				 * 
				 * @see #uholDoma()
				 * @see #smerDoma()
				 * @see #smerDoma(double)
				 */
				public void uholDoma(double uhol) { uholDoma = uhol; }

				/**
				 * <p><a class="setter"></a> Nastaví aktuálny smer (uhol)
				 * domovskej pozície robota.</p>
				 * 
				 * @param uhol nový domovský smer (uhol) robota
				 * 
				 * @see #uholDoma()
				 * @see #smerDoma()
				 * @see #uholDoma(double)
				 */
				public void smerDoma(double uhol) { uholDoma = uhol; }


				/**
				 * <p>Zistí, či sa mení pootočenie tvaru pri prechode na
				 * domovskú pozíciu robota. Ak je stav pootočenia tvaru po
				 * prechode robota na domovskú pozíciu zmenený, metóda vráti
				 * objekt {@link java.lang.Double Double} s hodnotou, na ktorú
				 * bude pootočenie tvaru po prechode na domovskú pozíciu
				 * nastavené. Ak sa po prechode stav pootočenia tvaru nemení,
				 * tak metóda vráti hodnotu {@code valnull}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Predvolene ovplyvňuje
				 * príkaz {@link #domov() domov} tri vlastnosti:
				 * {@linkplain #poloha() polohu}, {@linkplain #smer() smer},
				 * a {@linkplain #pootočenieTvaru() pootočenieTvaru}.</p>
				 * 
				 * @return objekt {@link java.lang.Double Double} alebo
				 *     {@code valnull}
				 * 
				 * @see #pootočenieTvaruDoma(Double)
				 * @see #zachovajPootočenieTvaruDoma()
				 * @see #pootočenieTvaru()
				 * @see #pootočenieTvaru(double)
				 */
				public Double pootočenieTvaruDoma()
				{ return pootočenieTvaruDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #pootočenieTvaruDoma() pootočenieTvaruDoma}.</p> */
				public Double pootocenieTvaruDoma()
				{ return pootočenieTvaruDoma; }

				/**
				 * <p>Nastaví správanie zmeny pootočenia tvaru robota po prechode
				 * na domovskú pozíciu na základe zadaného objektu typu
				 * {@link java.lang.Double Double}. Ak je zadaný objekt
				 * s konkrétnou číselnou hodnotou, tak bude pootočenie tvaru
				 * robota po prechode domov upravené na túto hodnotu. Ak je
				 * zadané {@code valnull}, tak sa stav pootočenia tvaru
				 * robota po prechode domov nezmení.</p>
				 * 
				 * @param položené objekt {@link java.lang.Boolean Boolean}
				 *     alebo {@code valnull}
				 * 
				 * @see #pootočenieTvaruDoma()
				 * @see #zachovajPootočenieTvaruDoma()
				 * @see #pootočenieTvaru()
				 * @see #pootočenieTvaru(double)
				 */
				public void pootočenieTvaruDoma(Double pootočenie)
				{
					if (null == pootočenie)
					{
						pootočenieTvaruDoma = pootočenie;
					}
					else
					{
						pootočenieTvaruDoma = pootočenie % 360;
						if (pootočenieTvaruDoma < 0) pootočenieTvaruDoma += 360;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #pootočenieTvaruDoma(Double) pootočenieTvaruDoma}.</p> */
				public void pootocenieTvaruDoma(Double pootočenie)
				{ pootočenieTvaruDoma(pootočenie); }

				/**
				 * <p>Po použití tejto metódy nebude stav pootočenia tvaru robota
				 * pri použití niektorej modifikácie metódy {@link #domov()
				 * domov} ovplyvňovaný.</p>
				 * 
				 * @see #pootočenieTvaruDoma()
				 * @see #pootočenieTvaruDoma(Double)
				 * @see #pootočenieTvaru()
				 * @see #pootočenieTvaru(double)
				 */
				public void zachovajPootočenieTvaruDoma()
				{ pootočenieTvaruDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajPootočenieTvaruDoma() zachovajPootočenieTvaruDoma}.</p> */
				public void zachovajPootocenieTvaruDoma()
				{ pootočenieTvaruDoma = null; }


				/**
				 * <p>Zistí, či sa mení stav pera pri prechode na domovskú
				 * pozíciu robota. Ak je pero po prechode robota na domovskú
				 * pozíciu položené, tak metóda vráti objekt {@link 
				 * java.lang.Boolean Boolean} s hodnotou {@code valtrue},
				 * ak zdvihnuté, tak s hodnotou {@code valfalse}, ak sa po
				 * prechode stav pera nemení, tak metóda vráti hodnotu
				 * {@code valnull}.</p>
				 * 
				 * @return objekt {@link java.lang.Boolean Boolean} alebo
				 *     {@code valnull}
				 * 
				 * @see #polohaPeraDoma(Boolean)
				 * @see #peroZdvihnutéDoma()
				 * @see #peroPoloženéDoma()
				 * @see #zdvihniPeroDoma()
				 * @see #položPeroDoma()
				 * @see #zachovajPeroDoma()
				 * @see #polohaPera() polohaPera
				 */
				public Boolean polohaPeraDoma() { return peroPoloženéDoma; }

				/**
				 * <p>Overí, či robot pri prechode na domovskú pozíciu zdvihne
				 * pero z plátna. Ak je pero po prechode robota na
				 * domovskú pozíciu zdvihnuté, metóda vráti objekt {@link 
				 * java.lang.Boolean Boolean} s hodnotou {@code valtrue}, ak
				 * je položené, tak s hodnotou {@code valfalse}, ak sa po
				 * prechode domov stav pera nemení metóda vráti {@code 
				 * valnull}.</p>
				 * 
				 * @return objekt {@link java.lang.Boolean Boolean} alebo
				 *     {@code valnull}
				 * 
				 * @see #polohaPeraDoma()
				 * @see #polohaPeraDoma(Boolean)
				 * @see #peroPoloženéDoma()
				 * @see #zdvihniPeroDoma()
				 * @see #položPeroDoma()
				 * @see #zachovajPeroDoma()
				 */
				public Boolean peroZdvihnutéDoma()
				{
					if (null == peroPoloženéDoma) return null;
					return peroPoloženéDoma.booleanValue() ?
						Boolean.FALSE : Boolean.TRUE;
				}

				/** <p><a class="alias"></a> Alias pre {@link #peroZdvihnutéDoma() peroZdvihnutéDoma}.</p> */
				public Boolean peroZdvihnuteDoma()
				{ return peroZdvihnutéDoma(); }

				/**
				 * <p>Overí, či robot pri prechode na domovskú pozíciu položí
				 * pero na plátno. Ak je pero po prechode robota na
				 * domovskú pozíciu položené, tak metóda vráti objekt {@link 
				 * java.lang.Boolean Boolean} s hodnotou {@code valtrue}, ak
				 * je zdvihnuté, tak s hodnotou {@code valfalse}, ak sa po
				 * prechode stav pera nemení, tak metóda vráti hodnotu
				 * {@code valnull}.</p>
				 * 
				 * @return objekt {@link java.lang.Boolean Boolean} alebo
				 *     {@code valnull}
				 * 
				 * @see #polohaPeraDoma()
				 * @see #polohaPeraDoma(Boolean)
				 * @see #peroZdvihnutéDoma()
				 * @see #zdvihniPeroDoma()
				 * @see #položPeroDoma()
				 * @see #zachovajPeroDoma()
				 */
				public Boolean peroPoloženéDoma() { return peroPoloženéDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #peroPoloženéDoma() peroPoloženéDoma}.</p> */
				public Boolean peroPolozeneDoma()
				{ return peroPoloženéDoma(); }

				/**
				 * <p>Nastaví správanie zmeny polohy pera po prechode domov na
				 * základe zadaného objektu typu {@link java.lang.Boolean
				 * Boolean}. Pri zadaní objektu s hodnotou {@code valtrue},
				 * bude pero položené, pri objekte s hodnotou {@code 
				 * valfalse} bude pero zdvihnuté a pri zadaní {@code 
				 * valnull}, sa po prechode domov stav pera nezmení.</p>
				 * 
				 * @param položené objekt {@link java.lang.Boolean Boolean}
				 *     alebo {@code valnull}
				 * 
				 * @see #polohaPeraDoma()
				 * @see #peroZdvihnutéDoma()
				 * @see #peroPoloženéDoma()
				 * @see #zdvihniPeroDoma()
				 * @see #položPeroDoma()
				 * @see #zachovajPeroDoma()
				 * @see #polohaPera(boolean) polohaPera
				 */
				public void polohaPeraDoma(Boolean položené)
				{ peroPoloženéDoma = položené; }

				/**
				 * <p>Spôsobí, že odteraz vždy pri použití niektorej modifikácie
				 * metódy {@link #domov() domov} zdvihne robot pero z plátna.</p>
				 * 
				 * @see #polohaPeraDoma()
				 * @see #polohaPeraDoma(Boolean)
				 * @see #peroZdvihnutéDoma()
				 * @see #peroPoloženéDoma()
				 * @see #položPeroDoma()
				 * @see #zachovajPeroDoma()
				 * @see #zdvihniPero() zdvihniPero
				 */
				public void zdvihniPeroDoma() { peroPoloženéDoma = Boolean.FALSE; }

				/**
				 * <p>Spôsobí, že odteraz vždy pri použití niektorej modifikácie
				 * metódy {@link #domov() domov} položí robot pero na plátno.</p>
				 * 
				 * @see #polohaPeraDoma()
				 * @see #polohaPeraDoma(Boolean)
				 * @see #peroZdvihnutéDoma()
				 * @see #peroPoloženéDoma()
				 * @see #zdvihniPeroDoma()
				 * @see #zachovajPeroDoma()
				 * @see #položPero() položPero
				 */
				public void položPeroDoma() { peroPoloženéDoma = Boolean.TRUE; }

				/** <p><a class="alias"></a> Alias pre {@link #položPeroDoma() položPeroDoma}.</p> */
				public void polozPeroDoma() { peroPoloženéDoma = Boolean.TRUE; }

				/**
				 * <p>Po použití tejto metódy nebude stav polohy pera pri použití
				 * niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaný.</p>
				 * 
				 * @see #polohaPeraDoma()
				 * @see #polohaPeraDoma(Boolean)
				 * @see #peroZdvihnutéDoma()
				 * @see #peroPoloženéDoma()
				 * @see #zdvihniPeroDoma()
				 * @see #položPeroDoma()
				 */
				public void zachovajPeroDoma() { peroPoloženéDoma = null; }


				/**
				 * <p>Zistí, či sa mení viditeľnosť robota pri prechode na
				 * domovskú pozíciu. Ak je robot po prechode na domovskú
				 * pozíciu zobrazený, metóda vráti objekt {@link 
				 * java.lang.Boolean Boolean} s hodnotou {@code valtrue}, ak
				 * skrytý, tak s hodnotou {@code valfalse} a ak sa po
				 * prechode domov viditeľnosť nemení, metóda vráti {@code 
				 * valnull}.</p>
				 * 
				 * @return objekt {@link java.lang.Boolean Boolean} alebo
				 *     {@code valnull}
				 * 
				 * @see #zobrazenýDoma()
				 * @see #skrytýDoma()
				 * @see #ukážDoma()
				 * @see #zobrazDoma()
				 * @see #skryDoma()
				 * @see #zachovajViditeľnosťDoma()
				 * @see #viditeľný() viditeľný
				 */
				public Boolean viditeľnýDoma() { return viditeľnýDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #viditeľnýDoma() viditeľnýDoma}.</p> */
				public Boolean viditelnyDoma() { return viditeľnýDoma; }

				/**
				 * <p>Zistí, či sa mení viditeľnosť robota pri prechode na
				 * domovskú pozíciu. Ak je robot po prechode na domovskú
				 * pozíciu zobrazený, metóda vráti objekt {@link 
				 * java.lang.Boolean Boolean} s hodnotou {@code valtrue}, ak
				 * skrytý, tak s hodnotou {@code valfalse} a ak sa po
				 * prechode domov viditeľnosť nemení, metóda vráti {@code 
				 * valnull}.</p>
				 * 
				 * @return objekt {@link java.lang.Boolean Boolean} alebo
				 *     {@code valnull}
				 * 
				 * @see #viditeľnýDoma()
				 * @see #skrytýDoma()
				 * @see #ukážDoma()
				 * @see #zobrazDoma()
				 * @see #skryDoma()
				 * @see #zachovajViditeľnosťDoma()
				 * @see #zobrazený() zobrazený
				 */
				public Boolean zobrazenýDoma() { return viditeľnýDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #zobrazenýDoma() zobrazenýDoma}.</p> */
				public Boolean zobrazenyDoma() { return viditeľnýDoma; }

				/**
				 * <p>Zistí, či sa mení viditeľnosť robota pri prechode na
				 * domovskú pozíciu. Ak je robot po prechode na domovskú
				 * pozíciu skrytý, metóda vráti objekt {@link 
				 * java.lang.Boolean Boolean} s hodnotou {@code valtrue}, ak
				 * zobrazený, tak s hodnotou {@code valfalse} a ak sa po
				 * prechode domov viditeľnosť nemení, metóda vráti {@code 
				 * valnull}.</p>
				 * 
				 * @return objekt {@link java.lang.Boolean Boolean} alebo
				 *     {@code valnull}
				 * 
				 * @see #viditeľnýDoma()
				 * @see #zobrazenýDoma()
				 * @see #ukážDoma()
				 * @see #zobrazDoma()
				 * @see #skryDoma()
				 * @see #zachovajViditeľnosťDoma()
				 * @see #skrytý() skrytý
				 */
				public Boolean skrytýDoma()
				{
					if (null == viditeľnýDoma) return null;
					return viditeľnýDoma.booleanValue() ?
						Boolean.FALSE : Boolean.TRUE;
				}

				/** <p><a class="alias"></a> Alias pre {@link #skrytýDoma() skrytýDoma}.</p> */
				public Boolean skrytyDoma() { return skrytýDoma(); }

				/**
				 * <p>Spôsobí, že odteraz sa robot vždy pri použití niektorej
				 * modifikácie metódy {@link #domov() domov} zobrazí.</p>
				 * 
				 * @see #viditeľnýDoma()
				 * @see #zobrazenýDoma()
				 * @see #skrytýDoma()
				 * @see #zobrazDoma()
				 * @see #skryDoma()
				 * @see #zachovajViditeľnosťDoma()
				 * @see #ukáž() ukáž
				 */
				public void ukážDoma() { viditeľnýDoma = Boolean.TRUE; }

				/** <p><a class="alias"></a> Alias pre {@link #viditeľnýDoma() viditeľnýDoma}.</p> */
				public void ukazDoma() { viditeľnýDoma = Boolean.TRUE; }

				/**
				 * <p>Spôsobí, že odteraz sa robot vždy pri použití niektorej
				 * modifikácie metódy {@link #domov() domov} zobrazí.</p>
				 * 
				 * @see #viditeľnýDoma()
				 * @see #zobrazenýDoma()
				 * @see #skrytýDoma()
				 * @see #ukážDoma()
				 * @see #skryDoma()
				 * @see #zachovajViditeľnosťDoma()
				 * @see #zobraz() zobraz
				 */
				public void zobrazDoma() { viditeľnýDoma = Boolean.TRUE; }

				/**
				 * <p>Spôsobí, že odteraz sa robot vždy pri použití niektorej
				 * modifikácie metódy {@link #domov() domov} skryje.</p>
				 * 
				 * @see #viditeľnýDoma()
				 * @see #zobrazenýDoma()
				 * @see #skrytýDoma()
				 * @see #ukážDoma()
				 * @see #zobrazDoma()
				 * @see #zachovajViditeľnosťDoma()
				 * @see #skry() skry
				 */
				public void skryDoma() { viditeľnýDoma = Boolean.FALSE; }

				/**
				 * <p>Po použití tejto metódy nebude viditeľnosť robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * @see #viditeľnýDoma()
				 * @see #zobrazenýDoma()
				 * @see #skrytýDoma()
				 * @see #ukážDoma()
				 * @see #zobrazDoma()
				 * @see #skryDoma()
				 */
				public void zachovajViditeľnosťDoma() { viditeľnýDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajViditeľnosťDoma() zachovajViditeľnosťDoma}.</p> */
				public void zachovajViditelnostDoma() { viditeľnýDoma = null; }


				/**
				 * <p>Zistí, ako sa mení farba po prechode robota
				 * {@linkplain #domov() domov}. Buď je vrátená konkrétna
				 * farba, alebo hodnota {@code valnull}, ktorá
				 * signalizuje, že farba sa po prechode domov nemení.</p>
				 * 
				 * @return hodnota farby po prechode robota na domovskú
				 *     pozíciu alebo {@code valnull}
				 * 
				 * @see #farbaDoma(Color)
				 * @see #farbaDoma(Farebnosť)
				 * @see #farbaDoma(int, int, int)
				 * @see #farbaDoma(int, int, int, int)
				 * @see #zachovajFarbuDoma()
				 * @see #farba() farba
				 */
				public Farba farbaDoma() { return farbaDoma; }

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie farby robota po jeho
				 * prechode {@linkplain #domov() domov}. Ak je zadaná
				 * konkrétna farebná inštancia, tak sa bude farba robota po
				 * prechode domov meniť na zadanú hodnotu. Ak je zadaná
				 * hodnota {@code (Farba)}{@code valnull}, tak farba nebude
				 * po prechode domov ovplyvnená.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Hodnota {@code valnull}
				 * nemá žiadny údajový typ. Je akoby „spoločná pre všetky
				 * údajové typy.“ Táto hodnota vyjadruje neprítomnosť
				 * žiadneho objektu, neprítomnosť žiadnej inštancie.
				 * V skutočnosti nie je a nikdy nebude možné určiť jej typ.
				 * Pri volaní metódy musí byť pretypovanie prítomné preto,
				 * aby kompilátor dokázal určiť, ktorú verziu z preťažených
				 * metód má volať.</p>
				 * 
				 * @param nováFarba nová hodnota farby pera robota, ktorá má
				 *     byť nastavená po jeho prechode na domovskú pozíciu
				 *     alebo pretypovaná hodnota {@code (Farba)}{@code valnull}
				 * 
				 * @see #farbaDoma()
				 * @see #farbaDoma(Farebnosť)
				 * @see #farbaDoma(int, int, int)
				 * @see #farbaDoma(int, int, int, int)
				 * @see #zachovajFarbuDoma()
				 * @see #farba(Color) farba
				 */
				public void farbaDoma(Color nováFarba)
				{
					if (null == nováFarba) farbaDoma = null;
					else if (nováFarba instanceof Farba)
						farbaDoma = (Farba)nováFarba;
					else
						farbaDoma = new Farba(nováFarba);
				}

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie farby robota po jeho
				 * prechode {@linkplain #domov() domov}. Ak je zadaná
				 * konkrétna farebná inštancia, tak sa bude farba robota po
				 * prechode domov meniť na zadanú hodnotu. Ak je zadaná
				 * hodnota {@code (Farebnosť)}{@code valnull}, tak farba
				 * nebude po prechode domov ovplyvnená.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Hodnota {@code valnull}
				 * nemá žiadny údajový typ. Je akoby „spoločná pre všetky
				 * údajové typy.“ Táto hodnota vyjadruje neprítomnosť
				 * žiadneho objektu, neprítomnosť žiadnej inštancie.
				 * V skutočnosti nie je a nikdy nebude možné určiť jej typ.
				 * Pri volaní metódy musí byť pretypovanie prítomné preto,
				 * aby kompilátor dokázal určiť, ktorú verziu z preťažených
				 * metód má volať.</p>
				 * 
				 * @param podľaObjektu objekt určujúci novú farbu na
				 *     domovskej pozícii alebo pretypovaná hodnota
				 *     {@code (Farebnosť)}{@code valnull}
				 * 
				 * @see #farbaDoma()
				 * @see #farbaDoma(Color)
				 * @see #farbaDoma(int, int, int)
				 * @see #farbaDoma(int, int, int, int)
				 * @see #zachovajFarbuDoma()
				 */
				public void farbaDoma(Farebnosť podľaObjektu)
				{ farbaDoma(podľaObjektu.farba()); }

				/**
				 * <p>Nastaví ovplyvňovanie farby robota po jeho
				 * prechode {@linkplain #domov() domov}.</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @return objekt typu {@link Farba Farba} – nová farba
				 * 
				 * @see #farbaDoma()
				 * @see #farbaDoma(Color)
				 * @see #farbaDoma(Farebnosť)
				 * @see #farbaDoma(int, int, int, int)
				 * @see #zachovajFarbuDoma()
				 */
				public Farba farbaDoma(int r, int g, int b)
				{
					farbaDoma = new Farba(r, g, b);
					return farbaDoma;
				}

				/**
				 * <p>Nastaví ovplyvňovanie farby robota po jeho
				 * prechode {@linkplain #domov() domov}.</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param a úroveň (ne)priehľadnosti novej farby; celé číslo
				 *     v rozsahu 0 – 255 (0 – neviditeľná farba; 255 –
				 *     nepriehľadná farba)
				 * @return objekt typu {@link Farba Farba} – nová farba
				 * 
				 * @see #farbaDoma()
				 * @see #farbaDoma(Color)
				 * @see #farbaDoma(Farebnosť)
				 * @see #farbaDoma(int, int, int)
				 * @see #zachovajFarbuDoma()
				 */
				public Farba farbaDoma(int r, int g, int b, int a)
				{
					farbaDoma = new Farba(r, g, b, a);
					return farbaDoma;
				}

				/**
				 * <p>Po použití tejto metódy nebude farba robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * @see #farbaDoma()
				 * @see #farbaDoma(Color)
				 * @see #farbaDoma(Farebnosť)
				 * @see #farbaDoma(int, int, int)
				 * @see #farbaDoma(int, int, int, int)
				 */
				public void zachovajFarbuDoma() { farbaDoma = null; }


				/**
				 * <p>Zistí, ako sa mení cieľová farba po prechode robota
				 * {@linkplain #domov() domov}. Buď je vrátená konkrétna
				 * farba, alebo hodnota {@code valnull}, ktorá signalizuje
				 * to, že cieľová farba nie je po prechode robota domov
				 * ovplyvnená.</p>
				 * 
				 * @return hodnota cieľovej farby robota po jeho prechode
				 *     na domovskú pozíciu alebo {@code valnull}
				 * 
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 * @see #zrušCieľovúFarbuDoma()
				 * @see #cieľováFarba() cieľováFarba
				 */
				public Farba cieľováFarbaDoma() { return cieľováFarbaDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarbaDoma() cieľováFarbaDoma}.</p> */
				public Farba cielovaFarbaDoma() { return cieľováFarbaDoma; }

				/**
				 * <p>Zmení nastavenie cieľovej farby robota po jeho prechode
				 * {@linkplain #domov() domov}. Hodnota {@code (Farba)}{@link 
				 * valnull} znamená, že ak nie je nastavené {@linkplain 
				 * #zrušCieľovúFarbuDoma(boolean) zrušenie cieľovej farby
				 * doma}, tak cieľová farba nie je po prechode domov
				 * ovplyvnená.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Hodnota {@code valnull}
				 * nemá žiadny údajový typ. Je akoby „spoločná pre všetky
				 * údajové typy.“ Táto hodnota vyjadruje neprítomnosť
				 * žiadneho objektu, neprítomnosť žiadnej inštancie.
				 * V skutočnosti nie je a nikdy nebude možné určiť jej typ.
				 * Pri volaní metódy musí byť pretypovanie prítomné preto,
				 * aby kompilátor dokázal určiť, ktorú verziu z preťažených
				 * metód má volať.</p>
				 * 
				 * @param nováFarba cieľová farba robota po prechode na
				 *     domovskú pozíciu alebo pretypovaná hodnota
				 *     {@code (Farba)}{@code valnull}
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 * @see #zrušCieľovúFarbuDoma()
				 * @see #cieľováFarba(Color) cieľováFarba
				 */
				public void cieľováFarbaDoma(Color nováFarba)
				{
					if (null == nováFarba) cieľováFarbaDoma = null;
					else if (nováFarba instanceof Farba)
						cieľováFarbaDoma = (Farba)nováFarba;
					else
						cieľováFarbaDoma = new Farba(nováFarba);
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarbaDoma(Color) cieľováFarbaDoma}.</p> */
				public void cielovaFarbaDoma(Color nováFarba)
				{ cieľováFarbaDoma(nováFarba); }

				/**
				 * <p>Zmení nastavenie cieľovej farby robota po jeho prechode
				 * {@linkplain #domov() domov}. Hodnota {@code 
				 * (Farebnosť)}{@code valnull} znamená, že cieľová farba nie
				 * je po prechode domov ovplyvnená.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Hodnota {@code valnull}
				 * nemá žiadny údajový typ. Je akoby „spoločná pre všetky
				 * údajové typy.“ Táto hodnota vyjadruje neprítomnosť
				 * žiadneho objektu, neprítomnosť žiadnej inštancie.
				 * V skutočnosti nie je a nikdy nebude možné určiť jej typ.
				 * Pri volaní metódy musí byť pretypovanie prítomné preto,
				 * aby kompilátor dokázal určiť, ktorú verziu z preťažených
				 * metód má volať.</p>
				 * 
				 * @param podľaObjektu objekt určujúci nastavenie cieľovej
				 *     farby robota, ktorá bude použitá pri jeho prechode
				 *     na domovskú pozíciu, pričom pretypovaná hodnota
				 *     {@code (Farebnosť)}{@code valnull} signalizuje zrušenie
				 *     nastavenia cieľovej farby pri prechode domov
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 * @see #zrušCieľovúFarbuDoma()
				 */
				public void cieľováFarbaDoma(Farebnosť podľaObjektu)
				{
					if (null == podľaObjektu)
						cieľováFarbaDoma = null;
					else if (podľaObjektu instanceof GRobot)
						cieľováFarbaDoma(((GRobot)podľaObjektu).cieľováFarba());
					else
						cieľováFarbaDoma(podľaObjektu.farba());
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarbaDoma(Farebnosť) cieľováFarbaDoma}.</p> */
				public void cielovaFarbaDoma(Farebnosť podľaObjektu)
				{ cieľováFarbaDoma(podľaObjektu); }

				/**
				 * <p>Nastaví cieľovú farbu robota po jeho
				 * prechode {@linkplain #domov() domov}.</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @return objekt typu {@link Farba Farba} – nová cieľová farba
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 * @see #zrušCieľovúFarbuDoma()
				 */
				public Farba cieľováFarbaDoma(int r, int g, int b)
				{
					cieľováFarbaDoma = new Farba(r, g, b);
					return cieľováFarbaDoma;
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarbaDoma(int, int, int) cieľováFarbaDoma}.</p> */
				public Farba cielovaFarbaDoma(int r, int g, int b)
				{ return cieľováFarbaDoma(r, g, b); }

				/**
				 * <p>Nastaví cieľovú farbu robota po jeho
				 * prechode {@linkplain #domov() domov}.</p>
				 * 
				 * @param r červená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param g zelená zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param b modrá zložka novej farby; celé číslo v rozsahu
				 *     0 – 255
				 * @param a úroveň (ne)priehľadnosti novej farby; celé číslo
				 *     v rozsahu 0 – 255 (0 – neviditeľná farba; 255 –
				 *     nepriehľadná farba)
				 * @return objekt typu {@link Farba Farba} – nová cieľová farba
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 * @see #zrušCieľovúFarbuDoma()
				 */
				public Farba cieľováFarbaDoma(int r, int g, int b, int a)
				{
					cieľováFarbaDoma = new Farba(r, g, b, a);
					return cieľováFarbaDoma;
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľováFarbaDoma(int, int, int, int) cieľováFarbaDoma}.</p> */
				public Farba cielovaFarbaDoma(int r, int g, int b, int a)
				{ return cieľováFarbaDoma(r, g, b, a); }

				/**
				 * <p>Overí, či bude po použití niektorej modifikácie metódy
				 * {@link #domov() domov} cieľová farba zrušená, alebo nie.</p>
				 * 
				 * @return {@code valtrue} – cieľová farba bude po prechode
				 *     robota domov zrušená; {@code valtrue} – cieľová farba
				 *     bude nastavená na konkrétnu farbu alebo nebude
				 *     ovplyvnená – pozri metódu {@link 
				 *     #cieľováFarbaDoma(Color) cieľováFarbaDoma}
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 * @see #zrušCieľovúFarbuDoma()
				 */
				public boolean zrušíCieľovúFarbuDoma() { return zrušCieľovúFarbuDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľovúFarbuDoma() zrušCieľovúFarbuDoma}.</p> */
				public boolean zrusiCielovuFarbuDoma() { return zrušCieľovúFarbuDoma; }

				/**
				 * <p>Táto metóda umožňuje nastaviť správanie zmeny cieľovej
				 * farby robota po prechode na domovskú pozíciu. Ak je hodnota
				 * parametra {@code zruš} rovná {@code valtrue}, tak cieľová
				 * farba bude po použití niektorej modifikácie metódy {@link 
				 * #domov() domov} zrušená, v opačnom prípade závisí od
				 * nastavenia parametra robota {@link #cieľováFarbaDoma()
				 * cieľováFarbaDoma}.</p>
				 * 
				 * @param zruš hodnota {@code valtrue} znamená, že cieľová
				 *     farba bude po prechode {@linkplain #domov() domov}
				 *     zrušená a hodnota{@code valfalse} znamená, že zmena
				 *     cieľovej farby pri prechode domov závisí od nastavenia
				 *     parametra robota {@link #cieľováFarbaDoma()
				 *     cieľováFarbaDoma}
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma()
				 */
				public void zrušCieľovúFarbuDoma(boolean zruš) { zrušCieľovúFarbuDoma = zruš; }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľovúFarbuDoma() zrušCieľovúFarbuDoma}.</p> */
				public void zrusCielovuFarbuDoma(boolean zruš) { zrušCieľovúFarbuDoma = zruš; }

				/**
				 * <p>Po použití tejto metódy bude cieľová farba robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * zrušená.</p>
				 * 
				 * @see #cieľováFarbaDoma()
				 * @see #cieľováFarbaDoma(Color)
				 * @see #cieľováFarbaDoma(Farebnosť)
				 * @see #cieľováFarbaDoma(int, int, int)
				 * @see #cieľováFarbaDoma(int, int, int, int)
				 * @see #zrušíCieľovúFarbuDoma()
				 * @see #zrušCieľovúFarbuDoma(boolean)
				 */
				public void zrušCieľovúFarbuDoma() { zrušCieľovúFarbuDoma = true; }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľovúFarbuDoma() zrušCieľovúFarbuDoma}.</p> */
				public void zrusCielovuFarbuDoma() { zrušCieľovúFarbuDoma = true; }


				/**
				 * <p>Zistí, ako sa mení hrúbka pera po prechode robota
				 * {@linkplain #domov() domov}. Buď je vrátená konkrétna
				 * číselná hodnota, alebo hodnota {@code valnull}, ktorá
				 * signalizuje, že hrúbka pera sa po prechode domov nemení.</p>
				 * 
				 * @return hrúbka pera domovskej pozície alebo {@code valnull}
				 * 
				 * @see #hrúbkaČiaryDoma()
				 * @see #hrúbkaPeraDoma(Double)
				 * @see #hrúbkaČiaryDoma(Double)
				 * @see #zachovajHrúbkuPeraDoma()
				 * @see #zachovajHrúbkuČiaryDoma()
				 * @see #hrúbkaPera() hrúbkaPera
				 */
				public Double hrúbkaPeraDoma() { return polomerPeraDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaPeraDoma() hrúbkaPeraDoma}.</p> */
				public Double hrubkaPeraDoma() { return polomerPeraDoma; }

				/**
				 * <p>Zistí, ako sa mení hrúbka pera po prechode robota
				 * {@linkplain #domov() domov}. Buď je vrátená konkrétna
				 * číselná hodnota, alebo hodnota {@code valnull}, ktorá
				 * signalizuje, že hrúbka pera sa po prechode domov nemení.</p>
				 * 
				 * @return hrúbka pera domovskej pozície alebo {@code valnull}
				 * 
				 * @see #hrúbkaPeraDoma()
				 * @see #hrúbkaPeraDoma(Double)
				 * @see #hrúbkaČiaryDoma(Double)
				 * @see #zachovajHrúbkuPeraDoma()
				 * @see #zachovajHrúbkuČiaryDoma()
				 * @see #hrúbkaČiary() hrúbkaČiary
				 */
				public Double hrúbkaČiaryDoma() { return polomerPeraDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaPeraDoma() hrúbkaPeraDoma}.</p> */
				public Double hrubkaCiaryDoma() { return polomerPeraDoma; }

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie hrúbky pera po prechode
				 * robota {@linkplain #domov() domov}. Ak je zadaná konkrétna
				 * číselná hodnota, hrúbka pera robota bude po prechode domov
				 * upravená na zadanú hodnotu. Ak je zadaná hodnota {@link 
				 * valnull}, tak hrúbka pera nebude po prechode domov
				 * ovplyvnená.</p>
				 * 
				 * @param nováHrúbka nová hrúbka pera domovskej pozície alebo
				 *     {@code valnull}
				 * 
				 * @see #hrúbkaPeraDoma()
				 * @see #hrúbkaČiaryDoma()
				 * @see #hrúbkaČiaryDoma(Double)
				 * @see #zachovajHrúbkuPeraDoma()
				 * @see #zachovajHrúbkuČiaryDoma()
				 * @see #hrúbkaPera(double) hrúbkaPera
				 */
				public void hrúbkaPeraDoma(Double nováHrúbka)
				{ polomerPeraDoma = nováHrúbka; }

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaPeraDoma(Double) hrúbkaPeraDoma}.</p> */
				public void hrubkaPeraDoma(Double nováHrúbka)
				{ polomerPeraDoma = nováHrúbka; }

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie hrúbky pera po prechode
				 * robota {@linkplain #domov() domov}. Ak je zadaná konkrétna
				 * číselná hodnota, hrúbka pera robota bude po prechode domov
				 * upravená na zadanú hodnotu. Ak je zadaná hodnota {@link 
				 * valnull}, tak hrúbka pera nebude po prechode domov
				 * ovplyvnená.</p>
				 * 
				 * @param nováHrúbka nová hrúbka pera domovskej pozície alebo
				 *     {@code valnull}
				 * 
				 * @see #hrúbkaPeraDoma()
				 * @see #hrúbkaČiaryDoma()
				 * @see #hrúbkaPeraDoma(Double)
				 * @see #zachovajHrúbkuPeraDoma()
				 * @see #zachovajHrúbkuČiaryDoma()
				 * @see #hrúbkaČiary(double) hrúbkaČiary
				 */
				public void hrúbkaČiaryDoma(Double nováHrúbka)
				{ polomerPeraDoma = nováHrúbka; }

				/** <p><a class="alias"></a> Alias pre {@link #hrúbkaPeraDoma(Double) hrúbkaPeraDoma}.</p> */
				public void hrubkaCiaryDoma(Double nováHrúbka)
				{ polomerPeraDoma = nováHrúbka; }

				/**
				 * <p>Po použití tejto metódy nebude hrúbka pera robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * @see #hrúbkaPeraDoma()
				 * @see #hrúbkaČiaryDoma()
				 * @see #hrúbkaPeraDoma(Double)
				 * @see #hrúbkaČiaryDoma(Double)
				 * @see #zachovajHrúbkuČiaryDoma()
				 */
				public void zachovajHrúbkuPeraDoma()
				{ polomerPeraDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajHrúbkuPeraDoma() zachovajHrúbkuPeraDoma}.</p> */
				public void zachovajHrubkuPeraDoma()
				{ polomerPeraDoma = null; }

				/**
				 * <p>Po použití tejto metódy nebude hrúbka pera robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * @see #hrúbkaPeraDoma()
				 * @see #hrúbkaČiaryDoma()
				 * @see #hrúbkaPeraDoma(Double)
				 * @see #hrúbkaČiaryDoma(Double)
				 * @see #zachovajHrúbkuPeraDoma()
				 */
				public void zachovajHrúbkuČiaryDoma()
				{ polomerPeraDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajHrúbkuČiaryDoma() zachovajHrúbkuČiaryDoma}.</p> */
				public void zachovajHrubkuCiaryDoma()
				{ polomerPeraDoma = null; }


				/**
				 * <p>Zistí, ako sa mení veľkosť robota po jeho prechode na
				 * {@linkplain #domov() domovskú pozíciu}. Buď je vrátená
				 * konkrétna číselná hodnota, alebo hodnota {@code valnull},
				 * ktorá signalizuje, že veľkosť robota sa po prechode domov
				 * nemení.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @return hodnota veľkosti robota po prechode na domovskú
				 *     pozíciu alebo {@code valnull}
				 * 
				 * @see #pomerDoma()
				 * @see #rozmerDoma()
				 * @see #zachovajVeľkosťDoma()
				 * @see #veľkosť()
				 */
				public Double veľkosťDoma() { return veľkosťDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #veľkosťDoma() veľkosťDoma}.</p> */
				public Double velkostDoma() { return veľkosťDoma; }

				/**
				 * <p>Zistí, ako sa mení pomer veľkosti robota po jeho
				 * prechode na {@linkplain #domov() domovskú pozíciu}. Buď
				 * je vrátená konkrétna číselná hodnota, alebo hodnota
				 * {@code valnull}, ktorá signalizuje, že pomer veľkosti
				 * robota sa po prechode domov nemení.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @return hodnota pomeru veľkosti robota po prechode na
				 *     domovskú pozíciu alebo {@code valnull}
				 * 
				 * @see #veľkosťDoma()
				 * @see #rozmerDoma()
				 * @see #zachovajPomerDoma()
				 * @see #pomer()
				 */
				public Double pomerDoma() { return pomerDoma; }

				/**
				 * <p>Zistí, či a ako sa budú meniť rozmery ({@linkplain 
				 * #šírka() šírky} a {@linkplain #výška() výšky} robota po
				 * prechode na domovskú pozíciu. V skutočnosti (pozri poznámku
				 * nižšie) ide o prepočítané hodnoty dvoch iných vlastností:
				 * {@link #veľkosťDoma() veľkosťDoma} a {@link #pomerDoma()
				 * pomerDoma}. Ak je hociktorá z týchto dvoch vlastností
				 * <b><i>ne</i></b>nastavená (rovná {@code valnull}), tak
				 * bude návratová hodnota tejto metódy {@code valnull},
				 * pretože domovský rozmer bez nich nemôže byť vypočítaný.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * {@link #veľkosťDoma() veľkosťDoma}
				 * {@link #pomerDoma() pomerDoma}
				 * 
				 * @return objekt obsahujúci zmenu rozmerov robota po
				 *     prechode na domovskú pozíciu alebo {@code valnull}
				 * 
				 * @see #veľkosťDoma()
				 * @see #pomerDoma()
				 * @see #zachovajRozmerDoma()
				 * @see #rozmery()
				 */
				public Rozmer rozmerDoma()
				{
					// TODO – test
					if (null == veľkosťDoma || null == pomerDoma) return null;
					return new Rozmery(2.0 * veľkosťDoma * pomerDoma,
						2.0 * veľkosťDoma);
				}

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie veľkosti robota po jeho
				 * prechode na {@linkplain #domov() domovskú pozíciu}. Ak je
				 * zadaná konkrétna číselná hodnota, veľkosť robota bude
				 * po prechode domov upravená na zadanú hodnotu. Ak je zadaná
				 * hodnota {@code valnull}, tak veľkosť robota nebude po
				 * prechode domov ovplyvnená.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @param nováVeľkosť nová veľkosť robota, ktorá bude
				 *     nastavená pri prechode robota na domovskú pozíciu
				 *     alebo {@code valnull}
				 * 
				 * @see #pomerDoma(Double)
				 * @see #rozmerDoma(Rozmer)
				 * @see #zachovajVeľkosťDoma()
				 * @see #veľkosť(double)
				 */
				public void veľkosťDoma(Double nováVeľkosť)
				{ veľkosťDoma = nováVeľkosť; }

				/** <p><a class="alias"></a> Alias pre {@link #veľkosťDoma(Double) veľkosťDoma}.</p> */
				public void velkostDoma(Double nováVeľkosť)
				{ veľkosťDoma = nováVeľkosť; }

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie pomeru veľkosti robota
				 * po jeho prechode na {@linkplain #domov() domovskú pozíciu}.
				 * Ak je zadaná konkrétna číselná hodnota, tak bude pomer
				 * veľkosti robota po prechode domov upravený na zadanú
				 * hodnotu. Ak je zadaná hodnota {@code valnull}, tak sa
				 * pomer veľkosti robota po prechode domov nezmení.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @param novýPomer nová hodnota pomeru veľkosti pri prechode
				 *     na domovskú pozíciu; {@code valnull} znamená „nemeniť
				 *     pomer pri prechode na domovskú pozíciu“
				 * 
				 * @see #veľkosťDoma(Double)
				 * @see #rozmerDoma(Rozmer)
				 * @see #zachovajPomerDoma()
				 * @see #pomer(double)
				 */
				public void pomerDoma(Double novýPomer)
				{ pomerDoma = novýPomer; }

				/**
				 * <p>Nastaví alebo zruší nastavovanie zmeny rozmerov (šírky
				 * a výšky) robota po prechode na domovskú pozíciu.
				 * V skutočnosti nastavuje táto metóda hodnoty dvojice
				 * vlastností {@link #veľkosťDoma(Double) veľkosťDoma}
				 * a {@link #pomerDoma(Double) pomerDoma}. Ich hodnoty sú
				 * prepočítané podľa pravidiel, ktoré sú rozpísané
				 * v upozornení v opise metódy {@link #rozmery(double,
				 * double) rozmery}{@code (šírka, výška)} (pozri aj poznámku
				 * nižšie). Ak je hodnota nového rozmeru rovná
				 * {@code valnull}, tak budú obidve vlastnosti (domovská
				 * veľkosť a domovský pomer veľkosti) nastavené na
				 * {@code valnull}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @param novýRozmer inštancia rozmeru, ktorého hodnoty budú
				 *     prepočítané na {@link #veľkosťDoma(Double) veľkosťDoma}
				 *     a {@link #pomerDoma(Double) pomerDoma} alebo hodnota
				 *     {@code valnull}
				 * 
				 * @see #veľkosťDoma(Double)
				 * @see #pomerDoma(Double)
				 * @see #zachovajRozmerDoma()
				 * @see #rozmery(Rozmer)
				 */
				public void rozmerDoma(Rozmer novýRozmer)
				{
					// TODO – test
					if (null == novýRozmer)
						veľkosťDoma = pomerDoma = null;
					else
					{
						veľkosťDoma = novýRozmer.výška() / 2.0;
						if (0 == veľkosťDoma) pomerDoma = 0.0;
						else pomerDoma = (novýRozmer.šírka() / 2.0) / veľkosťDoma;
					}
				}

				/**
				 * <p>Po použití tejto metódy nebude veľkosť robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @see #veľkosťDoma()
				 * @see #pomerDoma()
				 * @see #rozmerDoma()
				 * @see #veľkosťDoma(Double)
				 */
				public void zachovajVeľkosťDoma() { veľkosťDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajVeľkosťDoma() zachovajVeľkosťDoma}.</p> */
				public void zachovajVelkostDoma() { veľkosťDoma = null; }

				/**
				 * <p>Po použití tejto metódy nebude pomer veľkosti robota
				 * (šírky a výšky) pri použití niektorej modifikácie metódy
				 * {@link #domov() domov} ovplyvňovaný.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @see #veľkosťDoma()
				 * @see #pomerDoma()
				 * @see #rozmerDoma()
				 * @see #pomerDoma(Double)
				 */
				public void zachovajPomerDoma() { pomerDoma = null; }

				/**
				 * <p>Volanie tejto metódy je ekvivalentné volaniu tejto
				 * dvojice metód:</p>
				 * 
				 * <ul><li>{@link #zachovajVeľkosťDoma() zachovajVeľkosťDoma}</li>
				 * <li>{@link #zachovajPomerDoma() zachovajPomerDoma}</li></ul>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
				 * upozorneniu v opise metódy {@link #rozmery(double, double)
				 * rozmery}{@code (šírka, výška)}.</p>
				 * 
				 * @see #veľkosťDoma()
				 * @see #pomerDoma()
				 * @see #rozmerDoma()
				 * @see #rozmerDoma(Rozmer)
				 */
				public void zachovajRozmerDoma()
				{
					veľkosťDoma = null;
					pomerDoma = null;
				}


				/**
				 * <p>Zistí, ako sa mení priehľadnosť robota po jeho prechode na
				 * {@linkplain #domov() domovskú pozíciu}. Buď je vrátená
				 * konkrétna číselná hodnota, alebo hodnota {@code valnull},
				 * ktorá signalizuje, že priehľadnosť robota sa po prechode
				 * domov nemení.</p>
				 * 
				 * @return hodnota priehľadnosti robota po jeho prechode
				 *     na domovskú pozíciu alebo {@code valnull}
				 * 
				 * @see #priehľadnosťDoma(Double)
				 * @see #zachovajPriehľadnosťDoma()
				 * @see #priehľadnosť()
				 */
				public Double priehľadnosťDoma()
				{
					if (null ==  priehľadnosťDoma) return null;
					return new Double(priehľadnosťDoma);
				}

				/** <p><a class="alias"></a> Alias pre {@link #priehľadnosťDoma() priehľadnosťDoma}.</p> */
				public Double priehladnostDoma() { return priehľadnosťDoma(); }

				/**
				 * <p>Nastaví alebo zruší ovplyvňovanie priehľadnosti robota po
				 * jeho prechode na {@linkplain #domov() domovskú pozíciu}.
				 * Ak je zadaná konkrétna číselná hodnota, priehľadnosť robota
				 * bude po prechode domov upravená na zadanú hodnotu. Ak je
				 * zadaná hodnota {@code valnull}, tak priehľadnosť robota
				 * nebude po prechode domov ovplyvnená.</p>
				 * 
				 * @param nováPriehľadnosť nová priehľadnosť robota na domovskej
				 *     pozícii alebo {@code valnull}
				 * 
				 * @see #priehľadnosťDoma()
				 * @see #zachovajPriehľadnosťDoma()
				 * @see #priehľadnosť()
				 */
				public void priehľadnosťDoma(Double nováPriehľadnosť)
				{
					if (null == nováPriehľadnosť)
						priehľadnosťDoma = null;
					else
						priehľadnosťDoma = new Float(nováPriehľadnosť);
				}

				/** <p><a class="alias"></a> Alias pre {@link #priehľadnosťDoma(Double) priehľadnosťDoma}.</p> */
				public void priehladnostDoma(Double nováPriehľadnosť)
				{ priehľadnosťDoma(nováPriehľadnosť); }

				/**
				 * <p>Po použití tejto metódy nebude priehľadnosť robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * @see #priehľadnosťDoma()
				 * @see #priehľadnosťDoma(Double)
				 */
				public void zachovajPriehľadnosťDoma()
				{ priehľadnosťDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajPriehľadnosťDoma() zachovajPriehľadnosťDoma}.</p> */
				public void zachovajPriehladnostDoma()
				{ priehľadnosťDoma = null; }


				/**
				 * <p>Zistí, ako sa mení písmo robota po jeho prechode na
				 * {@linkplain #domov() domovskú pozíciu}. Buď je vrátený
				 * konkrétny objekt reprezentujúci písmo, alebo hodnota
				 * {@code valnull}, ktorá signalizuje, že písmo robota sa po
				 * prechode domov nemení.</p>
				 * 
				 * @return písmo, ktoré bude nastavené po prechode robota na
				 *     domovskú pozíciu alebo {@code valnull}
				 * 
				 * @see #písmoDoma(Font)
				 * @see #písmoDoma(String, double)
				 * @see #zachovajPísmoDoma()
				 * @see #písmo()
				 */
				public Písmo písmoDoma() { return písmoDoma; }

				/** <p><a class="alias"></a> Alias pre {@link #písmoDoma() písmoDoma}.</p> */
				public Pismo pismoDoma() { return new Pismo(písmoDoma); }

				/**
				 * <p>Nastaví alebo zruší zmenu písma robota po jeho prechode na
				 * {@linkplain #domov() domovskú pozíciu}. Ak je zadaný objekt
				 * typu {@link Písmo} alebo {@link java.awt.Font}, tak písmo
				 * robota sa po prechode domov zmení podľa zadaného objektu.
				 * Ak je zadaná hodnota {@code valnull}, tak písmo robota nebude
				 * po prechode domov ovplyvnené.</p>
				 * 
				 * @param novéPísmo objekt typu {@link Písmo} alebo
				 *     {@link java.awt.Font} alebo {@code valnull}
				 * 
				 * @see #písmoDoma()
				 * @see #písmoDoma(String, double)
				 * @see #zachovajPísmoDoma()
				 * @see #písmo(String, double)
				 */
				public void písmoDoma(Font novéPísmo)
				{
					if (null == novéPísmo) písmoDoma = null;
					else if (novéPísmo instanceof Písmo)
						písmoDoma = (Písmo)novéPísmo;
					else
						písmoDoma = new Písmo(novéPísmo);
				}

				/** <p><a class="alias"></a> Alias pre {@link #písmoDoma(Font) písmoDoma}.</p> */
				public void pismoDoma(Font novéPísmo) { písmoDoma(novéPísmo); }

				/**
				 * <p>Určí nové písmo robota, ktoré bude nastavené po jeho prechode
				 * na {@linkplain #domov() domovskú pozíciu}.</p>
				 * 
				 * @param názov názov písma; môže byť všeobecný názov
				 *     logického písma (Dialog, DialogInput, Monospaced,
				 *     Serif, SansSerif…) alebo názov
				 *     konkrétneho písma (Times New Roman, Arial…)
				 * @param veľkosť veľkosť písma v bodoch (hodnota je
				 *     zaokrúhlená na typ {@code typefloat})
				 * @return objekt typu {@link Písmo} určujúci nový typ písma
				 *     robota
				 * 
				 * @see #písmoDoma()
				 * @see #písmoDoma(Font)
				 * @see #zachovajPísmoDoma()
				 * @see #písmo(String, double)
				 */
				public Písmo písmoDoma(String názov, double veľkosť)
				{ return písmoDoma = new Písmo(názov, Písmo.PLAIN, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #písmoDoma(String, double) písmoDoma}.</p> */
				public Pismo pismoDoma(String názov, double veľkosť)
				{ return pismoDoma(názov, veľkosť); }

				/**
				 * <p>Po použití tejto metódy nebude písmo robota pri
				 * použití niektorej modifikácie metódy {@link #domov() domov}
				 * ovplyvňovaná.</p>
				 * 
				 * @see #písmoDoma()
				 * @see #písmoDoma(Font)
				 * @see #písmoDoma(String, double)
				 */
				public void zachovajPísmoDoma()
				{ písmoDoma = null; }

				/** <p><a class="alias"></a> Alias pre {@link #zachovajPísmoDoma() zachovajPísmoDoma}.</p> */
				public void zachovajPismoDoma()
				{ písmoDoma = null; }


			// Spôsob kreslenia

				/**
				 * <p><a class="getter"></a> Číta spôsob kreslenia obrázkov
				 * a písania textov (resp. „kreslenia“ textov) aktuálnym
				 * robotom.</p>
				 * 
				 * @return spôsob kreslenia, čo môže byť buď hodnota {@link 
				 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
				 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}
				 * 
				 * @see #text(String)
				 * @see #obrázok(String)
				 */
				public int spôsobKreslenia() { return spôsobKreslenia; }

				/** <p><a class="alias"></a> Alias pre {@link #spôsobKreslenia() spôsobKreslenia}.</p> */
				public int sposobKreslenia() { return spôsobKreslenia; }

				/**
				 * <p><a class="setter"></a> Zmení spôsob kreslenia obrázkov
				 * a písania textov (resp. „kreslenia“ textov) aktuálnym
				 * robotom.</p>
				 * 
				 * @param novýSpôsobKreslenia môže byť buď hodnota {@link 
				 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
				 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
				 * 
				 * @see #text(String)
				 * @see #obrázok(String)
				 */
				public void spôsobKreslenia(int novýSpôsobKreslenia)
				{ spôsobKreslenia = novýSpôsobKreslenia; }

				/** <p><a class="alias"></a> Alias pre {@link #spôsobKreslenia(int) spôsobKreslenia}.</p> */
				public void sposobKreslenia(int novýSpôsobKreslenia)
				{ spôsobKreslenia = novýSpôsobKreslenia; }


			// Meno robota, uloženie/zapísanie a čítanie

				/**
				 * <p><a class="setter"></a> Pomenuje alebo zruší meno tohto
				 * robota. Meno robota je používané pri zápise a obnove
				 * vlastností robota s pomocou {@linkplain 
				 * Svet#použiKonfiguráciu(String) konfiguračného súboru}
				 * a {@linkplain Svet#interaktívnyRežim(boolean)
				 * interaktívnym režimom}.</p>
				 * 
				 * <p>Zadané meno musí byť unikátne, nesmie byť prázdne ani
				 * rezervované, nesmie sa začínať ani končiť bodkou a nesmie
				 * obsahovať znak rovná sa. Na zrušenie mena tohto robota
				 * treba zavolať túto metódu s argumentom {@code valnull}.</p>
				 * 
				 * <p>Rezervované mená sú: {@code srg"svet"},
				 * {@code srg"podlaha"}, {@code srg"strop"}
				 * a {@code srg"robot"}. Posledné pomenovanie je rezervované
				 * pre {@linkplain Svet#hlavnýRobot() hlavný robot}. Pri
				 * ňom jedinom toto meno nespôsobí vznik výnimky {@link 
				 * GRobotException GRobotException} ohlasujúcej zadanie
				 * nesprávneho (rezervovaného) mena a pre neho je zároveň
				 * tento reťazec ekvivalentný zrušeniu mena robota zadaním
				 * hodnoty {@code valnull}. (To znamená, že aj hlavný robot
				 * môže mať vlastné unikátne meno, ale v prípade priradenia
				 * predvoleného mena je jeho pomenovanie fiktívne. To znamená,
				 * že ak by náhodou svoje privilégium {@linkplain 
				 * Svet#hlavnýRobot() hlavný robot} z nejakého dôvodu
				 * stratil, tak sa z neho automaticky stane nepomenovaný
				 * robot.)</p>
				 * 
				 * @param novéMeno nového meno robota alebo {@code valnull}
				 *     na zrušenie mena tohto robota
				 * 
				 * @throws GRobotException ak zadané meno nespĺňa niektorú
				 *     požiadavku
				 */
				public void meno(String novéMeno)
				{
					if (null != menoRobota)
					{
						menáRobotov.remove(menoRobota);
						menoRobota = null;
					}

					// Argument null len zruší meno robota:
					if (null == novéMeno) return;

					if (novéMeno.equalsIgnoreCase("robot"))
					{
						if (this == Svet.hlavnýRobot) return;
						throw new GRobotException(
							"Zadané meno robota je rezervované.",
							"robotNameReserved", novéMeno,
							new IllegalArgumentException());
					}

					if (menáRobotov.containsKey(novéMeno))
						throw new GRobotException(
							"Meno robota (" + novéMeno +
							") musí byť unikátne.", "robotNameMustBeUnique",
							novéMeno, new IllegalArgumentException());

					if (novéMeno.equals(""))
						throw new GRobotException(
							"Meno robota nesmie byť prázdne.",
							"robotNameEmpty",
							new IllegalArgumentException());

					if (novéMeno.equalsIgnoreCase("svet") ||
						novéMeno.equalsIgnoreCase("podlaha") ||
						novéMeno.equalsIgnoreCase("strop"))
						throw new GRobotException(
							"Zadané meno robota je rezervované.",
							"robotNameReserved", novéMeno,
							new IllegalArgumentException());

					if (novéMeno.endsWith("."))
						throw new GRobotException(
							"Meno robota sa nesmie končiť bodkou.",
							"robotNameEndsWithDot", novéMeno,
							new IllegalArgumentException());

					if (novéMeno.startsWith(";"))
						throw new GRobotException(
							"Meno robota sa nesmie začínať znakom komentára.",
							"robotNameStartsWithSemicolon", novéMeno,
							new IllegalArgumentException());

					if (novéMeno.startsWith("."))
						throw new GRobotException(
							"Meno robota sa nesmie začínať bodkou.",
							"robotNameStartsWithDot", novéMeno,
							new IllegalArgumentException());

					if (-1 != novéMeno.indexOf('='))
						throw new GRobotException(
							"Meno robota nesmie obsahovať znak rovná sa.",
							"robotNameContainsEquals", novéMeno,
							new IllegalArgumentException());

					menoRobota = novéMeno;
					menáRobotov.put(menoRobota, this);
				}

				/**
				 * <p><a class="getter"></a> Vráti meno robota alebo
				 * {@code valnull} ak robot nemá meno. Ak ide o {@linkplain 
				 * Svet#hlavnýRobot() hlavný robot}, ktorý nebol pomenovaný
				 * (to znamená, že jeho meno nebolo {@linkplain #meno(String)
				 * zmenené}), tak metóda vráti rezervované meno
				 * {@code srg"robot"}.</p>
				 * 
				 * @return vráti meno robota alebo {@code valnull} (ak robot
				 *     nemá meno a nejde o hlavný robot)
				 * 
				 * @see #meno(String)
				 */
				public String meno()
				{
					if (null == menoRobota && this == Svet.hlavnýRobot)
						return "robot";
					return menoRobota;
				}


				/**
				 * <p>Zaregistruje tento robot v {@linkplain 
				 * Svet#použiKonfiguráciu(String) konfigurácii sveta}. To
				 * znamená, že po ukončení aplikácie budú údaje o tomto
				 * robote automaticky uložené do konfigurácie sveta. Táto
				 * metóda by mala byť vykonaná pri spustení aplikácie, pretože
				 * jej vykonanie zároveň prečíta a použije údaje o robote
				 * z konfiguračného súboru. Ak tento robot nie je {@linkplain 
				 * Svet#hlavnýRobot() hlavným robotom}, tak musí mať definované
				 * {@linkplain #meno(String) meno}, inak vznikne výnimka.
				 * Ďalšie informácie môžete nájsť pri ekvivalentnej metóde
				 * sveta {@link Svet#registrujRobot(GRobot)
				 * registrujRobot(robot)}.</p>
				 * 
				 * @see Svet#registrujRobot(GRobot)
				 * @see Svet#dajRobot(String)
				 * @see GRobot#registrujVKonfigurácii(String)
				 * @see GRobot#jeRegistrovaný()
				 */
				public void registrujVKonfigurácii()
				{ Svet.registrujRobot(this); }

				/** <p><a class="alias"></a> Alias pre {@link #registrujVKonfigurácii() registrujVKonfigurácii}.</p> */
				public void registrujVKonfiguracii()
				{ registrujVKonfigurácii(); }

				/**
				 * <p>Zaregistruje tento robot v {@linkplain 
				 * Svet#použiKonfiguráciu(String) konfigurácii sveta} pod
				 * novým {@linkplain #meno(String) menom}. To znamená, že po
				 * ukončení aplikácie budú údaje o tomto robote automaticky
				 * uložené do konfigurácie sveta. Táto metóda by mala byť
				 * vykonaná pri spustení aplikácie, pretože jej vykonanie
				 * zároveň prečíta a použije údaje o robote z konfiguračného
				 * súboru. Ak tento robot nie je {@linkplain Svet#hlavnýRobot()
				 * hlavným robotom}, tak musí mať definované {@linkplain 
				 * #meno(String) meno} (pričom zadané meno nesmie mať hodnotu
				 * {@code valnull}), inak vznikne výnimka. Ďalšie informácie
				 * môžete nájsť pri úzko súvisiacej metóde sveta {@link 
				 * Svet#registrujRobot(GRobot) registrujRobot(robot)}.</p>
				 * 
				 * @param novéMeno nové meno robota
				 * 
				 * @see Svet#registrujRobot(GRobot)
				 * @see Svet#dajRobot(String)
				 * @see GRobot#registrujVKonfigurácii()
				 * @see GRobot#jeRegistrovaný()
				 */
				public void registrujVKonfigurácii(String novéMeno)
				{
					meno(novéMeno);
					Svet.registrujRobot(this);
				}

				/** <p><a class="alias"></a> Alias pre {@link #registrujVKonfigurácii(String) registrujVKonfigurácii}.</p> */
				public void registrujVKonfiguracii(String novéMeno)
				{ registrujVKonfigurácii(novéMeno); }

				/**
				 * <p>Overí, či je tento robot {@linkplain 
				 * #registrujVKonfigurácii() registrovaný} v {@linkplain 
				 * Svet#použiKonfiguráciu(String) konfigurácii sveta}.</p>
				 * 
				 * @return {@code valtrue} ak je robot {@linkplain 
				 *     #registrujVKonfigurácii() registrovaný}
				 *     v {@linkplain Svet#použiKonfiguráciu(String)
				 *     konfigurácii sveta}, inak {@code valfalse}
				 * 
				 * @see Svet#registrujRobot(GRobot)
				 * @see Svet#dajRobot(String)
				 * @see GRobot#registrujVKonfigurácii()
				 * @see GRobot#registrujVKonfigurácii(String)
				 */
				public boolean jeRegistrovaný() { return jeRegistrovaný; }

				/** <p><a class="alias"></a> Alias pre {@link #jeRegistrovaný() jeRegistrovaný}.</p> */
				public boolean jeRegistrovany() { return jeRegistrovaný; }

				/**
				 * <p>Prečíta vlastnosti robota zo zadaného súboru. Robot musí
				 * mať {@linkplain #meno(String) meno} (okrem {@linkplain 
				 * Svet#hlavnýRobot() hlavného robota}, ktorému je v prípade
				 * nepriradenia žiadneho mena automaticky priradené meno
				 * {@code robot}) a súbor musí
				 * byť otvorený na čítanie. Metóda je používaná {@linkplain 
				 * Svet#použiKonfiguráciu(String) automatickou konfiguráciou}
				 * sveta. (Ďalšie informácie súvisiace s ukladaním údajov robota
				 * sú v opise metódy {@link #uložDoSúboru(Súbor)
				 * uložDoSúboru(súbor)}.)</p>
				 * 
				 * @param súbor inštancia triedy {@linkplain Súbor súbor}
				 *     otvorená na čítanie
				 * 
				 * @see ObsluhaUdalostí#konfiguráciaZmenená()
				 * @see Svet#použiKonfiguráciu()
				 * @see Svet#registrujRobot(GRobot, String)
				 * @see #uložDoSúboru(Súbor)
				 * 
				 * @exception IOException ak vznikla chyba vo
				 *     vstupno-výstupnej operácii
				 * @throws GRobotException ak robot nemá meno
				 */
				public void čítajZoSúboru(Súbor súbor) throws IOException
				{
					String menoRobota = this.menoRobota;

					if (null == menoRobota)
					{
						if (this == Svet.hlavnýRobot)
							menoRobota = "robot";
						else
							throw new GRobotException("Robot nemá meno.",
								"robotHasNoName");
					}

					boolean kresliB = !Svet.nekresli;
					Svet.nekresli = true;

					String mennýPriestor = súbor.aktívnaSekcia.
						mennýPriestorVlastností;
					if (null == mennýPriestor)
						súbor.aktívnaSekcia.mennýPriestorVlastností =
							menoRobota;
					else
						súbor.aktívnaSekcia.mennýPriestorVlastností =
							mennýPriestor + "." + menoRobota;

					try
					{
						String vlastnosťS; int vlastnosťI1, vlastnosťI2;
						boolean vlastnosťB; Bod bod; Double vlastnosťD;

						// Na nastavovanie vlastností musí byť použitá
						// prislúchajúca metóda, lebo každá zmena hodnoty
						// vlastnosti má za následok sériu akcií…
						vlastnosťS = súbor.čítajVlastnosť("poloha",
							Bod.polohaNaReťazec(this));
						if (null != vlastnosťS)
							poloha(Bod.reťazecNaPolohu(vlastnosťS));
						uhol(súbor.čítajVlastnosť("uhol", aktuálnyUhol));
						uholOtáčania(súbor.čítajVlastnosť(
							"uholOtáčania", uholOtáčania));
						pootočenieTvaru(súbor.čítajVlastnosť("pootočenieTvaru",
							pootočenieTvaru));

						vlastnosťS = súbor.čítajVlastnosť("farba",
							Farba.farbaNaReťazec(farbaRobota));
						if (null != vlastnosťS)
							farba(Farba.reťazecNaFarbu(vlastnosťS));

						vlastnosťS = súbor.čítajVlastnosť("cieľováFarba",
							null == cieľováFarba ? null :
								Farba.farbaNaReťazec(cieľováFarba));
						if (null == vlastnosťS)
							zrušCieľovúFarbu();
						else
							cieľováFarba(Farba.reťazecNaFarbu(vlastnosťS));

						použiKruhovýNáter = súbor.čítajVlastnosť(
							"použiKruhovýNáter", použiKruhovýNáter);

						hrúbkaČiary(súbor.čítajVlastnosť("hrúbkaPera",
							polomerPera));

						polohaPera(súbor.čítajVlastnosť("peroPoložené",
							peroPoložené));
						if (súbor.čítajVlastnosť("viditeľnosť", viditeľný))
							ukáž(); else skry();
						veľkosť(súbor.čítajVlastnosť("veľkosť", veľkosť));
						pomer(súbor.čítajVlastnosť("pomerVeľkosti",
							pomerVeľkosti));
						zaoblenieX(súbor.čítajVlastnosť("zaoblenieX",
							zaoblenieX));
						zaoblenieY(súbor.čítajVlastnosť("zaoblenieY",
							zaoblenieY));
						pôvodnáVeľkosť = súbor.čítajVlastnosť(
							"pôvodnáVeľkosť", pôvodnáVeľkosť);
						pôvodnýPomer = súbor.čítajVlastnosť(
							"pôvodnýPomer", pôvodnýPomer);
						priehľadnosť = súbor.čítajVlastnosť("priehľadnosť",
							// Double.valueOf(priehľadnosť)).floatValue();
							priehľadnosť);

						vyplnený = súbor.čítajVlastnosť("vyplnený", vyplnený);

						if (aktívnePlátno == podlaha)
							vlastnosťS = súbor.čítajVlastnosť("plátno",
								"podlaha");
						else if (aktívnePlátno == strop)
							vlastnosťS = súbor.čítajVlastnosť("plátno",
								"strop");
						else
							vlastnosťS = súbor.čítajVlastnosť("plátno",
								(String)null);

						if (null != vlastnosťS)
						{
							vlastnosťS = vlastnosťS.toLowerCase();
							if (-1 != vlastnosťS.indexOf("podlaha"))
								kresliNaPodlahu();
							else if (-1 != vlastnosťS.indexOf("strop"))
								kresliNaStrop();
						}

						// Poznámka: Príznaky (ne)kreslenia dutých/vyplnených
						//     tvarov (kresliTvary a vypĺňajTvary) sú uložené
						//     v rámci nasledujúcej vlastnosti „kresli.“
						{
							String kresliS = "";

							if (0 != (spôsobKreslenia & KRESLI_ROTOVANÉ))
								kresliS += " | rotované";
							if (0 != (spôsobKreslenia & KRESLI_NA_STRED))
								kresliS += " | centrované";

							if (vypĺňajTvary) kresliS += " | vyplnené";
							if (kresliTvary) kresliS += " | tvary";

							if (kresliS.isEmpty())
								kresliS = "priamo";
							else
								kresliS = kresliS.substring(3);

							spôsobKreslenia = 0;
							vlastnosťS = súbor.čítajVlastnosť(
								"kresli", kresliS);
							if (null != vlastnosťS)
							{
								vlastnosťS = vlastnosťS.toLowerCase();
								if (-1 != vlastnosťS.indexOf("rotované") ||
									-1 != vlastnosťS.indexOf("rotovane") ||
									-1 != vlastnosťS.indexOf("v-smere"))
									spôsobKreslenia |= KRESLI_ROTOVANÉ;
								if (-1 != vlastnosťS.indexOf("centrované") ||
									-1 != vlastnosťS.indexOf("centrovane") ||
									-1 != vlastnosťS.indexOf("na-stred"))
									spôsobKreslenia |= KRESLI_CENTROVANÉ;
								kresliTvary = -1 != vlastnosťS.indexOf("tvary");
								vypĺňajTvary = (-1 != vlastnosťS.indexOf(
									"vyplnené")) || (-1 != vlastnosťS.indexOf(
									"vyplnene"));
							}
						}

						vlastnosťI1 = súbor.čítajVlastnosť("vrstva",
							// Long.valueOf(vrstva)).intValue();
							vrstva);
						if (vlastnosťI1 != vrstva) vrstva(vlastnosťI1);

						vlastnosťB = súbor.čítajVlastnosť(
							"interaktívny", interaktívnyRežim);
						interaktívnyRežim(vlastnosťB);


						písmo(aktuálnePísmo.čítajZoSúboru(súbor));


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".ohraničenie";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota +
								".ohraničenie";

						{
							String ohraničenieS = "neznáme";

							switch (aktuálneOhraničenie)
							{
							case ŽIADNE: ohraničenieS = "žiadne"; break;
							case ODRAZ:  ohraničenieS = "odraz";  break;
							case PLOT:   ohraničenieS = "plot";   break;
							case PRETOČ: ohraničenieS = "pretoč"; break;
							}

							vlastnosťS = súbor.čítajVlastnosť(
								"spôsob", ohraničenieS);
							if (null != vlastnosťS)
							{
								vlastnosťS = vlastnosťS.toLowerCase().trim();
								if (vlastnosťS.equals("žiadne") ||
									vlastnosťS.equals("ziadne"))
									aktuálneOhraničenie = ŽIADNE;
								else if (vlastnosťS.equals("odraz") ||
									vlastnosťS.equals("odrazenie") ||
									vlastnosťS.equals("odraziť") ||
									vlastnosťS.equals("odrazit"))
									aktuálneOhraničenie = ODRAZ;
								else if (vlastnosťS.equals("plot") ||
									vlastnosťS.equals("oplotenie") ||
									vlastnosťS.equals("oplotiť") ||
									vlastnosťS.equals("oplotit"))
									aktuálneOhraničenie = PLOT;
								else if (vlastnosťS.equals("pretoč") ||
									vlastnosťS.equals("pretoc") ||
									vlastnosťS.equals("pretočenie") ||
									vlastnosťS.equals("pretocenie") ||
									vlastnosťS.equals("pretočiť") ||
									vlastnosťS.equals("pretocit"))
									aktuálneOhraničenie = PRETOČ;
								else
									aktuálneOhraničenie = ŽIADNE;
							}
						}

						{
							String ohraničenieS = "neznáme";

							switch (zálohovanéOhraničenie)
							{
							case ŽIADNE: ohraničenieS = "žiadne"; break;
							case ODRAZ:  ohraničenieS = "odraz";  break;
							case PLOT:   ohraničenieS = "plot";   break;
							case PRETOČ: ohraničenieS = "pretoč"; break;
							}

							vlastnosťS = súbor.čítajVlastnosť(
								"záloha", ohraničenieS);
							if (null != vlastnosťS)
							{
								vlastnosťS = vlastnosťS.toLowerCase().trim();
								if (vlastnosťS.equals("žiadne") ||
									vlastnosťS.equals("ziadne"))
									zálohovanéOhraničenie = ŽIADNE;
								else if (vlastnosťS.equals("odraz") ||
									vlastnosťS.equals("odrazenie") ||
									vlastnosťS.equals("odraziť") ||
									vlastnosťS.equals("odrazit"))
									zálohovanéOhraničenie = ODRAZ;
								else if (vlastnosťS.equals("plot") ||
									vlastnosťS.equals("oplotenie") ||
									vlastnosťS.equals("oplotiť") ||
									vlastnosťS.equals("oplotit"))
									zálohovanéOhraničenie = PLOT;
								else if (vlastnosťS.equals("pretoč") ||
									vlastnosťS.equals("pretoc") ||
									vlastnosťS.equals("pretočenie") ||
									vlastnosťS.equals("pretocenie") ||
									vlastnosťS.equals("pretočiť") ||
									vlastnosťS.equals("pretocit"))
									zálohovanéOhraničenie = PRETOČ;
								else
									zálohovanéOhraničenie = ŽIADNE;
							}
						}

						// switch (aktuálneOhraničenie)
						// {
						// case ODRAZ: case PLOT: case PRETOČ:
							ľaváHranica = súbor.čítajVlastnosť(
								"ľavé",  ľaváHranica);
							dolnáHranica = súbor.čítajVlastnosť(
								"dolné", dolnáHranica);
							praváHranica = súbor.čítajVlastnosť(
								"pravé", praváHranica);
							hornáHranica = súbor.čítajVlastnosť(
								"horné", hornáHranica);
						// }


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".pôsobisko";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".pôsobisko";

						kresliPôsobisko = súbor.čítajVlastnosť(
							"kresli", kresliPôsobisko);

						vlastnosťS = súbor.čítajVlastnosť("minimum",
							Bod.polohaNaReťazec(minimálneX, minimálneY));
						if (null != vlastnosťS)
						{
							bod = Bod.reťazecNaPolohu(vlastnosťS);
							minimálneX = bod.polohaX();
							minimálneY = bod.polohaY();
						}

						vlastnosťS = súbor.čítajVlastnosť("maximum",
							Bod.polohaNaReťazec(minimálneX, minimálneY));
						if (null != vlastnosťS)
						{
							bod = Bod.reťazecNaPolohu(vlastnosťS);
							minimálneX = bod.polohaX();
							minimálneY = bod.polohaY();
						}


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".doma";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".doma";

						vlastnosťS = súbor.čítajVlastnosť("poloha",
							Bod.polohaNaReťazec(domaX, domaY));
						if (null != vlastnosťS)
						{
							bod = Bod.reťazecNaPolohu(vlastnosťS);
							domaX = bod.polohaX(); domaY = bod.polohaY();
						}
						uholDoma = súbor.čítajVlastnosť("uhol", uholDoma);
						pootočenieTvaruDoma = súbor.čítajVlastnosť(
							"pootočenieTvaru", pootočenieTvaruDoma);

						vlastnosťS = súbor.čítajVlastnosť("farba",
							null == farbaDoma ? null :
								Farba.farbaNaReťazec(farbaDoma));
						farbaDoma = null == vlastnosťS ? null :
							Farba.reťazecNaFarbu(vlastnosťS);

						vlastnosťS = súbor.čítajVlastnosť("cieľováFarba",
							null == cieľováFarbaDoma ? null :
								Farba.farbaNaReťazec(cieľováFarbaDoma));
						cieľováFarbaDoma = null == vlastnosťS ? null :
							Farba.reťazecNaFarbu(vlastnosťS);

						zrušCieľovúFarbuDoma = súbor.čítajVlastnosť(
							"zrušCieľovúFarbu", zrušCieľovúFarbuDoma);

						polomerPeraDoma = súbor.čítajVlastnosť("hrúbkaPera",
							polomerPeraDoma);

						peroPoloženéDoma = súbor.čítajVlastnosť("peroPoložené",
							peroPoloženéDoma);
						viditeľnýDoma = súbor.čítajVlastnosť("viditeľnosť",
							viditeľnýDoma);
						veľkosťDoma = súbor.čítajVlastnosť("veľkosť",
							veľkosťDoma);
						pomerDoma = súbor.čítajVlastnosť("pomer",
							pomerDoma);

						vlastnosťD = súbor.čítajVlastnosť("priehľadnosť",
							null == priehľadnosťDoma ? (Double)null :
							new Double(priehľadnosťDoma));
						priehľadnosťDoma = null == vlastnosťD ? (Float)null :
							new Float(vlastnosťD);

						písmoDoma(Písmo.čítajZoSúboru(súbor, písmoDoma));

						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".aktivita";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".aktivita";

						boolean aktivuj = súbor.čítajVlastnosť(
							"aktívny", aktívny);
						otáčanieTvaru = súbor.čítajVlastnosť("otáčanieTvaru",
							otáčanieTvaru);
						gyroskop = súbor.čítajVlastnosť("gyroskop", gyroskop);
						rýchlosť = súbor.čítajVlastnosť("rýchlosť", rýchlosť);
						rýchlosťPosunu = súbor.čítajVlastnosť(
							"rýchlosťPosunu", rýchlosťPosunu);
						uhlováRýchlosť = súbor.čítajVlastnosť(
							"uhlováRýchlosť", uhlováRýchlosť);
						maximálnaRýchlosť = súbor.čítajVlastnosť(
							"maximálnaRýchlosť", maximálnaRýchlosť);
						maximálnaRýchlosťPosunu = súbor.čítajVlastnosť(
							"maximálnaRýchlosťPosunu", maximálnaRýchlosťPosunu);
						maximálnaUhlováRýchlosť = súbor.čítajVlastnosť(
							"maximálnaUhlováRýchlosť", maximálnaUhlováRýchlosť);
						zrýchlenie = súbor.čítajVlastnosť("zrýchlenie",
							zrýchlenie);
						zrýchleniePosunu = súbor.čítajVlastnosť(
							"zrýchleniePosunu", zrýchleniePosunu);
						uhlovéZrýchlenie = súbor.čítajVlastnosť(
							"uhlovéZrýchlenie", uhlovéZrýchlenie);
						trvanieAktivity = súbor.čítajVlastnosť(
							"trvanieAktivity",
							// Long.valueOf(trvanieAktivity)).intValue();
							trvanieAktivity);
						trvaniePasivity = súbor.čítajVlastnosť(
							"trvaniePasivity",
							// Long.valueOf(trvaniePasivity)).intValue();
							trvaniePasivity);


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".cieľ";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".cieľ";

						cieľAktívny = súbor.čítajVlastnosť("aktívny",
							cieľAktívny);

						vlastnosťS = súbor.čítajVlastnosť("poloha",
							Bod.polohaNaReťazec(cieľX, cieľY));
						if (null != vlastnosťS)
						{
							bod = Bod.reťazecNaPolohu(vlastnosťS);
							cieľX = bod.polohaX(); cieľY = bod.polohaY();
						}
						zastavVCieli = súbor.čítajVlastnosť("zastavV",
							zastavVCieli);
						zastavPoSpomalení = súbor.čítajVlastnosť(
							"zastavPoSpomalení", zastavPoSpomalení);
						zastavPoSpomaleníPosunu = súbor.čítajVlastnosť(
							"zastavPoSpomaleníPosunu", zastavPoSpomaleníPosunu);

						if (aktívny != aktivuj)
						{
							if (aktivuj)
								aktivuj(trvanieAktivity, false);
							else
								deaktivuj(trvaniePasivity, false);
						}
					}
					finally
					{
						if (kresliB) Svet.kresli();
						súbor.aktívnaSekcia.mennýPriestorVlastností =
							mennýPriestor;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #čítajZoSúboru(Súbor) čítajZoSúboru}.</p> */
				public void citajZoSuboru(Súbor súbor) throws IOException
				{ čítajZoSúboru(súbor); }

				/** <p><a class="alias"></a> Alias pre {@link #čítajZoSúboru(Súbor) čítajZoSúboru}.</p> */
				public void prečítajZoSúboru(Súbor súbor) throws IOException
				{ čítajZoSúboru(súbor); }

				/** <p><a class="alias"></a> Alias pre {@link #čítajZoSúboru(Súbor) čítajZoSúboru}.</p> */
				public void precitajZoSuboru(Súbor súbor) throws IOException
				{ čítajZoSúboru(súbor); }

				/**
				 * <p>Uloží vlastnosti robota do zadaného súboru. Robot musí
				 * mať {@linkplain #meno(String) meno} (okrem {@linkplain 
				 * Svet#hlavnýRobot() hlavného robota}, ktorému je v prípade
				 * nepriradenia žiadneho mena automaticky priradené meno
				 * {@code robot}) a súbor musí
				 * byť otvorený na zápis. Metóda je používaná {@linkplain 
				 * Svet#použiKonfiguráciu(String) automatickou konfiguráciou}
				 * sveta. Do konfigurácie je zapísaných mnoho vlastností
				 * robota súvisiacich s jeho vzhľadom a aktivitou.
				 * <b>Nie sú</b> ukladané napríklad: spojnice, nastavenia
				 * kreslenia vlastného tvaru robota, nastavenie kreslenia do
				 * obrázka, záloha plátna, záznam cesty, ani zamestnanosť pre
				 * potreby obrázkov.</p>
				 * 
				 * @param súbor inštancia triedy {@linkplain Súbor súbor}
				 *     otvorená na zápis
				 * 
				 * @see ObsluhaUdalostí#konfiguráciaZmenená()
				 * @see Svet#použiKonfiguráciu()
				 * @see Svet#registrujRobot(GRobot, String)
				 * @see #čítajZoSúboru(Súbor)
				 * 
				 * @exception IOException ak vznikla chyba vo
				 *     vstupno-výstupnej operácii
				 * @throws GRobotException ak robot nemá meno
				 */
				public void uložDoSúboru(Súbor súbor) throws IOException
				{
					String menoRobota = this.menoRobota;

					if (null == menoRobota)
					{
						if (this == Svet.hlavnýRobot)
							menoRobota = "robot";
						else
							throw new GRobotException("Robot nemá meno.",
								"robotHasNoName");
					}

					String mennýPriestor = súbor.aktívnaSekcia.
						mennýPriestorVlastností;
					if (null == mennýPriestor)
						súbor.aktívnaSekcia.mennýPriestorVlastností =
							menoRobota;
					else
						súbor.aktívnaSekcia.mennýPriestorVlastností =
							mennýPriestor + "." + menoRobota;

					try
					{
						súbor.zapíšVlastnosť("poloha",
							Bod.polohaNaReťazec(this));
						súbor.zapíšVlastnosť("uhol", aktuálnyUhol);
						súbor.zapíšVlastnosť("uholOtáčania", uholOtáčania);
						súbor.zapíšVlastnosť("pootočenieTvaru",
							pootočenieTvaru);

						súbor.zapíšVlastnosť("farba",
							Farba.farbaNaReťazec(this));
						súbor.zapíšVlastnosť("cieľováFarba",
							null == cieľováFarba ? null :
							Farba.farbaNaReťazec(cieľováFarba));
						súbor.zapíšVlastnosť("použiKruhovýNáter",
							použiKruhovýNáter);
						súbor.zapíšVlastnosť("hrúbkaPera", polomerPera);

						súbor.zapíšVlastnosť("peroPoložené", peroPoložené);
						súbor.zapíšVlastnosť("viditeľnosť", viditeľný);
						súbor.zapíšVlastnosť("veľkosť", veľkosť);
						súbor.zapíšVlastnosť("pomerVeľkosti", pomerVeľkosti);
						súbor.zapíšVlastnosť("zaoblenieX", zaoblenieX);
						súbor.zapíšVlastnosť("zaoblenieY", zaoblenieY);
						súbor.zapíšVlastnosť("pôvodnáVeľkosť", pôvodnáVeľkosť);
						súbor.zapíšVlastnosť("pôvodnýPomer", pôvodnýPomer);
						súbor.zapíšVlastnosť("priehľadnosť",
							Double.valueOf(priehľadnosť));
						súbor.zapíšVlastnosť("vyplnený", vyplnený);

						if (aktívnePlátno == podlaha)
							súbor.zapíšVlastnosť("plátno", "podlaha");
						else if (aktívnePlátno == strop)
							súbor.zapíšVlastnosť("plátno", "strop");
						else
							súbor.zapíšVlastnosť("plátno", null);

						// Poznámka: Príznaky (ne)kreslenia dutých/vyplnených
						//     tvarov (kresliTvary a vypĺňajTvary) sú uložené
						//     v rámci nasledujúcej vlastnosti „kresli.“
						{
							String kresli = "";

							if (0 != (spôsobKreslenia & KRESLI_ROTOVANÉ))
								kresli += " | rotované";
							if (0 != (spôsobKreslenia & KRESLI_NA_STRED))
								kresli += " | centrované";

							if (vypĺňajTvary) kresli += " | vyplnené";
							if (kresliTvary) kresli += " | tvary";

							if (kresli.isEmpty())
								kresli = "priamo";
							else
								kresli = kresli.substring(3);

							súbor.zapíšVlastnosť("kresli", kresli);
						}

						/*
							// Starý zbytočne komplikovaný spôsob…

							if (kresliTvary && vypĺňajTvary)
								switch (spôsobKreslenia)
								{
								case KRESLI_PRIAMO:
									súbor.zapíšVlastnosť("kresli",
										"vyplnené tvary");
									break;

								case KRESLI_CENTROVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"centrované vyplnené tvary");
									break;

								case KRESLI_ROTOVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"rotované vyplnené tvary");
									break;

								default:
									súbor.zapíšVlastnosť("kresli",
										"rotované centrované vyplnené tvary");
								}
							else if (kresliTvary)
								switch (spôsobKreslenia)
								{
								case KRESLI_PRIAMO:
									súbor.zapíšVlastnosť("kresli",
										"tvary");
									break;

								case KRESLI_CENTROVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"centrované tvary");
									break;

								case KRESLI_ROTOVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"rotované tvary");
									break;

								default:
									súbor.zapíšVlastnosť("kresli",
										"rotované centrované tvary");
								}
							else if (vypĺňajTvary)
								switch (spôsobKreslenia)
								{
								case KRESLI_PRIAMO:
									súbor.zapíšVlastnosť("kresli",
										"vyplnené");
									break;

								case KRESLI_CENTROVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"centrované vyplnené");
									break;

								case KRESLI_ROTOVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"rotované vyplnené");
									break;

								default:
									súbor.zapíšVlastnosť("kresli",
										"rotované centrované vyplnené");
								}
							else
								switch (spôsobKreslenia)
								{
								case KRESLI_PRIAMO:
									súbor.zapíšVlastnosť("kresli",
										"priamo");
									break;

								case KRESLI_CENTROVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"centrované");
									break;

								case KRESLI_ROTOVANÉ:
									súbor.zapíšVlastnosť("kresli",
										"rotované");
									break;

								default:
									súbor.zapíšVlastnosť("kresli",
										"rotované centrované");
								}
						*/

						súbor.zapíšVlastnosť("vrstva", Long.valueOf(vrstva));

						súbor.zapíšVlastnosť("interaktívny", interaktívnyRežim);


						aktuálnePísmo.uložDoSúboru(súbor);


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".ohraničenie";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".ohraničenie";

						switch (aktuálneOhraničenie)
						{
						case ŽIADNE:
							súbor.zapíšVlastnosť("spôsob", "žiadne");
							break;

						case ODRAZ:
							súbor.zapíšVlastnosť("spôsob", "odraz");
							break;

						case PLOT:
							súbor.zapíšVlastnosť("spôsob", "plot");
							break;

						case PRETOČ:
							súbor.zapíšVlastnosť("spôsob", "pretoč");
							break;

						default:
							súbor.zapíšVlastnosť("spôsob", "neznáme");
						}

						switch (zálohovanéOhraničenie)
						{
						case ŽIADNE:
							súbor.zapíšVlastnosť("záloha", "žiadne");
							break;

						case ODRAZ:
							súbor.zapíšVlastnosť("záloha", "odraz");
							break;

						case PLOT:
							súbor.zapíšVlastnosť("záloha", "plot");
							break;

						case PRETOČ:
							súbor.zapíšVlastnosť("záloha", "pretoč");
							break;

						default:
							súbor.zapíšVlastnosť("záloha", "neznáme");
						}

						// switch (aktuálneOhraničenie)
						// {
						// case ODRAZ: case PLOT: case PRETOČ:
							súbor.zapíšVlastnosť("ľavé", ľaváHranica);
							súbor.zapíšVlastnosť("dolné", dolnáHranica);
							súbor.zapíšVlastnosť("pravé", praváHranica);
							súbor.zapíšVlastnosť("horné", hornáHranica);
						// }


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".pôsobisko";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".pôsobisko";

						súbor.zapíšVlastnosť("kresli", kresliPôsobisko);
						súbor.zapíšVlastnosť("minimum",
							Bod.polohaNaReťazec(minimálneX, minimálneY));
						súbor.zapíšVlastnosť("maximum",
							Bod.polohaNaReťazec(maximálneX, maximálneY));


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".doma";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".doma";

						súbor.zapíšVlastnosť("poloha",
							Bod.polohaNaReťazec(domaX, domaY));
						súbor.zapíšVlastnosť("uhol", uholDoma);
						súbor.zapíšVlastnosť("pootočenieTvaru",
							pootočenieTvaruDoma);

						súbor.zapíšVlastnosť("farba",
							null == farbaDoma ? null :
							Farba.farbaNaReťazec(farbaDoma));

						súbor.zapíšVlastnosť("cieľováFarba",
							null == cieľováFarbaDoma ? null :
							Farba.farbaNaReťazec(cieľováFarbaDoma));

						súbor.zapíšVlastnosť("zrušCieľovúFarbu",
							zrušCieľovúFarbuDoma);

						súbor.zapíšVlastnosť("hrúbkaPera", polomerPeraDoma);

						súbor.zapíšVlastnosť("peroPoložené", peroPoloženéDoma);
						súbor.zapíšVlastnosť("viditeľnosť", viditeľnýDoma);
						súbor.zapíšVlastnosť("veľkosť", veľkosťDoma);
						súbor.zapíšVlastnosť("pomer", pomerDoma);
						súbor.zapíšVlastnosť("priehľadnosť", priehľadnosťDoma);

						Písmo.uložDoSúboru(súbor, písmoDoma);


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".aktivita";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".aktivita";

						súbor.zapíšVlastnosť("aktívny", aktívny);
						súbor.zapíšVlastnosť("otáčanieTvaru", otáčanieTvaru);
						súbor.zapíšVlastnosť("gyroskop", gyroskop);
						súbor.zapíšVlastnosť("rýchlosť", rýchlosť);
						súbor.zapíšVlastnosť("rýchlosťPosunu", rýchlosťPosunu);
						súbor.zapíšVlastnosť("uhlováRýchlosť", uhlováRýchlosť);
						súbor.zapíšVlastnosť("maximálnaRýchlosť",
							maximálnaRýchlosť);
						súbor.zapíšVlastnosť("maximálnaRýchlosťPosunu",
							maximálnaRýchlosťPosunu);
						súbor.zapíšVlastnosť("maximálnaUhlováRýchlosť",
							maximálnaUhlováRýchlosť);
						súbor.zapíšVlastnosť("zrýchlenie", zrýchlenie);
						súbor.zapíšVlastnosť("zrýchleniePosunu",
							zrýchleniePosunu);
						súbor.zapíšVlastnosť("uhlovéZrýchlenie",
							uhlovéZrýchlenie);
						súbor.zapíšVlastnosť("trvanieAktivity",
							Long.valueOf(trvanieAktivity));
						súbor.zapíšVlastnosť("trvaniePasivity",
							Long.valueOf(trvaniePasivity));


						if (null == mennýPriestor)
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								menoRobota + ".cieľ";
						else
							súbor.aktívnaSekcia.mennýPriestorVlastností =
								mennýPriestor + "." + menoRobota + ".cieľ";

						súbor.zapíšVlastnosť("aktívny", cieľAktívny);
						súbor.zapíšVlastnosť("poloha",
							Bod.polohaNaReťazec(cieľX, cieľY));
						súbor.zapíšVlastnosť("zastavV", zastavVCieli);
						súbor.zapíšVlastnosť("zastavPoSpomalení",
							zastavPoSpomalení);
						súbor.zapíšVlastnosť("zastavPoSpomaleníPosunu",
							zastavPoSpomaleníPosunu);
					}
					finally
					{
						súbor.aktívnaSekcia.mennýPriestorVlastností =
							mennýPriestor;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #uložDoSúboru(Súbor) uložDoSúboru}.</p> */
				public void ulozDoSuboru(Súbor súbor) throws IOException
				{ uložDoSúboru(súbor); }


		// Základné aktivity

			// Smer a krokový pohyb v smere

				/**
				 * <p>Prikáže robotu, aby sa posunul dopredu o zadanú dĺžku
				 * v aktuálnom smere. Keď je pero položené, tak kreslí
				 * čiaru. Opakom je metóda {@link #vzad(double) vzad}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> V pôvodnom jazyku
				 * Logo (v anglickej verzii) sú ku každému príkazu pohybu
				 * korytnačky (z toho pochádza termín „korytnačia grafika“;
				 * korytnačku v tomto rámci nahrádza grafický robot)
				 * definované jeho dvojpísmenové skratky (fd – forward –
				 * dopredu; bk – backward – vzad; rt – right – vpravo; lt –
				 * left – vľavo). Pri preklade Loga do slovenčiny vznikali
				 * rôzne nejednoznačnosti, ktoré autori vyriešili ustálením
				 * nasledujúcich tvarov príkazov pohybu korytnačky:
				 * dopredu, vzad, vpravo a vľavo, ku ktorým prislúchajú skratky
				 * príkazov do, vz, vp a vľ. Ak chceme dodržať pravidlo
				 * vytvorenia skratky z prvých dvoch písmen, tak v slovenskom
				 * jazyku nenájdeme iné jednoznačné priradenie. V jazyku Java
				 * je však slovo {@code kwddo} rezervované. Preto
				 * v programovacom rámci GRobot nemôžu byť skratky pre tieto
				 * príkazy definované. Rozhodli sme sa aspoň definovať všetky
				 * aliasy príkazov pohybu: vpred, doprava, doľava a dozadu.</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú sa má robot posunúť
				 * 
				 * @see #dopredu() dopredu (bez zadania dĺžky)
				 * @see #vpred(double) (vpred)
				 * @see #vzad(double) vzad
				 * @see #dozadu(double) (dozadu)
				 * @see #vpravo(double) vpravo
				 * @see #doprava(double) (doprava)
				 * @see #vľavo(double) vľavo
				 * @see #doľava(double) (doľava)
				 * @see #choďNa(double, double) choďNa
				 * @see #skočNa(double, double) skočNa
				 * @see #choďPoOblúku(double, double) choďPoOblúku
				 * @see #skočPoOblúku(double, double) skočPoOblúku
				 * @see #zdvihniPero() zdvihniPero
				 * @see #položPero() položPero
				 */
				public void dopredu(double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(aktuálnyUhol)) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(aktuálnyUhol)) * dĺžka;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> dopredu(dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #dopredu(double) dopredu}.</p> */
				public void vpred(double dĺžka) { dopredu(dĺžka); }

				/**
				 * <p>Prikáže robotu, aby cúvol z aktuálneho miesta o zadanú
				 * dĺžku (v aktuálnom smere). Keď je pero položené, tak
				 * kreslí čiaru. Opakom je metóda {@link #dopredu(double)
				 * dopredu}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> V pôvodnom jazyku
				 * Logo (v anglickej verzii) sú ku každému príkazu pohybu
				 * korytnačky (z toho pochádza termín „korytnačia grafika“;
				 * korytnačku v tomto rámci nahrádza grafický robot)
				 * definované jeho dvojpísmenové skratky (fd – forward –
				 * dopredu; bk – backward – vzad; rt – right – vpravo; lt –
				 * left – vľavo). Pri preklade Loga do slovenčiny vznikali
				 * rôzne nejednoznačnosti, ktoré autori vyriešili ustálením
				 * nasledujúcich tvarov príkazov pohybu korytnačky:
				 * dopredu, vzad, vpravo a vľavo, ku ktorým prislúchajú skratky
				 * príkazov do, vz, vp a vľ. Ak chceme dodržať pravidlo
				 * vytvorenia skratky z prvých dvoch písmen, tak v slovenskom
				 * jazyku nenájdeme iné jednoznačné priradenie. V jazyku Java
				 * je však slovo {@code kwddo} rezervované. Preto
				 * v programovacom rámci GRobot nemôžu byť skratky pre tieto
				 * príkazy definované. Rozhodli sme sa aspoň definovať všetky
				 * aliasy príkazov pohybu: vpred, doprava, doľava a dozadu.</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú sa má robot posunúť
				 * 
				 * @see #vzad() vzad (bez zadania dĺžky)
				 * @see #dopredu(double) dopredu
				 * @see #vpred(double) (vpred)
				 * @see #dozadu(double) (dozadu)
				 * @see #vpravo(double) vpravo
				 * @see #doprava(double) (doprava)
				 * @see #vľavo(double) vľavo
				 * @see #doľava(double) (doľava)
				 * @see #choďNa(double, double) choďNa
				 * @see #skočNa(double, double) skočNa
				 * @see #choďPoOblúku(double, double) choďPoOblúku
				 * @see #skočPoOblúku(double, double) skočPoOblúku
				 * @see #zdvihniPero() zdvihniPero
				 * @see #položPero() položPero
				 */
				public void vzad(double dĺžka) { dopredu(-dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #vzad(double) vzad}.</p> */
				public void dozadu(double dĺžka) { dopredu(-dĺžka); }

				/**
				 * <p>Prikáže robotu, aby sa obrátil o zadaný uhol v smere
				 * hodinových ručičiek. Opakom je metóda {@link #vľavo(double)
				 * vľavo}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> V pôvodnom jazyku
				 * Logo (v anglickej verzii) sú ku každému príkazu pohybu
				 * korytnačky (z toho pochádza termín „korytnačia grafika“;
				 * korytnačku v tomto rámci nahrádza grafický robot)
				 * definované jeho dvojpísmenové skratky (fd – forward –
				 * dopredu; bk – backward – vzad; rt – right – vpravo; lt –
				 * left – vľavo). Pri preklade Loga do slovenčiny vznikali
				 * rôzne nejednoznačnosti, ktoré autori vyriešili ustálením
				 * nasledujúcich tvarov príkazov pohybu korytnačky:
				 * dopredu, vzad, vpravo a vľavo, ku ktorým prislúchajú skratky
				 * príkazov do, vz, vp a vľ. Ak chceme dodržať pravidlo
				 * vytvorenia skratky z prvých dvoch písmen, tak v slovenskom
				 * jazyku nenájdeme iné jednoznačné priradenie. V jazyku Java
				 * je však slovo {@code kwddo} rezervované. Preto
				 * v programovacom rámci GRobot nemôžu byť skratky pre tieto
				 * príkazy definované. Rozhodli sme sa aspoň definovať všetky
				 * aliasy príkazov pohybu: vpred, doprava, doľava a dozadu.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť
				 * 
				 * @see #vpravo() vpravo (bez zadania uhla)
				 * @see #dopredu(double) dopredu
				 * @see #vpred(double) (vpred)
				 * @see #vzad(double) vzad
				 * @see #dozadu(double) (dozadu)
				 * @see #doprava(double) (doprava)
				 * @see #vľavo(double) vľavo
				 * @see #doľava(double) (doľava)
				 * @see #otočNa(double, double)
				 * @see #choďPoOblúku(double, double) choďPoOblúku
				 * @see #skočPoOblúku(double, double) skočPoOblúku
				 */
				public void vpravo(double uhol)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol -= uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					// while (aktuálnyUhol > 360) aktuálnyUhol -= 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #vpravo(double) vpravo}.</p> */
				public void doprava(double uhol) { vpravo(uhol); }

				/**
				 * <p>Prikáže robotu, aby sa obrátil o zadaný uhol proti smeru
				 * hodinových ručičiek. Opakom je metóda {@link 
				 * #vpravo(double) vpravo}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> V pôvodnom jazyku
				 * Logo (v anglickej verzii) sú ku každému príkazu pohybu
				 * korytnačky (z toho pochádza termín „korytnačia grafika“;
				 * korytnačku v tomto rámci nahrádza grafický robot)
				 * definované jeho dvojpísmenové skratky (fd – forward –
				 * dopredu; bk – backward – vzad; rt – right – vpravo; lt –
				 * left – vľavo). Pri preklade Loga do slovenčiny vznikali
				 * rôzne nejednoznačnosti, ktoré autori vyriešili ustálením
				 * nasledujúcich tvarov príkazov pohybu korytnačky:
				 * dopredu, vzad, vpravo a vľavo, ku ktorým prislúchajú skratky
				 * príkazov do, vz, vp a vľ. Ak chceme dodržať pravidlo
				 * vytvorenia skratky z prvých dvoch písmen, tak v slovenskom
				 * jazyku nenájdeme iné jednoznačné priradenie. V jazyku Java
				 * je však slovo {@code kwddo} rezervované. Preto
				 * v programovacom rámci GRobot nemôžu byť skratky pre tieto
				 * príkazy definované. Rozhodli sme sa aspoň definovať všetky
				 * aliasy príkazov pohybu: vpred, doprava, doľava a dozadu.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť
				 * 
				 * @see #vľavo() vľavo (bez zadania uhla)
				 * @see #dopredu(double) dopredu
				 * @see #vpred(double) (vpred)
				 * @see #vzad(double) vzad
				 * @see #dozadu(double) (dozadu)
				 * @see #vpravo(double) vpravo
				 * @see #doprava(double) (doprava)
				 * @see #doľava(double) (doľava)
				 * @see #otočNa(double, double)
				 * @see #choďPoOblúku(double, double) choďPoOblúku
				 * @see #skočPoOblúku(double, double) skočPoOblúku
				 */
				public void vľavo(double uhol)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol += uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					// while (aktuálnyUhol > 360) aktuálnyUhol -= 360;
					// while (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #vľavo(double) vľavo}.</p> */
				public void vlavo(double uhol) { vľavo(uhol); }

				/** <p><a class="alias"></a> Alias pre {@link #vľavo(double) vľavo}.</p> */
				public void doľava(double uhol) { vľavo(uhol); }

				/** <p><a class="alias"></a> Alias pre {@link #doľava(double) doľava}.</p> */
				public void dolava(double uhol) { vľavo(uhol); }


				/**
				 * <p>Prikáže robotu, aby sa posunul v aktuálnom smere
				 * dopredu o hodnotu svojej {@linkplain #veľkosť() veľkosti}.
				 * Keď je pero položené, tak kreslí čiaru. Opakom je metóda
				 * {@link #vzad() vzad}. (Pozri aj metódu {@link 
				 * #dopredu(double) dopredu(dĺžka)}.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Cieľom tejto metódy je
				 * zjednodušiť pohyb robota v interaktívnom režime, kde
				 * fungujú aj skratky základných príkazov na pohyb: dopredu –
				 * {@code do}, vzad – {@code vz}, vpravo – {@code vp} a vľavo –
				 * {@code vľ}/{@code vl}. Samozrejme, že jej použitiu nič
				 * nebráni ani pri „klasickom“ programovaní s použitím
				 * programovacieho rámca GRobot.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @see #dopredu(double) dopredu(dĺžka)
				 * @see #vpred() (vpred)
				 * @see #vzad() vzad
				 * @see #dozadu() (dozadu)
				 * @see #vpravo() vpravo
				 * @see #doprava() (doprava)
				 * @see #vľavo() vľavo
				 * @see #doľava() (doľava)
				 * @see #zdvihniPero() zdvihniPero
				 * @see #položPero() položPero
				 */
				public void dopredu() { dopredu(veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #dopredu() dopredu}.</p> */
				public void vpred() { dopredu(veľkosť); }

				/**
				 * <p>Prikáže robotu, aby cúvol z aktuálneho miesta o hodnotu
				 * svojej {@linkplain #veľkosť() veľkosti} (v aktuálnom
				 * smere). Keď je pero položené, tak kreslí čiaru. Opakom je
				 * metóda {@link #dopredu() dopredu}.
				 * (Pozri aj metódu {@link #vzad(double) vzad(dĺžka)}.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Cieľom tejto metódy je
				 * zjednodušiť pohyb robota v interaktívnom režime, kde
				 * fungujú aj skratky základných príkazov na pohyb: dopredu –
				 * {@code do}, vzad – {@code vz}, vpravo – {@code vp} a vľavo –
				 * {@code vľ}/{@code vl}. Samozrejme, že jej použitiu nič
				 * nebráni ani pri „klasickom“ programovaní s použitím
				 * programovacieho rámca GRobot.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @see #vzad(double) vzad(dĺžka)
				 * @see #dopredu() dopredu
				 * @see #vpred() (vpred)
				 * @see #dozadu() (dozadu)
				 * @see #vpravo() vpravo
				 * @see #doprava() (doprava)
				 * @see #vľavo() vľavo
				 * @see #doľava() (doľava)
				 * @see #zdvihniPero() zdvihniPero
				 * @see #položPero() položPero
				 */
				public void vzad() { dopredu(-veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #vzad() vzad}.</p> */
				public void dozadu() { dopredu(-veľkosť); }

				/**
				 * <p>Prikáže robotu, aby sa obrátil o {@linkplain 
				 * #uholOtáčania() uhol otáčania} (predvolene 45° – s ohľadom
				 * na definície <a href="hodnoty-konstant.html#Smer.JUH">hodnôt
				 * konštát</a> v rozhraní {@link Smer Smer}) v smere
				 * hodinových ručičiek. Opakom je metóda {@link #vľavo()
				 * vľavo}.
				 * (Pozri aj metódu {@link #vpravo(double) vpravo(uhol)}.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Cieľom tejto metódy je
				 * zjednodušiť pohyb robota v interaktívnom režime, kde
				 * fungujú aj skratky základných príkazov na pohyb: dopredu –
				 * {@code do}, vzad – {@code vz}, vpravo – {@code vp} a vľavo –
				 * {@code vľ}/{@code vl}. Samozrejme, že jej použitiu nič
				 * nebráni ani pri „klasickom“ programovaní s použitím
				 * programovacieho rámca GRobot.</p>
				 * 
				 * @see #vpravo(double) vpravo(uhol)
				 * @see #uholOtáčania(double) uholOtáčania(uhol)
				 * @see #dopredu() dopredu
				 * @see #vpred() (vpred)
				 * @see #vzad() vzad
				 * @see #dozadu() (dozadu)
				 * @see #doprava() (doprava)
				 * @see #vľavo() vľavo
				 * @see #doľava() (doľava)
				 */
				public void vpravo() { vpravo(uholOtáčania); }

				/** <p><a class="alias"></a> Alias pre {@link #vpravo() vpravo}.</p> */
				public void doprava() { vpravo(uholOtáčania); }

				/**
				 * <p>Prikáže robotu, aby sa obrátil o {@linkplain 
				 * #uholOtáčania() uhol otáčania} (predvolene 45° – s ohľadom
				 * na definície <a href="hodnoty-konstant.html#Smer.JUH">hodnôt
				 * konštát</a> v rozhraní {@link Smer Smer}) proti
				 * smeru hodinových ručičiek. Opakom je metóda {@link 
				 * #vpravo() vpravo}.
				 * (Pozri aj metódu {@link #vľavo(double) vľavo(uhol)}.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Cieľom tejto metódy je
				 * zjednodušiť pohyb robota v interaktívnom režime, kde
				 * fungujú aj skratky základných príkazov na pohyb: dopredu –
				 * {@code do}, vzad – {@code vz}, vpravo – {@code vp} a vľavo –
				 * {@code vľ}/{@code vl}. Samozrejme, že jej použitiu nič
				 * nebráni ani pri „klasickom“ programovaní s použitím
				 * programovacieho rámca GRobot.</p>
				 * 
				 * @see #vľavo(double) vľavo(uhol)
				 * @see #uholOtáčania(double) uholOtáčania(uhol)
				 * @see #dopredu() dopredu
				 * @see #vpred() (vpred)
				 * @see #vzad() vzad
				 * @see #dozadu() (dozadu)
				 * @see #vpravo() vpravo
				 * @see #doprava() (doprava)
				 * @see #doľava() (doľava)
				 */
				public void vľavo() { vľavo(uholOtáčania); }

				/** <p><a class="alias"></a> Alias pre {@link #vľavo() vľavo}.</p> */
				public void vlavo() { vľavo(uholOtáčania); }

				/** <p><a class="alias"></a> Alias pre {@link #vľavo() vľavo}.</p> */
				public void doľava() { vľavo(uholOtáčania); }

				/** <p><a class="alias"></a> Alias pre {@link #doľava() doľava}.</p> */
				public void dolava() { vľavo(uholOtáčania); }


				/**
				 * <p>Prikáže robotu, aby preskočil dopredu o zadanú dĺžku
				 * v aktuálnom smere. Robot pri skákaní nekreslí čiaru.
				 * Opakom je metóda {@link #odskoč(double) odskoč}.
				 * (Pozri aj metódu {@link #skoč() skoč()}.)</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú má robot preskočiť
				 * 
				 * @see #dopredu(double) dopredu
				 */
				public void skoč(double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(aktuálnyUhol)) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(aktuálnyUhol)) * dĺžka;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> skoč(dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skoč(double) skoč}.</p> */
				public void skoc(double dĺžka) { skoč(dĺžka); }

				/**
				 * <p>Prikáže robotu, aby skokom cúvol z aktuálneho miesta
				 * o zadanú dĺžku (v aktuálnom smere). Robot pri skákaní
				 * nekreslí čiaru. Opakom je metóda {@link #skoč(double) skoč}.
				 * (Pozri aj metódu {@link #odskoč() odskoč()}.)</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú má robot preskočiť
				 * 
				 * @see #vzad(double) vzad
				 */
				public void odskoč(double dĺžka) { skoč(-dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #odskoč(double) odskoč}.</p> */
				public void odskoc(double dĺžka) { skoč(-dĺžka); }


				/**
				 * <p>Prikáže robotu, aby preskočil v aktuálnom smere dopredu
				 * o hodnotu svojej {@linkplain #veľkosť() veľkosti}. Robot
				 * pri skákaní nekreslí čiaru. Opakom je metóda
				 * {@link #odskoč() odskoč}.
				 * (Pozri aj metódu {@link #skoč(double) skoč(dĺžka)}.)</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @see #dopredu() dopredu
				 */
				public void skoč() { skoč(veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #skoč() skoč}.</p> */
				public void skoc() { skoč(veľkosť); }

				/**
				 * <p>Prikáže robotu, aby skokom cúvol z aktuálneho miesta
				 * o hodnotu svojej {@linkplain #veľkosť() veľkosti}
				 * (v aktuálnom smere). Robot pri skákaní nekreslí čiaru.
				 * Opakom je metóda {@link #skoč() skoč}.
				 * (Pozri aj metódu {@link #odskoč(double) odskoč(dĺžka)}.)</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @see #vzad() vzad
				 */
				public void odskoč() { skoč(-veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #odskoč() odskoč}.</p> */
				public void odskoc() { skoč(-veľkosť); }


				/**
				 * <p>Otočí robot o zadaný uhol (proti smeru hodinových
				 * ručičiek). Má rovnaký efekt, ako keby sme volali metódu
				 * {@link #vľavo(double) vľavo}.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť
				 * 
				 * @see #otoč(double)
				 * @see #otočO(double, double)
				 */
				public void otočO(double uhol)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol += uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					// while (aktuálnyUhol > 360) aktuálnyUhol -= 360;
					// while (aktuálnyUhol < 0) aktuálnyUhol += 360;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočO(double) otoč}.</p> */
				public void otocO(double uhol) { otočO(uhol); }


				/**
				 * <p>Otočí robot o zadaný uhol s kontrolou maximálneho
				 * dovoleného uhla pootočenia. Volanie tejto metódy má zmysel
				 * v prípade použitia premennej, ktorej hodnotu chceme
				 * obmedziť. Ak je absolútna hodnota uhla väčia ako absolútna
				 * hodnota obmedzenia (parametrom {@code najviacO}), tak je
				 * hodnota uhla otáčania „orezaná“ (nastavená na hodnotu
				 * {@code najviacO} so zachovaním znamienka, ktoré určuje
				 * smer otáčania).</p>
				 * 
				 * <p>Kladná hodnota uhla otáčania značí otáčanie proti smeru
				 * hodinových ručičiek. Znamienko hodnoty obmedzenia je
				 * ignorované.</p>
				 * 
				 * <p>Porovnaj s metódu {@link #otočO(double) otočO}.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť
				 * @param najviacO obmedzenie učujúce maximálnu povolenú
				 *     hodnota uhla otáčania
				 * 
				 * @see #otočO(double)
				 */
				public void otočO(double uhol, double najviacO)
				{
					if (najviacO < 0) najviacO = -najviacO;
					if (uhol > 0 && uhol > najviacO) uhol = najviacO;
					if (uhol < 0 && uhol < -najviacO) uhol = -najviacO;

					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol += uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočO(double, double) otoč}.</p> */
				public void otocO(double uhol, double najviacO) { otočO(uhol, najviacO); }


				/**
				 * <p>Prikáže robotu, aby sa posunul vpravo o zadanú dĺžku
				 * (vzhľadom na aktuálnu orientáciu). Robot zostane
				 * obrátený tam, kam bol. Keď je pero položené, tak kreslí
				 * čiaru. Protikladom je metóda {@link #posuňVľavo(double)
				 * posuňVľavo}.</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú sa má robot posunúť
				 */
				public void posuňVpravo(double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(aktuálnyUhol - 90)) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(aktuálnyUhol - 90)) * dĺžka;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							posuňVpravo(dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuňVpravo(double) posuňVpravo}.</p> */
				public void posunVpravo(double dĺžka) { posuňVpravo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVpravo(double) posuňVpravo}.</p> */
				public void posuňDoprava(double dĺžka) { posuňVpravo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňDoprava(double) posuňDoprava}.</p> */
				public void posunDoprava(double dĺžka) { posuňVpravo(dĺžka); }

				/**
				 * <p>Prikáže robotu, aby sa posunul vľavo o zadanú dĺžku
				 * (vzhľadom na aktuálnu orientáciu). Robot zostane obrátený
				 * tam, kam bol. Keď je pero položené, tak kreslí čiaru.
				 * Protikladom je metóda {@link #posuňVpravo(double)
				 * posuňVpravo}.</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú sa má robot posunúť
				 */
				public void posuňVľavo(double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(aktuálnyUhol + 90)) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(aktuálnyUhol + 90)) * dĺžka;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							posuňVľavo(dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuňVľavo(double) posuňVľavo}.</p> */
				public void posunVlavo(double dĺžka) { posuňVľavo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVľavo(double) posuňVľavo}.</p> */
				public void posuňDoľava(double dĺžka) { posuňVľavo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňDoľava(double) posuňDoľava}.</p> */
				public void posunDolava(double dĺžka) { posuňVľavo(dĺžka); }

				/**
				 * <p>Prikáže robotu, aby sa posunul vpravo o hodnotu svojej
				 * {@linkplain #veľkosť() veľkosti} násobenej {@linkplain 
				 * #pomer() pomerom} (vzhľadom na aktuálnu orientáciu). Robot
				 * zostane obrátený tam, kam bol. Keď je pero položené, tak
				 * kreslí čiaru. Protikladom je metóda {@link #posuňVľavo()
				 * posuňVľavo}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 */
				public void posuňVpravo() { posuňVpravo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVpravo() posuňVpravo}.</p> */
				public void posunVpravo() { posuňVpravo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVpravo() posuňVpravo}.</p> */
				public void posuňDoprava() { posuňVpravo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňDoprava() posuňDoprava}.</p> */
				public void posunDoprava() { posuňVpravo(veľkosť * pomerVeľkosti); }

				/**
				 * <p>Prikáže robotu, aby sa posunul vľavo o hodnotu svojej
				 * {@linkplain #veľkosť() veľkosti} násobenej {@linkplain 
				 * #pomer() pomerom} (vzhľadom na aktuálnu orientáciu). Robot
				 * zostane obrátený tam, kam bol. Keď je pero položené, tak
				 * kreslí čiaru. Protikladom je metóda {@link #posuňVpravo()
				 * posuňVpravo}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 */
				public void posuňVľavo() { posuňVľavo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVľavo() posuňVľavo}.</p> */
				public void posunVlavo() { posuňVľavo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVľavo() posuňVľavo}.</p> */
				public void posuňDoľava() { posuňVľavo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňDoľava() posuňDoľava}.</p> */
				public void posunDolava() { posuňVľavo(veľkosť * pomerVeľkosti); }


				/**
				 * <p>Prikáže robotu, aby sa posunul v zadanom smere
				 * o zadanú dĺžku. Robot zostane obrátený tam, kam bol. Keď
				 * je pero položené, tak kreslí čiaru.</p>
				 * 
				 * @param smer uhol smeru, ktorým sa má robot posunúť
				 * @param dĺžka vzdialenosť, o ktorú sa má robot posunúť
				 * 
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void posuňVSmere(double smer, double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(toRadians(smer)) * dĺžka;
					double novéY = aktuálneY + sin(toRadians(smer)) * dĺžka;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							posuňVSmere(smer, dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuňVSmere(double, double) posuňVSmere}.</p> */
				public void posunVSmere(double smer, double dĺžka)
				{ posuňVSmere(smer, dĺžka); }

				/**
				 * <p>Prikáže robotu, aby sa posunul v zadanom smere
				 * o hodnotu svojej {@linkplain #veľkosť() veľkosti}. Robot
				 * zostane obrátený tam, kam bol. Keď je pero položené, tak
				 * kreslí čiaru.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param smer uhol smeru, ktorým sa má robot posunúť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void posuňVSmere(double smer)
				{ posuňVSmere(smer, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVSmere(double) posuňVSmere}.</p> */
				public void posunVSmere(double smer)
				{ posuňVSmere(smer, veľkosť); }

				/**
				 * <p>Prikáže robotu, aby sa posunul v zadanom smere
				 * o zadanú dĺžku. Robot zostane obrátený tam, kam bol. Keď
				 * je pero položené, tak kreslí čiaru.</p>
				 * 
				 * @param smer inštancia určujúca smer, ktorým sa má robot
				 *     posunúť
				 * @param dĺžka vzdialenosť, o ktorú sa má robot posunúť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void posuňVSmere(Smer smer, double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(smer.smer())) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(smer.smer())) * dĺžka;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							posuňVSmere(smer.smer(), dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuňVSmere(Smer, double) posuňVSmere}.</p> */
				public void posunVSmere(Smer smer, double dĺžka)
				{ posuňVSmere(smer, dĺžka); }

				/**
				 * <p>Prikáže robotu, aby sa posunul v zadanom smere
				 * o hodnotu svojej {@linkplain #veľkosť() veľkosti}. Robot
				 * zostane obrátený tam, kam bol. Keď je pero položené, tak
				 * kreslí čiaru.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param smer inštancia určujúca smer, ktorým sa má robot
				 *     posunúť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #preskočVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void posuňVSmere(Smer smer)
				{ posuňVSmere(smer, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňVSmere(Smer) posuňVSmere}.</p> */
				public void posunVSmere(Smer smer)
				{ posuňVSmere(smer, veľkosť); }


				/**
				 * <p>Prikáže robotu, aby preskočil vpravo o zadanú dĺžku
				 * (vzhľadom na aktuálnu orientáciu). Robot zostane obrátený
				 * tam, kam bol a pri skákaní nekreslí čiaru. Protikladom je
				 * metóda {@link #preskočVľavo(double) preskočVľavo}.</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú má robot preskočiť
				 */
				public void preskočVpravo(double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(aktuálnyUhol - 90)) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(aktuálnyUhol - 90)) * dĺžka;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							preskočVpravo(dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #preskočVpravo(double) preskočVpravo}.</p> */
				public void preskocVpravo(double dĺžka) { preskočVpravo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVpravo(double) preskočVpravo}.</p> */
				public void preskočDoprava(double dĺžka) { preskočVpravo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočDoprava(double) preskočDoprava}.</p> */
				public void preskocDoprava(double dĺžka) { preskočVpravo(dĺžka); }

				/**
				 * <p>Prikáže robotu, aby preskočil vľavo o zadanú dĺžku
				 * (vzhľadom na aktuálnu orientáciu). Robot zostane obrátený
				 * tam, kam bol a pri skákaní nekreslí čiaru.
				 * Protikladom je metóda {@link #preskočVpravo(double)
				 * preskočVpravo}.</p>
				 * 
				 * @param dĺžka vzdialenosť, o ktorú má robot preskočiť
				 */
				public void preskočVľavo(double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(aktuálnyUhol + 90)) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(aktuálnyUhol + 90)) * dĺžka;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							preskočVľavo(dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #preskočVľavo(double) preskočVľavo}.</p> */
				public void preskocVlavo(double dĺžka) { preskočVľavo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVľavo(double) preskočVľavo}.</p> */
				public void preskočDoľava(double dĺžka) { preskočVľavo(dĺžka); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočDoľava(double) preskočDoľava}.</p> */
				public void preskocDolava(double dĺžka) { preskočVľavo(dĺžka); }

				/**
				 * <p>Prikáže robotu, aby preskočil vpravo o hodnotu svojej
				 * {@linkplain #veľkosť() veľkosti} násobenej {@linkplain 
				 * #pomer() pomerom} (vzhľadom na aktuálnu orientáciu). Robot
				 * zostane obrátený tam, kam bol a pri skákaní nekreslí čiaru.
				 * Protikladom je metóda {@link #preskočVľavo()
				 * preskočVľavo}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 */
				public void preskočVpravo() { preskočVpravo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVpravo() preskočVpravo}.</p> */
				public void preskocVpravo() { preskočVpravo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVpravo() preskočVpravo}.</p> */
				public void preskočDoprava() { preskočVpravo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočDoprava() preskočDoprava}.</p> */
				public void preskocDoprava() { preskočVpravo(veľkosť * pomerVeľkosti); }

				/**
				 * <p>Prikáže robotu, aby preskočil vľavo o hodnotu svojej
				 * {@linkplain #veľkosť() veľkosti} násobenej {@linkplain 
				 * #pomer() pomerom} (vzhľadom na aktuálnu orientáciu). Robot
				 * zostane obrátený tam, kam bol a pri skákaní nekreslí čiaru.
				 * Protikladom je metóda {@link #preskočVpravo()
				 * preskočVpravo}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 */
				public void preskočVľavo() { preskočVľavo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVľavo() preskočVľavo}.</p> */
				public void preskocVlavo() { preskočVľavo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVľavo() preskočVľavo}.</p> */
				public void preskočDoľava() { preskočVľavo(veľkosť * pomerVeľkosti); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočDoľava() preskočDoľava}.</p> */
				public void preskocDolava() { preskočVľavo(veľkosť * pomerVeľkosti); }


				/**
				 * <p>Prikáže robotu, aby preskočil v zadanom smere
				 * o zadanú dĺžku. Robot zostane obrátený tam, kam bol
				 * a pri skákaní nekreslí čiaru.</p>
				 * 
				 * @param smer uhol smeru, ktorým má robot skočiť
				 * @param dĺžka vzdialenosť, o ktorú má robot preskočiť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void preskočVSmere(double smer, double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(toRadians(smer)) * dĺžka;
					double novéY = aktuálneY + sin(toRadians(smer)) * dĺžka;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							preskočVSmere(smer, dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #preskočVSmere(double, double) preskočVSmere}.</p> */
				public void preskocVSmere(double smer, double dĺžka)
				{ preskočVSmere(smer, dĺžka); }

				/**
				 * <p>Prikáže robotu, aby preskočil v zadanom smere o hodnotu
				 * svojej {@linkplain #veľkosť() veľkosti}. Robot zostane
				 * obrátený tam, kam bol a pri skákaní nekreslí čiaru.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param smer uhol smeru, ktorým má robot skočiť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(Smer)
				 * @see #posuňVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void preskočVSmere(double smer)
				{ preskočVSmere(smer, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVSmere(double) preskočVSmere}.</p> */
				public void preskocVSmere(double smer)
				{ preskočVSmere(smer, veľkosť); }

				/**
				 * <p>Prikáže robotu, aby preskočil v zadanom smere
				 * o zadanú dĺžku. Robot zostane obrátený tam, kam bol
				 * a pri skákaní nekreslí čiaru.</p>
				 * 
				 * @param smer inštancia určujúca smer, ktorým má robot skočiť
				 * @param dĺžka vzdialenosť, o ktorú má robot preskočiť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void preskočVSmere(Smer smer, double dĺžka)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX + cos(
						toRadians(smer.smer())) * dĺžka;
					double novéY = aktuálneY + sin(
						toRadians(smer.smer())) * dĺžka;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							preskočVSmere(smer.smer(), dĺžka));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #preskočVSmere(Smer, double) preskočVSmere}.</p> */
				public void preskocVSmere(Smer smer, double dĺžka)
				{ preskočVSmere(smer, dĺžka); }

				/**
				 * <p>Prikáže robotu, aby preskočil v zadanom smere o hodnotu
				 * svojej {@linkplain #veľkosť() veľkosti}. Robot zostane
				 * obrátený tam, kam bol a pri skákaní nekreslí čiaru.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param smer inštancia určujúca smer, ktorým má robot skočiť
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * 
				 * @see #posuň(double, double)
				 * @see #preskoč(double, double)
				 */
				public void preskočVSmere(Smer smer)
				{ preskočVSmere(smer, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #preskočVSmere(Smer) preskočVSmere}.</p> */
				public void preskocVSmere(Smer smer)
				{ preskočVSmere(smer, veľkosť); }


				/**
				 * <p>Zistí smer (uhol) z aktuálneho miesta robota smerom na
				 * zadané súradnice [x, y]. Ak sú súradnice bodu zhodné so
				 * súradnicami robota, je vrátená hodnota uhla 360.</p>
				 * 
				 * @param x x-ová súradnica bodu
				 * @param y y-ová súradnica bodu
				 * @return hodnota uhla určujúceho smer od robota
				 *     k zadanému bodu
				 * 
				 * @see #smer()
				 * @see #uhol()
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 * @see #otočNa(double, double, double)
				 */
				public double smerNa(double x, double y)
				{
					double Δx = x - aktuálneX;  // delta x – rozdiel súradníc x
					double Δy = y - aktuálneY;  // delta y – rozdiel súradníc y

					if (Δx == 0 && Δy == 0) return 360;

					/*
					else if (Δx == 0 && Δy < 0) return 270;
					else if (Δx == 0 && Δy > 0) return 90;
					else if (Δx > 0 && Δy == 0) return 0;
					else if (Δx < 0 && Δy == 0) return 180;

					double α = toDegrees(atan(Δy / Δx));
					if (Δx < 0) return 180 + α;
					if (Δy < 0) return 360 + α;
					*/

					double α = toDegrees(atan2(Δy, Δx));
					if (α < 0) return 360 + α;
					return α;
				}

				/** <p><a class="alias"></a> Alias pre {@link #smerNa(double, double) smerNa}.</p> */
				public double uholNa(double x, double y) { return smerNa(x, y); }


				/**
				 * <p>Zistí smer (uhol) z aktuálneho miesta robota smerom ku
				 * zadanému objektu. Ak sú polohy robota a objektu zhodné, je
				 * vrátená hodnota uhla 360. (Cieľový objekt nemusí byť
				 * viditeľný.)</p>
				 * 
				 * @param objekt objekt vzhľadom ku ktorému bude zistená
				 *     orientácia
				 * @return hodnota uhla určujúceho smer od robota
				 *     ku zadanému objektu
				 * 
				 * @see #smer()
				 * @see #uhol()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 * @see #otočNa(Poloha)
				 * @see #otočNa(Poloha, double)
				 */
				public double smerNa(Poloha objekt)
				{
					double Δx = objekt.polohaX() - aktuálneX;
						// delta x – rozdiel súradníc x
					double Δy = objekt.polohaY() - aktuálneY;
						// delta y – rozdiel súradníc y

					if (Δx == 0 && Δy == 0) return 360;

					/*
					else if (Δx == 0 && Δy < 0) return 270;
					else if (Δx == 0 && Δy > 0) return 90;
					else if (Δx > 0 && Δy == 0) return 0;
					else if (Δx < 0 && Δy == 0) return 180;

					double α = toDegrees(atan(Δy / Δx));
					if (Δx < 0) return 180 + α;
					if (Δy < 0) return 360 + α;
					*/

					double α = toDegrees(atan2(Δy, Δx));
					if (α < 0) return 360 + α;
					return α;
				}

				/** <p><a class="alias"></a> Alias pre {@link #smerNa(Poloha) smerNa}.</p> */
				public double uholNa(Poloha objekt) { return smerNa(objekt); }


				/**
				 * <p>Zistí smer (uhol) z aktuálneho miesta robota smerom do,
				 * stredu hraníc<sup>[1]</sup> zadaného tvaru. Ak je poloha
				 * robota zhodná so stredom hraníc tvaru, je vrátená hodnota
				 * uhla 360.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * @param tvar tvar Javy ({@link Shape Shape}), ku stredu
				 *     hraníc ktorého má byť zistený smer
				 * @return hodnota uhla určujúceho smer od robota ku
				 *     zadanému tvaru
				 * 
				 * @see #smer()
				 * @see #uhol()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 * @see #otočNa(Shape)
				 * @see #otočNa(Shape, double)
				 */
				public double smerNa(Shape tvar)
				{
					Rectangle2D hranice = tvar.getBounds2D();
					double Δx = (Svet.prepočítajSpäťX(hranice.getX()) +
						hranice.getWidth() / 2) - aktuálneX;
					double Δy = (Svet.prepočítajSpäťY(hranice.getY()) -
						hranice.getHeight() / 2) - aktuálneY;

					if (Δx == 0 && Δy == 0) return 360;

					/*
					else if (Δx == 0 && Δy < 0) return 270;
					else if (Δx == 0 && Δy > 0) return 90;
					else if (Δx > 0 && Δy == 0) return 0;
					else if (Δx < 0 && Δy == 0) return 180;

					double α = toDegrees(atan(Δy / Δx));
					if (Δx < 0) return 180 + α;
					if (Δy < 0) return 360 + α;
					*/

					double α = toDegrees(atan2(Δy, Δx));
					if (α < 0) return 360 + α;
					return α;
				}

				/** <p><a class="alias"></a> Alias pre {@link #smerNa(Shape) smerNa}.</p> */
				public double uholNa(Shape tvar) { return smerNa(tvar); }


				/**
				 * <p>Zistí smer (uhol) z aktuálneho miesta robota smerom
				 * k aktuálnym súradniciam myši. Ak sú súradnice myši zhodné
				 * so súradnicami robota, je vrátená hodnota uhla 360.</p>
				 * 
				 * @return hodnota uhla určujúceho smer od robota
				 *     k aktuálnym súradniciam myši
				 * 
				 * @see #smer()
				 * @see #uhol()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 * @see #otočNaMyš()
				 * @see #otočNaMyš(double)
				 */
				public double smerNaMyš()
				{
					double Δx = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double Δy = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					if (Δx == 0 && Δy == 0) return 360;

					/*
					else if (Δx == 0 && Δy < 0) return 270;
					else if (Δx == 0 && Δy > 0) return 90;
					else if (Δx > 0 && Δy == 0) return 0;
					else if (Δx < 0 && Δy == 0) return 180;

					double α = toDegrees(atan(Δy / Δx));
					if (Δx < 0) return 180 + α;
					if (Δy < 0) return 360 + α;
					*/

					double α = toDegrees(atan2(Δy, Δx));
					if (α < 0) return 360 + α;
					return α;
				}

				/** <p><a class="alias"></a> Alias pre {@link #smerNaMyš() smerNaMyš}.</p> */
				public double smerNaMys() { return smerNaMyš(); }

				/** <p><a class="alias"></a> Alias pre {@link #smerNaMyš() smerNaMyš}.</p> */
				public double uholNaMyš() { return smerNaMyš(); }

				/** <p><a class="alias"></a> Alias pre {@link #smerNaMyš() smerNaMyš}.</p> */
				public double uholNaMys() { return smerNaMyš(); }


				/**
				 * <p>Zistí smer k bodu zadanému s pomocou odchýlok súradníc
				 * v horizontálnom a vertikáklom smere [Δx, Δy]. Ak sú zadané
				 * súradnice [0, 0], metóda vráti hodnotu 360. Efekt je
				 * rovnaký, ako keby robot stál v bode [0, 0] a použili by sme
				 * s rovnakými hodnotami metódu {@link #smerNa(double, double)
				 * smerNa}. (Inak povedané – táto metóda pracuje s tzv.
				 * relatívnymi súradnicami – súradnicami vztiahnutými
				 * k súčasnej polohe robota.)</p>
				 * 
				 * @param Δx odchýlka v smere osi x
				 * @param Δy odchýlka v smere osi y
				 * @return hodnota uhla určujúceho smer od stredu
				 *     súradnicovej sústavy k zadanému bodu
				 * 
				 * @see #smer()
				 * @see #uhol()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #uhol(double, double)
				 * @see #otočNa(double, double)
				 */
				public /*static*/ double smer(double Δx, double Δy)
				{
					if (Δx == 0 && Δy == 0) return 360;

					/*
					else if (Δx == 0 && Δy < 0) return 270;
					else if (Δx == 0 && Δy > 0) return 90;
					else if (Δx > 0 && Δy == 0) return 0;
					else if (Δx < 0 && Δy == 0) return 180;

					double α = toDegrees(atan(Δy / Δx));
					if (Δx < 0) return 180 + α;
					if (Δy < 0) return 360 + α;
					*/

					double α = toDegrees(atan2(Δy, Δx));
					if (α < 0) return 360 + α;
					return α;
				}

				/** <p><a class="alias"></a> Alias pre {@link #smer(double, double) smer}.</p> */
				public /*static*/ double uhol(double Δx, double Δy) { return smer(Δx, Δy); }


				/**
				 * <p>Nasmeruje robot smerom na zadané súradnice [x, y] na
				 * podlahe (strope). Ak sú súradnice bodu zhodné so
				 * súradnicami robota, smer robota sa nezmení. Inak je
				 * vypočítaný uhol smeru medzi aktuálnou polohou robota
				 * a zadaným bodom, ktorý je použitý na nasmerovanie robota.</p>
				 * 
				 * @param x x-ová súradnica bodu
				 * @param y y-ová súradnica bodu
				 * 
				 * @see #smer()
				 * @see #uhol()
				 * @see #smerNa(double, double)
				 * @see #uholNa(double, double)
				 * @see #smerNa(Poloha)
				 * @see #uholNa(Poloha)
				 * @see #smerNa(Shape)
				 * @see #uholNa(Shape)
				 * @see #smerNaMyš()
				 * @see #uholNaMyš()
				 * @see #smer(double, double)
				 * @see #uhol(double, double)
				 */
				public void otočNa(double x, double y)
				{
					double Δx = x - aktuálneX;  // delta x – rozdiel súradníc x
					double Δy = y - aktuálneY;  // delta y – rozdiel súradníc y

					if (Δx == 0 && Δy == 0) return;
					// else if (Δx == 0 && Δy < 0) aktuálnyUhol = 270;
					// else if (Δx == 0 && Δy > 0) aktuálnyUhol = 90;
					// else if (Δx > 0 && Δy == 0) aktuálnyUhol = 0;
					// else if (Δx < 0 && Δy == 0) aktuálnyUhol = 180;
					else
					{
						/*
						double α = toDegrees(atan(Δy / Δx));

						if (Δx < 0)
							aktuálnyUhol = 180 + α;
						else if (Δy < 0)
							aktuálnyUhol = 360 + α;
						else
							aktuálnyUhol = α;
						*/

						poslednýUhol = aktuálnyUhol;
						aktuálnyUhol = toDegrees(atan2(Δy, Δx));
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNa(double, double) otočNa}.</p> */
				public void otocNa(double x, double y) { otočNa(x, y); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otočNa(double, double)
				 * otočNa}, ibaže obmedzuje uhol pootočenia stanoveným smerom –
				 * neotočí robot okamžite smerom na zadané súradnice, iba ním
				 * pootočí stanoveným smerom o maximálnu zadanú hodnotu uhla.</p>
				 * 
				 * @param x x-ová súradnica bodu
				 * @param y y-ová súradnica bodu
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     robot otočiť smerom k bodu [x, y]
				 * 
				 * @see #smerNa(double, double)
				 */
				public void otočNa(double x, double y, double najviacO)
				{
					double α = smerNa(x, y);
					if (α == 360) return;
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNa(double, double, double) otočNa}.</p> */
				public void otocNa(double x, double y, double najviacO)
				{ otočNa(x, y, najviacO); }


				// /**
				//  * <p>Nasmeruje robot smerom na zadané súradnice na podlahe
				//  * (strope). Ak sú súradnice bodu zhodné so súradnicami
				//  * robota, smer robota sa nezmení. Inak je vypočítaný uhol
				//  * smeru medzi aktuálnou polohou robota a zadaným bodom,
				//  * ktorý je použitý na nasmerovanie robota.</p>
				//  * 
				//  * @param bod súradnice bodu
				//  * @see #smerNa(Point2D)
				//  */
				// public void otočNa(Point2D bod)
				// {
				// 	double Δx = bod.getX() - aktuálneX;
				// 	double Δy = bod.getY() - aktuálneY;
				// 
				// 	if (Δx == 0 && Δy == 0) return;
				// 	// else if (Δx == 0 && Δy < 0) aktuálnyUhol = 270;
				// 	// else if (Δx == 0 && Δy > 0) aktuálnyUhol = 90;
				// 	// else if (Δx > 0 && Δy == 0) aktuálnyUhol = 0;
				// 	// else if (Δx < 0 && Δy == 0) aktuálnyUhol = 180;
				// 	else
				// 	{
				// 		/*
				// 		double α = toDegrees(atan(Δy / Δx));
				// 
				// 		poslednýUhol = aktuálnyUhol;
				// 		if (Δx < 0)
				// 			aktuálnyUhol = 180 + α;
				// 		else if (Δy < 0)
				// 			aktuálnyUhol = 360 + α;
				// 		else
				// 			aktuálnyUhol = α;
				// 		*/
				// 
				// 		aktuálnyUhol = toDegrees(atan2(Δy, Δx));
				// 		if (aktuálnyUhol < 0) aktuálnyUhol += 360;
				// 	}
				// 
				// 	if (viditeľný) Svet.automatickéPrekreslenie();
				// }
				// 
				// /** <p><a class="alias"></a> Alias pre {@link #otočNa(Point2D) otočNa}.</p> */
				// public void otocNa(Point2D bod) { otočNa(bod); }
				// 
				// /**
				//  * <p>Funguje podobne ako metóda {@link #otočNa(Point2D)
				//  * otočNa}, ibaže obmedzuje uhol pootočenia stanoveným smerom –
				//  * neotočí robot okamžite smerom na zadané súradnice, iba ním
				//  * pootočí stanoveným smerom o maximálnu zadanú hodnotu
				//  * uhla.</p>
				//  * 
				//  * @param bod súradnice bodu
				//  * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				//  *      robot otočiť smerom k bodu
				//  * @see #smerNa(Point2D)
				//  */
				// public void otočNa(Point2D bod, double najviacO)
				// {
				// 	double α = smerNa(bod);
				// 	if (α == 360) return;
				// 	if (najviacO < 0) najviacO = -najviacO;
				// 
				// 	α -= aktuálnyUhol;
				// 	if (α > 180) α -= 360;
				// 	if (α < -180) α += 360;
				// 	if (α > 0 && α > najviacO) α = najviacO;
				// 	if (α < 0 && α < -najviacO) α = -najviacO;
				// 
				// 	vľavo(α);
				// }
				// 
				// /** <p><a class="alias"></a> Alias pre {@link #otočNa(Point2D, double) otočNa}.</p> */
				// public void otocNa(Point2D bod, double najviacO)
				// { otočNa(bod, najviacO); }


				/**
				 * <p>Nasmeruje tento robot smerom k zadanému objektu. Ak sú
				 * súradnice robota a objektu zhodné, smer robota sa nezmení.
				 * Inak je vypočítaný uhol smeru medzi polohou robota
				 * a zadaného objektu a ten je použitý na nasmerovanie robota.
				 * (Objekt nemusí byť viditeľný.)</p>
				 * 
				 * @param objekt objekt ku ktorému má byť tento robot
				 *     nasmerovaný
				 * 
				 * @see #smerNa(Poloha)
				 */
				public void otočNa(Poloha objekt)
				{
					double Δx = objekt.polohaX() - aktuálneX;
						// delta x – rozdiel súradníc x
					double Δy = objekt.polohaY() - aktuálneY;
						// delta y – rozdiel súradníc y

					if (Δx == 0 && Δy == 0) return;
					// else if (Δx == 0 && Δy < 0) aktuálnyUhol = 270;
					// else if (Δx == 0 && Δy > 0) aktuálnyUhol = 90;
					// else if (Δx > 0 && Δy == 0) aktuálnyUhol = 0;
					// else if (Δx < 0 && Δy == 0) aktuálnyUhol = 180;
					else
					{
						/*
						double α = toDegrees(atan(Δy / Δx));

						if (Δx < 0)
							aktuálnyUhol = 180 + α;
						else if (Δy < 0)
							aktuálnyUhol = 360 + α;
						else
							aktuálnyUhol = α;
						*/

						poslednýUhol = aktuálnyUhol;
						aktuálnyUhol = toDegrees(atan2(Δy, Δx));
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNa(Poloha) otočNa}.</p> */
				public void otocNa(Poloha objekt) { otočNa(objekt); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otočNa(Poloha) otočNa},
				 * ibaže obmedzuje uhol pootočenia stanoveným smerom – neotočí
				 * tento robot okamžite smerom k objektu, iba ho pootočí
				 * stanoveným smerom o maximálnu zadanú hodnotu uhla.</p>
				 * 
				 * @param objekt objekt ku ktorému má byť tento robot
				 *     nasmerovaný
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     tento robot otočiť smerom k objektu
				 * 
				 * @see #smerNa(Poloha)
				 */
				public void otočNa(Poloha objekt, double najviacO)
				{
					double α = smerNa(objekt);
					if (α == 360) return;
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNa(Poloha, double) otočNa}.</p> */
				public void otocNa(Poloha objekt, double najviacO)
				{ otočNa(objekt, najviacO); }


				/**
				 * <p>Nasmeruje tento robot smerom do stredu
				 * hraníc<sup>[1]</sup> zadaného tvaru. Ak je poloha robota
				 * zhodná so stredom hraníc tvaru, smer robota sa nezmení.
				 * Inak je vypočítaný uhol smeru medzi polohou aktuálneho
				 * robota a stredom hraníc tvaru a výsledok je použitý na
				 * nasmerovanie tohto robota.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * @param tvar tvar Javy ({@link Shape Shape}), do stredu
				 *     hraníc ktorého má byť robot nasmerovaný
				 * 
				 * @see #smerNa(Shape)
				 */
				public void otočNa(Shape tvar)
				{
					Rectangle2D hranice = tvar.getBounds2D();
					double Δx = (Svet.prepočítajSpäťX(hranice.getX()) +
						hranice.getWidth() / 2) - aktuálneX;
					double Δy = (Svet.prepočítajSpäťY(hranice.getY()) -
						hranice.getHeight() / 2) - aktuálneY;

					if (Δx == 0 && Δy == 0) return;
					// else if (Δx == 0 && Δy < 0) aktuálnyUhol = 270;
					// else if (Δx == 0 && Δy > 0) aktuálnyUhol = 90;
					// else if (Δx > 0 && Δy == 0) aktuálnyUhol = 0;
					// else if (Δx < 0 && Δy == 0) aktuálnyUhol = 180;
					else
					{
						/*
						double α = toDegrees(atan(Δy / Δx));

						if (Δx < 0)
							aktuálnyUhol = 180 + α;
						else if (Δy < 0)
							aktuálnyUhol = 360 + α;
						else
							aktuálnyUhol = α;
						*/

						poslednýUhol = aktuálnyUhol;
						aktuálnyUhol = toDegrees(atan2(Δy, Δx));
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNa(Shape) otočNa}.</p> */
				public void otocNa(Shape tvar) { otočNa(tvar); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otočNa(Shape) otočNa},
				 * ibaže obmedzuje uhol pootočenia stanoveným smerom – neotočí
				 * tento robot okamžite smerom do stredu hraníc<sup>[1]</sup>
				 * tvaru, iba ho pootočí stanoveným smerom o maximálnu zadanú
				 * hodnotu uhla.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * @param tvar tvar Javy ({@link Shape Shape}), do stredu
				 *     hraníc ktorého má byť robot nasmerovaný
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     tento robot otočiť smerom do stredu hraníc tvaru
				 * 
				 * @see #smerNa(Shape)
				 */
				public void otočNa(Shape tvar, double najviacO)
				{
					double α = smerNa(tvar);
					if (α == 360) return;
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNa(Shape, double) otočNa}.</p> */
				public void otocNa(Shape tvar, double najviacO)
				{ otočNa(tvar, najviacO); }


				/**
				 * <p>Nasmeruje robot smerom na aktuálne súradnice myši.
				 * Ak sú súradnice myši zhodné so súradnicami robota, smer
				 * robota sa nezmení. Inak je vypočítaný uhol smeru medzi
				 * aktuálnou polohou robota a polohou myši, ktorý je použitý
				 * na nasmerovanie robota.</p>
				 * 
				 * @see #smerNaMyš()
				 */
				public void otočNaMyš()
				{
					double Δx = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double Δy = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					if (Δx == 0 && Δy == 0) return;
					// else if (Δx == 0 && Δy < 0) aktuálnyUhol = 270;
					// else if (Δx == 0 && Δy > 0) aktuálnyUhol = 90;
					// else if (Δx > 0 && Δy == 0) aktuálnyUhol = 0;
					// else if (Δx < 0 && Δy == 0) aktuálnyUhol = 180;
					else
					{
						/*
						double α = toDegrees(atan(Δy / Δx));

						if (Δx < 0)
							aktuálnyUhol = 180 + α;
						else if (Δy < 0)
							aktuálnyUhol = 360 + α;
						else
							aktuálnyUhol = α;
						*/

						poslednýUhol = aktuálnyUhol;
						aktuálnyUhol = toDegrees(atan2(Δy, Δx));
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNaMyš() otočNaMyš}.</p> */
				public void otocNaMys() { otočNaMyš(); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otočNaMyš() otočNaMyš},
				 * ibaže obmedzuje uhol pootočenia – neotočí tento robot
				 * okamžite smerom k súradniciam myši, iba ho pootočí
				 * stanoveným smerom o maximálnu zadanú hodnotu uhla.</p>
				 * 
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     tento robot otočiť smerom k aktuálnym súradniciam myši
				 * 
				 * @see #smerNaMyš()
				 */
				public void otočNaMyš(double najviacO)
				{
					double α = smerNaMyš();
					if (α == 360) return;
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNaMyš(double) otočNaMyš}.</p> */
				public void otocNaMys(double najviacO) { otočNaMyš(najviacO); }


				/**
				 * <p>Nasmeruje robot smerom zadaným s pomocou súradníc [Δx, Δy].
				 * Ak je zadané [0, 0], smer robota sa nezmení. Inak je
				 * vypočítaný uhol smeru medzi aktuálnou polohou robota
				 * a súradnicami zmenenými o hodnoty [Δx, Δy]. Efekt je
				 * v podstate rovnaký, ako keby robot stál v bode [0, 0]
				 * a použili by sme s rovnakými hodnotami metódu {@link 
				 * #otočNa(double, double) otočNa}. (Inak povedané – táto
				 * metóda pracuje s tzv. relatívnymi súradnicami – súradnicami
				 * vztiahnutými k súčasnej polohe robota.)</p>
				 * 
				 * @param Δx odchýlka v smere osi x
				 * @param Δy odchýlka v smere osi y
				 * 
				 * @see #smer(double)
				 * @see #uhol(double)
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #otočNa(double, double)
				 * @see #otoč(double)
				 * @see #otoč(double, double)
				 * @see #otoč(double, double, double)
				 * @see #otočO(double)
				 */
				public void otoč(double Δx, double Δy)
				{
					if (Δx == 0 && Δy == 0) return;
					// else if (Δx == 0 && Δy < 0) aktuálnyUhol = 270;
					// else if (Δx == 0 && Δy > 0) aktuálnyUhol = 90;
					// else if (Δx > 0 && Δy == 0) aktuálnyUhol = 0;
					// else if (Δx < 0 && Δy == 0) aktuálnyUhol = 180;
					else
					{
						/*
						double α = toDegrees(atan(Δy / Δx));

						if (Δx < 0)
							aktuálnyUhol = 180 + α;
						else if (Δy < 0)
							aktuálnyUhol = 360 + α;
						else
							aktuálnyUhol = α;
						*/

						poslednýUhol = aktuálnyUhol;
						aktuálnyUhol = toDegrees(atan2(Δy, Δx));
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otoč(double, double) otoč}.</p> */
				public void otoc(double Δx, double Δy) { otoč(Δx, Δy); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otoč(double, double)
				 * otoč}, ibaže obmedzuje uhol pootočenia stanoveným smerom –
				 * neotočí robot okamžite smerom na zadané súradnice, iba ním
				 * pootočí stanoveným smerom o maximálnu zadanú hodnotu uhla.</p>
				 * 
				 * @param Δx odchýlka v smere osi x
				 * @param Δy odchýlka v smere osi y
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     robot otočiť smerom k bodu [Δx, Δy]
				 * 
				 * @see #otoč(double, double)
				 */
				public void otoč(double Δx, double Δy, double najviacO)
				{
					double α = smer(Δx, Δy);
					if (α == 360) return;
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otoč(double, double, double) otoč}.</p> */
				public void otoc(double Δx, double Δy, double najviacO)
				{ otoč(Δx, Δy, najviacO); }


				/**
				 * <p>Nasmeruje tento robot rovnakým smerom, akým je otočený
				 * zadaný objekt.</p>
				 * 
				 * @param objekt objekt, podľa ktorého chceme nasmerovať
				 *     tento robot
				 * 
				 * @see #otoč(double, double)
				 */
				public void otoč(Smer objekt)
				{
					poslednýUhol = aktuálnyUhol;
					aktuálnyUhol = objekt.smer();
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otoč(Smer) otoč}.</p> */
				public void otoc(Smer objekt) { otoč(objekt); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otoč(Smer) otoč},
				 * ibaže obmedzuje uhol pootočenia stanoveným smerom – neotočí
				 * robot okamžite podľa smeru iného robota, iba ním pootočí
				 * o maximálnu zadanú hodnotu uhla.</p>
				 * 
				 * @param objekt objekt, podľa ktorého chceme nasmerovať
				 *     tento robot
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     robot otočiť
				 */
				public void otoč(Smer objekt, double najviacO)
				{
					double α = objekt.smer();
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otoč(Smer, double) otoč}.</p> */
				public void otoc(Smer objekt, double najviacO)
				{ otoč(objekt, najviacO); }


				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol 0° znamená, že robot sa
				 * posunie presne na zadané súradnice. Uhol 180° znamená, že
				 * robot sa pohne presne opačným smerom než sa nachádzajú
				 * zadané súradnice.</p>
				 * 
				 * @param x x-ová súradnica cieľového bodu
				 * @param y y-ová súradnica cieľového bodu
				 * @param uhol uhol pootočenia výsledného pohybu voči cieľu
				 * 
				 * @see #choďNaPootočený(Poloha, double)
				 * @see #choďNaPootočený(double, double, Smer)
				 * @see #skočNaPootočený(double, double, double)
				 * @see #skočNaPootočený(double, double, Smer)
				 */
				public void choďNaPootočený(double x, double y, double uhol)
				{
					double α = toRadians(uhol);
					double Δx = x - aktuálneX;
					double Δy = y - aktuálneY;
					choď(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaPootočený(double, double, double) choďNaPootočený}.</p> */
				public void chodNaPootoceny(double x, double y, double uhol)
				{ choďNaPootočený(x, y, uhol); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param x x-ová súradnica cieľového bodu
				 * @param y y-ová súradnica cieľového bodu
				 * @param smer objekt určujúci uhol pootočenia výsledného
				 *     pohybu voči cieľu
				 * 
				 * @see #choďNaPootočený(Poloha, Smer)
				 * @see #choďNaPootočený(double, double, double)
				 * @see #skočNaPootočený(double, double, double)
				 * @see #skočNaPootočený(double, double, Smer)
				 */
				public void choďNaPootočený(double x, double y, Smer smer)
				{
					double α = toRadians(smer.uhol());
					double Δx = x - aktuálneX;
					double Δy = y - aktuálneY;
					choď(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaPootočený(double, double, Smer) choďNaPootočený}.</p> */
				public void chodNaPootoceny(double x, double y, Smer smer)
				{ choďNaPootočený(x, y, smer); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param x x-ová súradnica cieľového bodu
				 * @param y y-ová súradnica cieľového bodu
				 * @param uhol uhol pootočenia výsledného pohybu voči cieľu
				 * 
				 * @see #skočNaPootočený(Poloha, double)
				 * @see #choďNaPootočený(double, double, double)
				 * @see #choďNaPootočený(double, double, Smer)
				 * @see #skočNaPootočený(double, double, Smer)
				 */
				public void skočNaPootočený(double x, double y, double uhol)
				{
					double α = toRadians(uhol);
					double Δx = x - aktuálneX;
					double Δy = y - aktuálneY;
					skoč(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaPootočený(double, double, double) skočNaPootočený}.</p> */
				public void skocNaPootoceny(double x, double y, double uhol)
				{ skočNaPootočený(x, y, uhol); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param x x-ová súradnica cieľového bodu
				 * @param y y-ová súradnica cieľového bodu
				 * @param smer objekt určujúci uhol pootočenia výsledného
				 *     pohybu voči cieľu
				 * 
				 * @see #skočNaPootočený(Poloha, Smer)
				 * @see #choďNaPootočený(double, double, double)
				 * @see #choďNaPootočený(double, double, Smer)
				 * @see #skočNaPootočený(double, double, double)
				 */
				public void skočNaPootočený(double x, double y, Smer smer)
				{
					double α = toRadians(smer.uhol());
					double Δx = x - aktuálneX;
					double Δy = y - aktuálneY;
					skoč(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaPootočený(double, double, Smer) skočNaPootočený}.</p> */
				public void skocNaPootoceny(double x, double y, Smer smer)
				{ skočNaPootočený(x, y, smer); }


				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param poloha objekt určujúci cieľový bod
				 * @param uhol uhol pootočenia výsledného pohybu voči cieľu
				 * 
				 * @see #choďNaPootočený(double, double, double)
				 * @see #choďNaPootočený(Poloha, Smer)
				 * @see #skočNaPootočený(Poloha, double)
				 * @see #skočNaPootočený(Poloha, Smer)
				 */
				public void choďNaPootočený(Poloha poloha, double uhol)
				{
					double α = toRadians(uhol);
					double Δx = poloha.polohaX() - aktuálneX;
					double Δy = poloha.polohaY() - aktuálneY;
					choď(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaPootočený(Poloha, double) choďNaPootočený}.</p> */
				public void chodNaPootoceny(Poloha poloha, double uhol)
				{ choďNaPootočený(poloha, uhol); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param poloha objekt určujúci cieľový bod
				 * @param smer objekt určujúci uhol pootočenia výsledného
				 *     pohybu voči cieľu
				 * 
				 * @see #choďNaPootočený(double, double, Smer)
				 * @see #choďNaPootočený(Poloha, double)
				 * @see #skočNaPootočený(Poloha, double)
				 * @see #skočNaPootočený(Poloha, Smer)
				 */
				public void choďNaPootočený(Poloha poloha, Smer smer)
				{
					double α = toRadians(smer.uhol());
					double Δx = poloha.polohaX() - aktuálneX;
					double Δy = poloha.polohaY() - aktuálneY;
					choď(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaPootočený(Poloha, Smer) choďNaPootočený}.</p> */
				public void chodNaPootoceny(Poloha poloha, Smer smer)
				{ choďNaPootočený(poloha, smer); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param poloha objekt určujúci cieľový bod
				 * @param uhol uhol pootočenia výsledného pohybu voči cieľu
				 * 
				 * @see #skočNaPootočený(double, double, double)
				 * @see #choďNaPootočený(Poloha, double)
				 * @see #choďNaPootočený(Poloha, Smer)
				 * @see #skočNaPootočený(Poloha, Smer)
				 */
				public void skočNaPootočený(Poloha poloha, double uhol)
				{
					double α = toRadians(uhol);
					double Δx = poloha.polohaX() - aktuálneX;
					double Δy = poloha.polohaY() - aktuálneY;
					skoč(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaPootočený(Poloha, double) skočNaPootočený}.</p> */
				public void skocNaPootoceny(Poloha poloha, double uhol)
				{ skočNaPootočený(poloha, uhol); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných súradníc o zadaný uhol so stredom otáčania
				 * v mieste robota. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne na zadané súradnice.
				 * Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané
				 * súradnice.</p>
				 * 
				 * @param poloha objekt určujúci cieľový bod
				 * @param smer objekt určujúci uhol pootočenia výsledného
				 *     pohybu voči cieľu
				 * 
				 * @see #skočNaPootočený(double, double, Smer)
				 * @see #choďNaPootočený(Poloha, double)
				 * @see #choďNaPootočený(Poloha, Smer)
				 * @see #skočNaPootočený(Poloha, double)
				 */
				public void skočNaPootočený(Poloha poloha, Smer smer)
				{
					double α = toRadians(smer.uhol());
					double Δx = poloha.polohaX() - aktuálneX;
					double Δy = poloha.polohaY() - aktuálneY;
					skoč(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaPootočený(Poloha, Smer) skočNaPootočený}.</p> */
				public void skocNaPootoceny(Poloha poloha, Smer smer)
				{ skočNaPootočený(poloha, smer); }


				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných relatívnych súradníc o zadaný uhol. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne o zadané súradnice
				 * v smere osí x a y. Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané relatívne
				 * súradnice.</p>
				 * 
				 * @param Δx zmena súradníc v osi x
				 * @param Δy zmena súradníc v osi y
				 * @param uhol uhol pootočenia výsledného pohybu voči cieľu
				 * 
				 * @see #choďPootočený(double, double, Smer)
				 * @see #skočPootočený(double, double, double)
				 * @see #skočPootočený(double, double, Smer)
				 */
				public void choďPootočený(double Δx, double Δy, double uhol)
				{
					double α = toRadians(uhol);
					choď(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďPootočený(double, double, double) choďPootočený}.</p> */
				public void chodPootoceny(double Δx, double Δy, double uhol)
				{ choďPootočený(Δx, Δy, uhol); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných relatívnych súradníc o zadaný uhol. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne o zadané súradnice
				 * v smere osí x a y. Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané relatívne
				 * súradnice.</p>
				 * 
				 * @param Δx zmena súradníc v osi x
				 * @param Δy zmena súradníc v osi y
				 * @param smer objekt určujúci uhol pootočenia výsledného
				 *     pohybu voči cieľu
				 * 
				 * @see #choďPootočený(double, double, double)
				 * @see #skočPootočený(double, double, double)
				 * @see #skočPootočený(double, double, Smer)
				 */
				public void choďPootočený(double Δx, double Δy, Smer smer)
				{
					double α = toRadians(smer.uhol());
					choď(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďPootočený(double, double, Smer) choďPootočený}.</p> */
				public void chodPootoceny(double Δx, double Δy, Smer smer)
				{ choďPootočený(Δx, Δy, smer); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných relatívnych súradníc o zadaný uhol. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne o zadané súradnice
				 * v smere osí x a y. Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané relatívne
				 * súradnice.</p>
				 * 
				 * @param Δx zmena súradníc v osi x
				 * @param Δy zmena súradníc v osi y
				 * @param uhol uhol pootočenia výsledného pohybu voči cieľu
				 * 
				 * @see #choďPootočený(double, double, double)
				 * @see #choďPootočený(double, double, Smer)
				 * @see #skočPootočený(double, double, Smer)
				 */
				public void skočPootočený(double Δx, double Δy, double uhol)
				{
					double α = toRadians(uhol);
					skoč(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočPootočený(double, double, double) skočPootočený}.</p> */
				public void skocPootoceny(double Δx, double Δy, double uhol)
				{ skočPootočený(Δx, Δy, uhol); }

				/**
				 * <p>Tento príkaz pošle robot na miesto určené pootočením
				 * zadaných relatívnych súradníc o zadaný uhol. Príklady: Uhol
				 * 0° znamená, že robot sa posunie presne o zadané súradnice
				 * v smere osí x a y. Uhol 180° znamená, že robot sa pohne
				 * presne opačným smerom než sa nachádzajú zadané relatívne
				 * súradnice.</p>
				 * 
				 * @param Δx zmena súradníc v osi x
				 * @param Δy zmena súradníc v osi y
				 * @param smer objekt určujúci uhol pootočenia výsledného
				 *     pohybu voči cieľu
				 * 
				 * @see #choďPootočený(double, double, double)
				 * @see #choďPootočený(double, double, Smer)
				 * @see #skočPootočený(double, double, double)
				 */
				public void skočPootočený(double Δx, double Δy, Smer smer)
				{
					double α = toRadians(smer.uhol());
					skoč(rotovanéXRad(Δx, Δy, α),
						rotovanéYRad(Δx, Δy, α));
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočPootočený(double, double, Smer) skočPootočený}.</p> */
				public void skocPootoceny(double Δx, double Δy, Smer smer)
				{ skočPootočený(Δx, Δy, smer); }


			// Horizontálny a vertikálny krokový pohyb

				/**
				 * <p>Prikáže robotu, aby prešiel na konkrétne súradnice na
				 * podlahe (strope). Keď je pero položené, tak kreslí čiaru.
				 * Robot nezmení smer, kam bol obrátený.</p>
				 * 
				 * @param novéX nová x-ová súradnica
				 * @param novéY nová y-ová súradnica
				 * 
				 * @see #dopredu(double) dopredu
				 * @see #vzad(double) vzad
				 * @see #položPero() položPero
				 * @see #zdvihniPero() zdvihniPero
				 * @see #choďNa(Poloha)
				 * @see #choďNa(Shape)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Poloha)
				 * @see #skočNa(Shape)
				 * @see #choď(double, double)
				 * @see #skoč(double, double)
				 * @see #choďPoOblúku(double, double)
				 * @see #choďNaMyš()
				 */
				public void choďNa(double novéX, double novéY)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							choďNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNa(double, double) choďNa}.</p> */
				public void chodNa(double novéX, double novéY) { choďNa(novéX, novéY); }

				/**
				 * <p>Prikáže tomuto robotu, aby prešiel na polohu
				 * zadaného objektu. Keď je pero položené, tak kreslí čiaru.
				 * Robot nezmení smer, kam bol obrátený.</p>
				 * 
				 * @param objekt objekt určujúci cieľovú polohu
				 * 
				 * @see #choďNa(double, double)
				 * @see #choďNa(Shape)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Poloha)
				 * @see #skočNa(Shape)
				 * @see #choď(double, double)
				 * @see #skoč(double, double)
				 */
				public void choďNa(Poloha objekt)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY,
							objekt.polohaX(), objekt.polohaY());
						aktualizujPôsobisko();
						aktuálneX = objekt.polohaX();
						aktuálneY = objekt.polohaY();
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = objekt.polohaX();
						aktuálneY = objekt.polohaY();
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(objekt.polohaX()),
								Svet.prepočítajY(objekt.polohaY()));
						else
							cesta.moveTo(
								Svet.prepočítajX(objekt.polohaX()),
								Svet.prepočítajY(objekt.polohaY()));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(objekt.polohaX()),
							(int)Svet.prepočítajY(objekt.polohaY()));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							choďNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNa(Poloha) choďNa}.</p> */
				public void chodNa(Poloha objekt) { choďNa(objekt); }

				/**
				 * <p>Prikáže robotu, aby prešiel do stredu
				 * hraníc<sup>[1]</sup> zadaného tvaru. Keď je pero položené,
				 * tak kreslí čiaru. Robot nezmení smer, kam bol obrátený.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * @param tvar tvar Javy ({@link Shape Shape}), do stredu
				 *     hraníc ktorého prejde tento robot
				 * 
				 * @see #choďNa(double, double)
				 * @see #choďNa(Poloha)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Poloha)
				 * @see #skočNa(Shape)
				 * @see #choď(double, double)
				 * @see #skoč(double, double)
				 */
				public void choďNa(Shape tvar)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					Rectangle2D hranice = tvar.getBounds2D();
					double novéX = Svet.prepočítajSpäťX(hranice.getX()) +
						hranice.getWidth() / 2;
					double novéY = Svet.prepočítajSpäťY(hranice.getY()) -
						hranice.getHeight() / 2;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							choďNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNa(Shape) choďNa}.</p> */
				public void chodNa(Shape tvar) { choďNa(tvar); }

				/**
				 * <p>Prikáže robotu, aby na podlahe (strope) prešiel na
				 * aktuálne súradnice myši. Keď je pero položené, tak kreslí
				 * čiaru. Robot nezmení smer, kam bol obrátený.</p>
				 * 
				 * @see #choďNa(double, double)
				 * @see #skočNaMyš()
				 */
				public void choďNaMyš()
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY,
							ÚdajeUdalostí.súradnicaMyšiX,
							ÚdajeUdalostí.súradnicaMyšiY);
						aktualizujPôsobisko();
						aktuálneX = ÚdajeUdalostí.súradnicaMyšiX;
						aktuálneY = ÚdajeUdalostí.súradnicaMyšiY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = ÚdajeUdalostí.súradnicaMyšiX;
						aktuálneY = ÚdajeUdalostí.súradnicaMyšiY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
								Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
						else
							cesta.moveTo(
								Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
								Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
							(int)Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							choďNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaMyš() choďNaMyš}.</p> */
				public void chodNaMys() { choďNaMyš(); }


				/**
				 * <p>Prikáže robotu, aby sa na posunul o zadané súradnice
				 * v horizontálnom a vertikálnom smere. Keď je pero položené,
				 * tak kreslí čiaru po aktívnom plátne (podlahe alebo strope).
				 * Robot nezmení aktuálny smer.</p>
				 * 
				 * @param Δx miera posunutia v smere osi x
				 * @param Δy miera posunutia v smere osi y
				 * 
				 * @see #choďNa(double, double)
				 * @see #choďNa(Poloha)
				 * @see #choďNa(Shape)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Poloha)
				 * @see #skočNa(Shape)
				 * @see #skoč(double, double)
				 */
				public void choď(double Δx, double Δy)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY,
							aktuálneX + Δx, aktuálneY + Δy);
						aktualizujPôsobisko();
						aktuálneX += Δx;
						aktuálneY += Δy;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX += Δx;
						aktuálneY += Δy;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
						else
							cesta.moveTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(aktuálneX),
							(int)Svet.prepočítajY(aktuálneY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> choď(Δx, Δy));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choď(double, double) choď}.</p> */
				public void chod(double Δx, double Δy) { choď(Δx, Δy); }


				/**
				 * <p>Prikáže robotu, aby preskočil na konkrétne súradnice na
				 * podlahe (strope). Robot nekreslí čiaru, ani nezmení smer,
				 * kam bol obrátený.</p>
				 * 
				 * @param novéX nová x-ová súradnica
				 * @param novéY nová y-ová súradnica
				 * 
				 * @see #dopredu(double) dopredu
				 * @see #vzad(double) vzad
				 * @see #choďNa(double, double)
				 * @see #choďNa(Poloha)
				 * @see #choďNa(Shape)
				 * @see #skočNa(Poloha)
				 * @see #skočNa(Shape)
				 * @see #choď(double, double)
				 * @see #skoč(double, double)
				 * @see #skočPoOblúku(double, double)
				 * @see #skočNaMyš()
				 */
				public void skočNa(double novéX, double novéY)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							skočNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNa(double, double) skočNa}.</p> */
				public void skocNa(double novéX, double novéY)
				{ skočNa(novéX, novéY); }

				/**
				 * <p>Prikáže tomuto robotu, aby preskočil na polohu zadaného
				 * objektu. Robot nekreslí čiaru, ani nezmení smer, kam bol
				 * obrátený.</p>
				 * 
				 * @param objekt objekt určujúci cieľovú polohu
				 * 
				 * @see #choďNa(double, double)
				 * @see #choďNa(Poloha)
				 * @see #choďNa(Shape)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Shape)
				 * @see #choď(double, double)
				 * @see #skoč(double, double)
				 */
				public void skočNa(Poloha objekt)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					aktuálneX = objekt.polohaX();
					aktuálneY = objekt.polohaY();

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(objekt.polohaX()),
								Svet.prepočítajY(objekt.polohaY()));
						else
							cesta.moveTo(
								Svet.prepočítajX(objekt.polohaX()),
								Svet.prepočítajY(objekt.polohaY()));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(objekt.polohaX()),
							(int)Svet.prepočítajY(objekt.polohaY()));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							skočNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNa(Poloha) skočNa}.</p> */
				public void skocNa(Poloha objekt) { skočNa(objekt); }

				/**
				 * <p>Prikáže robotu, aby preskočil do stredu
				 * hraníc<sup>[1]</sup> zadaného tvaru. Robot nekreslí čiaru,
				 * ani nezmení smer, kam bol obrátený.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * @param tvar tvar Javy ({@link Shape Shape}), do stredu
				 *     hraníc ktorého preskočí tento robot
				 * 
				 * @see #choďNa(double, double)
				 * @see #choďNa(Poloha)
				 * @see #choďNa(Shape)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Poloha)
				 * @see #choď(double, double)
				 * @see #skoč(double, double)
				 */
				public void skočNa(Shape tvar)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					Rectangle2D hranice = tvar.getBounds2D();
					double novéX = Svet.prepočítajSpäťX(hranice.getX()) +
						hranice.getWidth() / 2;
					double novéY = Svet.prepočítajSpäťY(hranice.getY()) -
						hranice.getHeight() / 2;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							skočNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNa(Shape) skočNa}.</p> */
				public void skocNa(Shape tvar) { skočNa(tvar); }

				/**
				 * <p>Prikáže robotu, aby v rámci podlahy (stropu) preskočil na
				 * aktuálne súradnice myši. Robot nekreslí čiaru, ani nezmení
				 * smer, kam bol obrátený.</p>
				 * 
				 * @see #skočNa(double, double)
				 * @see #choďNaMyš()
				 */
				public void skočNaMyš()
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					aktuálneX = ÚdajeUdalostí.súradnicaMyšiX;
					aktuálneY = ÚdajeUdalostí.súradnicaMyšiY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
								Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
						else
							cesta.moveTo(
								Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
								Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
							(int)Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							skočNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaMyš() skočNaMyš}.</p> */
				public void skocNaMys() { skočNaMyš(); }


				/**
				 * <p>Prikáže robotu, aby sa na na podlahe (strope) preskočil
				 * o zadané súradnice v horizontálnom a vertikálnom smere.
				 * Robot nekreslí čiaru, ani nezmení svoj aktuálny smer.</p>
				 * 
				 * @param Δx miera posunutia v smere osi x
				 * @param Δy miera posunutia v smere osi y
				 * 
				 * @see #choďNa(double, double)
				 * @see #choďNa(Poloha)
				 * @see #choďNa(Shape)
				 * @see #skočNa(double, double)
				 * @see #skočNa(Poloha)
				 * @see #skočNa(Shape)
				 * @see #choď(double, double)
				 */
				public void skoč(double Δx, double Δy)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					aktuálneX += Δx;
					aktuálneY += Δy;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
						else
							cesta.moveTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(aktuálneX),
							(int)Svet.prepočítajY(aktuálneY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> skoč(Δx, Δy));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skoč(double, double) skoč}.</p> */
				public void skoc(double Δx, double Δy) { skoč(Δx, Δy); }


				/**
				 * <p>Prikáže robotu, aby sa posunul o zadané súradnice
				 * smere osí x a y, pričom obe osi sú pootočené podľa
				 * rozdielu aktuálneho smeru robota a uhla 90°. To znamená,
				 * že ak je aktuálny uhol robota rovný 90° (čo je predvolená
				 * hodnota), tak sa príkaz správa rovnako ako príkaz
				 * {@link #choď(double, double) choď(Δx, Δy)} (čiže
				 * súradnicový systém nie je pootočený), inak robot skočí
				 * v rámci pootočeného súradnicového priestoru. Keď je pero
				 * robota položené, tak robot kreslí čiaru.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Príklad používajúcu
				 * túto metódu je v opise metódy {@link #preskoč(double,
				 * double) preskoč}.</p>
				 * 
				 * @param Δx miera posunutia, o ktorú sa má robot posunúť
				 *     „doprava“ – v smere kolmom vzhľadom na svoju orientáciu
				 *     (záporné hodnoty posúvajú robot „doľava“)
				 * @param Δy miera posunutia, o ktorú sa má robot posunúť
				 *     „dopredu“ – priamo v smere svojej orientácie (opäť,
				 *     záporné súradnice posúvajú robot „dozadu“)
				 * 
				 * @see #preskoč(double, double)
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 */
				public void posuň(double Δx, double Δy)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX
						+ sin(toRadians(aktuálnyUhol)) * Δx
						+ cos(toRadians(aktuálnyUhol)) * Δy;

					double novéY = aktuálneY
						- cos(toRadians(aktuálnyUhol)) * Δx
						+ sin(toRadians(aktuálnyUhol)) * Δy;

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, novéX, novéY);
						aktualizujPôsobisko();
						aktuálneX = novéX;
						aktuálneY = novéY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = novéX;
						aktuálneY = novéY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> posuň(Δx, Δy));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuň(double, double) posuň}.</p> */
				public void posun(double Δx, double Δy) { posuň(Δx, Δy); }

				/**
				 * <p>Prikáže robotu, aby preskočil o zadané súradnice
				 * smere osí x a y, pričom obe osi sú pootočené podľa
				 * rozdielu aktuálneho smeru robota a uhla 90°. To znamená,
				 * že ak je aktuálny uhol robota rovný 90° (čo je predvolená
				 * hodnota), tak sa príkaz správa rovnako ako príkaz
				 * {@link #skoč(double, double) skoč(Δx, Δy)} (čiže
				 * súradnicový systém nie je pootočený), inak robot skočí
				 * v rámci pootočeného súradnicového priestoru. Robot pri
				 * skákaní nekreslí čiaru.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Tento príklad ukazuje ako funguje metóda {@code 
				 * currpreskoč} – ľavé tlačidlo posúva robot po plátne
				 * s použitím tejto metódy a pravé tlačidlo otáča robot
				 * smerom na myš. Po spustení programu funguje metóda {@code 
				 * currpreskoč} rovnako ako metóda {@link #skoč(double,
				 * double) skoč}, pretože predvolený smer robota je 90°.
				 * Rozdiel sa prejaví až po pootočení robota iným smerom.
				 * Príklad tiež používa metódu {@link #posuň(double, double)
				 * posuň} na nakreslenie osí súradnicových sústav (stabilnej
				 * a pootočenej).</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} TestPosunovRobota {@code kwdextends} {@link GRobot GRobot}
					{
						{@code comm// Kreslenie osí súradnicových sústav…}
						{@code kwdprivate} {@code typevoid} kresliOsi()
						{
							{@code comm// Záloha polohy, smeru a farby robota:}
							{@link Poloha Poloha} p = {@link GRobot#poloha() poloha}();
							{@code typedouble} u = {@link GRobot#uhol() uhol}();
							{@link Farba Farba} f = {@link GRobot#farba() farba}();
							{@link GRobot#skočNa(double, double) skočNa}({@code num0}, {@code num0});

							{@code comm// Stabilná súradnicová sústava:}
							{@link GRobot#farba(Color) farba}({@link Farebnosť#čierna čierna});
							{@link GRobot#skoč(double, double) skoč}(-{@code num200}, {@code num0}); {@link GRobot#choď(double, double) choď}({@code num400}, {@code num0});
							{@link GRobot#skoč(double, double) skoč}(-{@code num200}, {@code num200}); {@link GRobot#choď(double, double) choď}({@code num0}, -{@code num400});
							{@link GRobot#skoč(double, double) skoč}({@code num0}, {@code num200});

							{@code comm// Pootočená súradnicová sústava:}
							{@link GRobot#farba(Color) farba}({@link Farebnosť#tyrkysová tyrkysová});
							{@link GRobot#preskoč(double, double) preskoč}(-{@code num200}, {@code num0}); {@link GRobot#posuň(double, double) posuň}({@code num400}, {@code num0});
							{@link GRobot#preskoč(double, double) preskoč}(-{@code num200}, {@code num200}); {@link GRobot#posuň(double, double) posuň}({@code num0}, -{@code num400});

							{@code comm// Obnovenie parametrov zo zálohy:}
							{@link GRobot#poloha(Poloha) poloha}(p);
							{@link GRobot#uhol(double) uhol}(u);
							{@link GRobot#farba(Color) farba}(f);
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#stlačenieTlačidlaMyši() stlačenieTlačidlaMyši}()
						{
							{@code comm// Reakcia stlačenia tlačidla myši funguje}
							{@code comm// rovnako ako ťahanie myšou:}
							{@link GRobot#ťahanieMyšou() ťahanieMyšou}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#ťahanieMyšou() ťahanieMyšou}()
						{
							{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#tlačidloMyši(int) tlačidloMyši}({@link GRobot#ĽAVÉ ĽAVÉ}))
							{
								{@code comm// Ľavé tlačidlo presunie robot od stredu}
								{@code comm// o súradnice myši s použitím metódy preskoč}
								{@code comm// (čiže v súradnicovej sústave pootočenej}
								{@code comm// o zmenu smeru robota):}
								{@link GRobot#skočNa(double, double) skočNa}({@code num0}, {@code num0});
								{@link GRobot#preskoč(double, double) preskoč}({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#súradnicaMyšiX() súradnicaMyšiX}(),
									{@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#súradnicaMyšiY() súradnicaMyšiY}());
							}
							{@code kwdelse}
							{
								{@code comm// Ostatné tlačidlá otočia robot na myš:}
								{@link Svet Svet}.{@link Svet#vymaž() vymaž}();
								{@link GRobot#otočNaMyš() otočNaMyš}();
								kresliOsi();
							}
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}... args)
						{
							{@code comm// Trieda TestPosunovRobota nemá definovaný žiadny konštruktor,}
							{@code comm// preto inicializáciu (prvé volanie metódy kresliOsi) vykonávame}
							{@code comm// tu:}
							{@code kwdnew} TestPosunovRobota().kresliOsi();
						}
					}
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>test-posunov-robota.png<alt/>Použitie metódy
				 * preskoč.</image>Príklad v činnosti: Robot bol pootočený
				 * (použitím pravého tlačidla) a potom posunutý v rámci
				 * pootočenej súradnicovej sústavy (tyrkysová farba).</p>
				 * 
				 * @param Δx miera posunutia, o ktorú má robot preskočiť
				 *     „doprava“ – v smere kolmom vzhľadom na jeho orientáciu
				 *     (záporné hodnoty kážu robotu skákať „doľava“)
				 * @param Δy miera posunutia, o ktorú má robot preskočiť
				 *     „dopredu“ – priamo v smere svojej orientácie (opäť,
				 *     záporné súradnice mu kážu skákať „dozadu“)
				 * 
				 * @see #posuň(double, double)
				 * 
				 * @see #posuňVSmere(double, double)
				 * @see #preskočVSmere(double, double)
				 * @see #posuňVSmere(Smer, double)
				 * @see #preskočVSmere(Smer, double)
				 * @see #posuňVSmere(double)
				 * @see #preskočVSmere(double)
				 * @see #posuňVSmere(Smer)
				 * @see #preskočVSmere(Smer)
				 */
				public void preskoč(double Δx, double Δy)
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					double novéX = aktuálneX
						+ sin(toRadians(aktuálnyUhol)) * Δx
						+ cos(toRadians(aktuálnyUhol)) * Δy;

					double novéY = aktuálneY
						- cos(toRadians(aktuálnyUhol)) * Δx
						+ sin(toRadians(aktuálnyUhol)) * Δy;

					aktuálneX = novéX;
					aktuálneY = novéY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						else
							cesta.moveTo(
								Svet.prepočítajX(novéX),
								Svet.prepočítajY(novéY));
						/*
						cesta.addPoint(
							(int)Svet.prepočítajX(novéX),
							(int)Svet.prepočítajY(novéY));
						*/
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() -> preskoč(Δx, Δy));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #preskoč(double, double) preskoč}.</p> */
				public void preskoc(double Δx, double Δy) { preskoč(Δx, Δy); }


			// Špeciálny pohyb

				/**
				 * <p>Pohne robotom po oblúku so zadaným polomerom o zadaný
				 * uhol a v prípade, že je položené pero, tak oblúk aj
				 * nakreslí. Robot sa predvolene otáča doľava (t. j. pri
				 * zadaní kladného uhla otáčania a kladného polomeru sa robot
				 * pri pohybe dopredu otáča doľava, čiže kreslí ľavotočivý
				 * oblúk). Na obrátenie smeru otáčania (kreslenie pravotočivého
				 * oblúka) zadajte záporný polomer otáčania. Pri zadaní
				 * záporného uhla bude robot cúvať. Keď je polomer rovný nule,
				 * robot zostane stáť aj v prípade, že je uhol nenulový,
				 * pretože nie je možné určiť vzdialenosť akú by mal prejsť.</p>
				 * 
				 * <p class="attention"><b>Upozornenie:</b> Vo verzii 2.0
				 * sa zmenil predvolený smer otáčania robota!</p>
				 *
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     zadaného polomeru
				 * @param polomer polomer otáčania
				 * 
				 * @see #dopredu(double) dopredu
				 * @see #vzad(double) vzad
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #choďNa(double, double) choďNa
				 * @see #skočNa(double, double) skočNa
				 * @see #choďPoOblúku(double)
				 * @see #choďPoOblúku()
				 * @see #skočPoOblúku(double, double)
				 * @see #choďNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 * @see #choďNaPoOblúku(Poloha)
				 * @see #skočNaPoOblúku(Poloha)
				 * @see #polohaPera() polohaPera
				 */
				public void choďPoOblúku(double uhol, double polomer)
				{
					// ‼ Keď je polomer rovný nule, robot zostane stáť aj
					// v prípade, že je uhol nenulový ‼ (V podstate je
					// akoby zaseknutý, neschopný otáčať sa na mieste.)
					if (0 == uhol || 0 == polomer) return;

					// (Potrebné do lambda výrazu v registrujPretočOhraničenie,
					// lebo premenná musí byť „efektívne konečná“.)
					double uhol2 = uhol, polomer2 = polomer;

					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					/*
					if (polomer < 0)
					{
						uhol = -uhol;
						polomer = -polomer;
					}
					*/

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);
					double priemer;

					// double novéX = aktuálneX;
					// double novéY = aktuálneY;

					Arc2D.Double oblúk;

					// Pôvodné správanie metódy (ako bolo navrhnuté) trochu
					// skomplikovalo výpočty, tak sme to zjednodušili
					// a rozdelili na dve vetvy…

					// Keďže oblúk je teraz kreslený s pomocou tvaru Javy, bolo
					// treba vyriešiť presunutie robota na novú pozíciu. Je
					// riešené tromi jednoduchými krokmi: posunom robota do
					// stredu otáčania, pootočením o uhol otáčania a posunom
					// späť na dráhu oblúka…

					if (polomer >= 0)
					{
						priemer = 2 * polomer;

						prepočítanéX -= polomer * (1 - cos(
							toRadians(aktuálnyUhol + 90)));
						prepočítanéY -= polomer * (1 + sin(
							toRadians(aktuálnyUhol + 90)));

						oblúk = new Arc2D.Double(prepočítanéX, prepočítanéY,
							priemer, priemer, aktuálnyUhol + 270, uhol,
							Arc2D.OPEN);

						// posuňVľavo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol + 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol + 90)) * polomer;

						// doľava…
						aktuálnyUhol += uhol;
						aktuálnyUhol %= 360;
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;

						// posuňVpravo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol - 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol - 90)) * polomer;
					}
					else
					{
						polomer = -polomer;
						priemer = 2 * polomer;

						prepočítanéX -= polomer * (1 - cos(
							toRadians(aktuálnyUhol - 90)));
						prepočítanéY -= polomer * (1 + sin(
							toRadians(aktuálnyUhol - 90)));

						oblúk = new Arc2D.Double(prepočítanéX, prepočítanéY,
							priemer, priemer, aktuálnyUhol + 90, -uhol,
							Arc2D.OPEN);

						// posuňVpravo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol - 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol - 90)) * polomer;

						// doprava…
						aktuálnyUhol -= uhol;
						aktuálnyUhol %= 360;
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;

						// posuňVľavo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol + 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol + 90)) * polomer;
					}

					/*
					// Pôvodné správanie metódy:
					double pôvodnýSmer = aktuálnyUhol;
					double krok = (PI * polomer) / 180.0;
					double alfa = uhol >= 0 ? 1 : -1;
					double rotácia = alfa;
					while (abs(rotácia) <= abs(uhol))
					{
						aktuálnyUhol -= alfa;
						rotácia += alfa;
						dopredu(krok);
					}
					aktuálnyUhol = pôvodnýSmer - uhol;
					aktuálnyUhol %= 360;
					if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					*/

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.append(oblúk.getPathIterator(null), true);
						else
							cesta.moveTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							{
								// final double uhol3 = uhol2,
								// 	polomer3 = polomer2;
								choďPoOblúku(uhol2, polomer2);
							});
						while (doriešOhraničenie());
					}

					if (peroPoložené)
					{
						// grafikaAktívnehoPlátna.setColor(farbaRobota);
						nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
						nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
						grafikaAktívnehoPlátna.setStroke(čiara);
						grafikaAktívnehoPlátna.draw(oblúk);
						aktualizujPôsobisko(oblúk.getBounds2D());
						obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
						Svet.automatickéPrekreslenie();
					}
					else if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďPoOblúku(double, double) choďPoOblúku}.</p> */
				public void chodPoObluku(double uhol, double polomer)
				{ choďPoOblúku(uhol, polomer); }


				/* *
				 * <p>Pohne robotom po oblúku so zadaným polomerom o zadaný
				 * uhol. Robot sa predvolene otáča doľava. Na obrátenie
				 * smeru otáčania zadajte záporný uhol.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     zadaného polomeru
				 * @param polomer polomer otáčania
				 * @param jemnosť jemnosť pohybu po oblúku; zodpovedá uhlu
				 *     pootočenia po každom kroku; niekedy je grafický
				 *     výsledok (paradoxne) lepší pri zadaní väčších hodnôt
				 *     (ktoré znamenajú menšiu „jemnosť“ pohybu); príliš
				 *     jemný krok môže vyústiť v príliš zubatý oblúk
				 *     spôsobený nahustením kreslených čiar na malej ploche
				 * /
				public void choďPoOblúku(double uhol, double polomer,
					double jemnosť)
				{
					if (0 == uhol || 0 == jemnosť) return;
					double pôvodnýSmer = aktuálnyUhol;
					double krok = (PI * polomer * jemnosť) / 180.0;
					double alfa = uhol >= 0 ? jemnosť : -jemnosť;
					double rotácia = alfa;
					poslednýUhol = aktuálnyUhol;
					while (abs(rotácia) <= abs(uhol))
					{
						aktuálnyUhol -= alfa;
						rotácia += alfa;
						dopredu(krok);
					}
					aktuálnyUhol = pôvodnýSmer + uhol;
					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďPoOblúku(double, double, double) choďPoOblúku}.</p> * /
				public void chodPoObluku(double uhol, double polomer, double jemnosť) { choďPoOblúku(uhol, polomer, jemnosť); }*/


				/**
				 * <p>Pohne robotom po oblúku so zadaným polomerom o zadaný
				 * uhol bez jeho nakreslenia. Robot sa predvolene otáča
				 * doľava (t. j. pri zadaní kladného uhla otáčania a kladného
				 * polomeru sa robot pri pohybe dopredu otáča doľava, čiže sa
				 * pohybuje po ľavotočivom oblúku). Na obrátenie smeru
				 * otáčania (pohyb po pravotočivom oblúku) zadajte záporný
				 * polomer otáčania. Pri zadaní záporného uhla bude robot
				 * cúvať. Keď je polomer rovný nule, robot zostane stáť aj
				 * v prípade, že je uhol nenulový, pretože nie je možné
				 * určiť vzdialenosť akú by mal prejsť.</p>
				 * 
				 * <p class="attention"><b>Upozornenie:</b> Vo verzii 2.0
				 * sa zmenil predvolený smer otáčania robota!</p>
				 *
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     zadaného polomeru
				 * @param polomer polomer otáčania
				 * 
				 * @see #dopredu(double) dopredu
				 * @see #vzad(double) vzad
				 * @see #vpravo(double) vpravo
				 * @see #vľavo(double) vľavo
				 * @see #choďNa(double, double) choďNa
				 * @see #skočNa(double, double) skočNa
				 * @see #skočPoOblúku(double)
				 * @see #skočPoOblúku()
				 * @see #choďPoOblúku(double, double)
				 * @see #choďNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 * @see #choďNaPoOblúku(Poloha)
				 * @see #skočNaPoOblúku(Poloha)
				 */
				public void skočPoOblúku(double uhol, double polomer)
				{
					// ‼ Keď je polomer rovný nule, robot zostane stáť aj
					// v prípade, že je uhol nenulový ‼ (V podstate je
					// akoby zaseknutý, neschopný otáčať sa na mieste.)
					if (0 == uhol || 0 == polomer) return;

					// (Potrebné do lambda výrazu v registrujPretočOhraničenie,
					// lebo premenná musí byť „efektívne konečná“.)
					double uhol2 = uhol, polomer2 = polomer;

					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
						poslednýUhol = aktuálnyUhol;
					}

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);
					double priemer;

					Arc2D.Double oblúk;

					// Pôvodné správanie metódy (ako bolo navrhnuté) trochu
					// skomplikovalo výpočty, tak sme to zjednodušili
					// a rozdelili na dve vetvy…

					// Keďže oblúk je teraz kreslený s pomocou tvaru Javy, bolo
					// treba vyriešiť presunutie robota na novú pozíciu. Je
					// riešené tromi jednoduchými krokmi: posunom robota do
					// stredu otáčania, pootočením o uhol otáčania a posunom
					// späť na dráhu oblúka…

					if (polomer >= 0)
					{
						priemer = 2 * polomer;

						prepočítanéX -= polomer * (1 - cos(
							toRadians(aktuálnyUhol + 90)));
						prepočítanéY -= polomer * (1 + sin(
							toRadians(aktuálnyUhol + 90)));

						oblúk = new Arc2D.Double(prepočítanéX, prepočítanéY,
							priemer, priemer, aktuálnyUhol + 270, uhol,
							Arc2D.OPEN);

						// posuňVľavo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol + 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol + 90)) * polomer;

						// doľava…
						aktuálnyUhol += uhol;
						aktuálnyUhol %= 360;
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;

						// posuňVpravo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol - 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol - 90)) * polomer;
					}
					else
					{
						polomer = -polomer;
						priemer = 2 * polomer;

						prepočítanéX -= polomer * (1 - cos(
							toRadians(aktuálnyUhol - 90)));
						prepočítanéY -= polomer * (1 + sin(
							toRadians(aktuálnyUhol - 90)));

						oblúk = new Arc2D.Double(prepočítanéX, prepočítanéY,
							priemer, priemer, aktuálnyUhol + 90, -uhol,
							Arc2D.OPEN);

						// posuňVpravo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol - 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol - 90)) * polomer;

						// doprava…
						aktuálnyUhol -= uhol;
						aktuálnyUhol %= 360;
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;

						// posuňVľavo…
						aktuálneX += cos(toRadians(
							aktuálnyUhol + 90)) * polomer;
						aktuálneY += sin(toRadians(
							aktuálnyUhol + 90)) * polomer;
					}


					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.append(oblúk.getPathIterator(null), true);
						else
							cesta.moveTo(
								Svet.prepočítajX(aktuálneX),
								Svet.prepočítajY(aktuálneY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							{ skočPoOblúku(uhol2, polomer2); });
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočPoOblúku(double, double) skočPoOblúku}.</p> */
				public void skocPoObluku(double uhol, double polomer)
				{ skočPoOblúku(uhol, polomer); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o zadaný uhol a v prípade, že je položené pero,
				 * tak oblúk aj nakreslí. Ďalej platia rovnaké informácie
				 * ako pri metóde {@link #choďPoOblúku(double, double)
				 * choďPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     polomeru určeného veľkosťou robota
				 * 
				 * @see #choďPoOblúku(double, double)
				 * @see #veľkosť()
				 */
				public void choďPoOblúku(double uhol)
				{ choďPoOblúku(uhol, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #choďPoOblúku(double) choďPoOblúku}.</p> */
				public void chodPoObluku(double uhol)
				{ choďPoOblúku(uhol, veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o zadaný uhol bez jeho nakreslenia. Ďalej platia
				 * rovnaké informácie ako pri metóde
				 * {@link #skočPoOblúku(double, double)
				 * skočPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     polomeru určeného veľkosťou robota
				 * 
				 * @see #skočNaPoOblúku(double, double)
				 * @see #veľkosť()
				 */
				public void skočPoOblúku(double uhol)
				{ skočPoOblúku(uhol, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #skočPoOblúku(double) skočPoOblúku}.</p> */
				public void skocPoObluku(double uhol)
				{ skočPoOblúku(uhol, veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o aktuálny uhol otáčania a v prípade, že je položené
				 * pero, tak oblúk aj nakreslí. Pozri metódy {@link #veľkosť()}
				 * a {@link #uholOtáčania()}. Ďalej platia rovnaké informácie
				 * ako pri metóde {@link #choďPoOblúku(double, double)
				 * choďPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @see #choďPoOblúku(double, double)
				 * @see #veľkosť()
				 * @see #uholOtáčania()
				 */
				public void choďPoOblúku()
				{ choďPoOblúku(uholOtáčania, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #choďPoOblúku(double) choďPoOblúku}.</p> */
				public void chodPoObluku()
				{ choďPoOblúku(uholOtáčania, veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o aktuálny uhol otáčania bez nakreslenia oblúka.
				 * Pozri metódy {@link #veľkosť()} a {@link #uholOtáčania()}.
				 * Ďalej platia rovnaké informácie ako pri metóde
				 * {@link #skočPoOblúku(double, double)
				 * skočPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @see #skočNaPoOblúku(double, double)
				 * @see #veľkosť()
				 * @see #uholOtáčania()
				 */
				public void skočPoOblúku()
				{ skočPoOblúku(uholOtáčania, veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #skočPoOblúku(double) skočPoOblúku}.</p> */
				public void skocPoObluku()
				{ skočPoOblúku(uholOtáčania, veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o zadaný uhol a v prípade, že je položené pero,
				 * tak oblúk aj nakreslí. Ak je hodnota parametra
				 * {@code vpravo} rovná {@code valtrue}, tak sa robot bude
				 * otáčať doprava. Inak platia rovnaké informácie
				 * ako pri metóde {@link #choďPoOblúku(double, double)
				 * choďPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     polomeru určeného veľkosťou robota
				 * @param vpravo ak je táto hodnota rovná {@code valtrue},
				 *     tak sa robot bude otáčať doprava
				 * 
				 * @see #choďPoOblúku(double, double)
				 * @see #veľkosť()
				 */
				public void choďPoOblúku(double uhol, boolean vpravo)
				{ choďPoOblúku(uhol, vpravo ? -veľkosť : veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #choďPoOblúku(double) choďPoOblúku}.</p> */
				public void chodPoObluku(double uhol, boolean vpravo)
				{ choďPoOblúku(uhol, vpravo ? -veľkosť : veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o zadaný uhol bez jeho nakreslenia. Ak je hodnota
				 * parametra {@code vpravo} rovná {@code valtrue}, tak sa
				 * robot bude otáčať doprava. Inak platia rovnaké informácie
				 * ako pri metóde {@link #skočPoOblúku(double, double)
				 * skočPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param uhol uhol, o ktorý sa má robot otočiť okolo
				 *     polomeru určeného veľkosťou robota
				 * @param vpravo ak je táto hodnota rovná {@code valtrue},
				 *     tak sa robot bude otáčať doprava
				 * 
				 * @see #skočNaPoOblúku(double, double)
				 * @see #veľkosť()
				 */
				public void skočPoOblúku(double uhol, boolean vpravo)
				{ skočPoOblúku(uhol, vpravo ? -veľkosť : veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #skočPoOblúku(double) skočPoOblúku}.</p> */
				public void skocPoObluku(double uhol, boolean vpravo)
				{ skočPoOblúku(uhol, vpravo ? -veľkosť : veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o aktuálny uhol otáčania a v prípade, že je položené
				 * pero, tak oblúk aj nakreslí. Pozri metódy {@link #veľkosť()}
				 * a {@link #uholOtáčania()}. Ak je hodnota parametra
				 * {@code vpravo} rovná {@code valtrue}, tak sa robot bude
				 * otáčať doprava. Inak platia rovnaké informácie
				 * ako pri metóde {@link #choďPoOblúku(double, double)
				 * choďPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param vpravo ak je táto hodnota rovná {@code valtrue},
				 *     tak sa robot bude otáčať doprava
				 * 
				 * @see #choďPoOblúku(double, double)
				 * @see #veľkosť()
				 * @see #uholOtáčania()
				 */
				public void choďPoOblúku(boolean vpravo)
				{ choďPoOblúku(uholOtáčania, vpravo ? -veľkosť : veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #choďPoOblúku(double) choďPoOblúku}.</p> */
				public void chodPoObluku(boolean vpravo)
				{ choďPoOblúku(uholOtáčania, vpravo ? -veľkosť : veľkosť); }


				/**
				 * <p>Pohne robotom po oblúku s polomerom rovným veľkosti
				 * robota o aktuálny uhol otáčania bez nakreslenia oblúka.
				 * Pozri metódy {@link #veľkosť()} a {@link #uholOtáčania()}.
				 * Ak je hodnota parametra {@code vpravo} rovná
				 * {@code valtrue}, tak sa robot bude otáčať doprava. Inak
				 * platia rovnaké informácie ako pri metóde
				 * {@link #skočPoOblúku(double, double)
				 * skočPoOblúku(uhol, polomer)}.</p>
				 * 
				 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
				 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
				 * 
				 * @param vpravo ak je táto hodnota rovná {@code valtrue},
				 *     tak sa robot bude otáčať doprava
				 * 
				 * @see #skočNaPoOblúku(double, double)
				 * @see #veľkosť()
				 * @see #uholOtáčania()
				 */
				public void skočPoOblúku(boolean vpravo)
				{ skočPoOblúku(uholOtáčania, vpravo ? -veľkosť : veľkosť); }

				/** <p><a class="alias"></a> Alias pre {@link #skočPoOblúku(double) skočPoOblúku}.</p> */
				public void skocPoObluku(boolean vpravo)
				{ skočPoOblúku(uholOtáčania, vpravo ? -veľkosť : veľkosť); }


				// Súkromný atribút slúžiaci niektorým metódam (momentálne
				// už len pohyb po oblúku…) na uchovanie súradníc priesečníka
				// úsečiek.
				private Bod pracovnýPriesečník = new Bod(0, 0);


				/**
				 * <p>Pohne robotom po oblúku do cieľového bodu určeného
				 * súradnicami [x, y] s ohľadom na aktuálne otočenie robota.
				 * Ak robot smeruje približne na miesto súradníc (s odchýlkou
				 * ±0,0001°), tak sa pohne do cieľového miesta po úsečke
				 * (pričom bude pootočený o nepatrnú odchýlku). Ak má robot
				 * položené pero, tak pri pohybe kreslí čiaru. Robot nesmie
				 * smerovať presne opačným smerom od cieľového miesta, inak
				 * vznikne výnimka.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Situácia so vznikom
				 * výnimky by sa s cieľom zvýšenia komfortu práce
				 * s programovacím rámcom dala vyriešiť generovaním dvoch
				 * úsečiek – jednej smerujúcej z aktuálnej pozície do
				 * „nekonečna“ v smere robota a druhej prichádzajúca z opačnej
				 * strany (z „protiľahlého nekonečna“) do cieľového bodu.
				 * Problém je v definovaní nekonečna. Aké úsečky by boli
				 * dostatočne dlhé na to, aby smerovali zdanlivo do nekonečna
				 * a aby pritom nevznikali prípadné nežiadúce skreslenia,
				 * ktoré sa v niektorých prípadoch prejavujú pri práci
				 * s údajovým typom {@code double}? Robot navyše pri kreslení
				 * generuje tvary Javy, ktoré sa môžu stať súčasťou zachytenej
				 * cesty. Tá môže byť exportovaná mimo programovací rámec.
				 * Vždy by sa našiel spôsob, ktorý by tento „malý trik“
				 * odhalil, preto táto metóda radšej generuje výnimku
				 * a vyriešenie situácie ponecháva na programátora
				 * používajúceho tento programovací rámec.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <pre CLASS="example">
					{@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; {@code num360}; i += {@code num2.5})
					{
						{@link #uhol(double) uhol}(i);
						{@link #skočNa(double, double) skočNa}(-{@code num100}, {@code num0});
						{@code kwdif} (i != {@code num180})
							{@code currchoďNaPoOblúku}({@code num100}, {@code num0});
					}
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>chod-na-po-obluku.png<alt/>Použitie metódy
				 * choďNaPoOblúku.</image>Vzor pripomínajúci siločiary
				 * nakreslený s pomocou metódy
				 * {@code currchoďNaPoOblúku}.</p>
				 * 
				 * @param x x-ová súradnica cieľového bodu
				 * @param y y-ová súradnica cieľového bodu
				 * 
				 * @throws GRobotException ak je robot obrátený opačným smerom
				 *     než sa nachádza cieľový bod (o 180° smerom od neho)
				 * 
				 * @see #choďNa(double, double) choďNa
				 * @see #choďPoOblúku(double, double)
				 * @see #skočPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 * @see #polohaPera() polohaPera
				 */
				public void choďNaPoOblúku(double x, double y)
				{
					// Táto metóda bola zaplatená „krvou a potom.“ Výpočty,
					// testy, neúspechy… Trvalo to asi týždeň. Originál je
					// v súbore TestChoďNaPoOblúku.java

					if (aktuálneX == x && aktuálneY == y)
					{
						if (peroPoložené) bod();
						return;
					}

					// Jeden pracovný uhol je uhol kolmý na cieľ
					double pracovnýUhol1 = (90 + toDegrees(atan2(
						y - aktuálneY, x - aktuálneX))) % 360;
					if (pracovnýUhol1 < 0) pracovnýUhol1 += 360;

					// Druhý pracovný uhol je kolmý na aktuálnu polohu
					double pracovnýUhol2 = (90 + aktuálnyUhol) % 360;
					if (pracovnýUhol2 < 0) pracovnýUhol2 += 360;

					// Rozdiel pracovných uhlov je odchýlka aktuálneho smeru od
					// polohy cieľa
					double δ = (pracovnýUhol1 - pracovnýUhol2) % 360;
					if (δ < 0) δ += 360;

					// Pri veľmi malej odchýlke je orientácia robota
					// považovaná za súhlasnú so smerom kreslenia oblúka
					// a preto sa nakreslí do cieľa úsečka – vykoná sa príkaz
					// choďNa(x, y) – je tu určité skreslenie, ktoré by však
					// nemalo prekážať, prekážalo by len pri veľmi veľkých
					// vzdialenostiach
					if (δ < 0.0001 || δ > 359.9999)
					{
						choďNa(x, y);
						double zálohaUhla = aktuálnyUhol;
						aktuálnyUhol += δ;
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;

						uhol(aktuálnyUhol);
						poslednýUhol = zálohaUhla;
						return;
					}
					else if (δ > 179.9999 && δ < 180.0001)
					{
						// Oprava: V dôsledku chýb pri práci s údajovým
						// typom double nevznikala táto výnimka tam, kde mala
						// (nižšie – v bloku catch, pretože sa pri výpočte
						// „neukázala“ paralelnosť úsečiek hľadaného
						// priesečníka). Namiesto toho bol vypočítaný
						// nezmyselný oblúk s gigantickým polomerom (ktorý
						// sa navyše vôbec nezačínal na aktuálnej polohe
						// robota).
						throw new GRobotException(
							"Robot je obrátený presne opačným smerom od " +
							"cieľového miesta kreslenia oblúka – musel by " +
							"prejsť nekonečnom, aby sa do cieľa dostal.",
							"robotHeadsToOpositeDirection");
					}

					// System.out.println("δ: " + δ);

					// Počítame súradnice chýbajúcich bodov úsečiek, ktoré
					// budú použité na nájdenie priesečníka a ten určí stred
					// kružnice oblúka

					// Stred vzdialenosti medzi aktuálnou a cieľovou pozíciou
					double x0 = (x + aktuálneX) / 2;
					double y0 = (y + aktuálneY) / 2;

					// System.out.println("x0: " + x0);
					// System.out.println("y0: " + y0);

					// Podľa smeru sa prepočítajú súradnice druhého bodu
					double x1 = x0 + cos(toRadians(pracovnýUhol1));
					double y1 = y0 + sin(toRadians(pracovnýUhol1));

					// System.out.println("x1: " + x1);
					// System.out.println("y1: " + y1);

					// Aktuálnu polohu máme, takže len podľa smeru prepočítame
					// druhú súradnicu
					double x2 = aktuálneX + cos(toRadians(pracovnýUhol2));
					double y2 = aktuálneY + sin(toRadians(pracovnýUhol2));

					// System.out.println("x2: " + x2);
					// System.out.println("y2: " + y2);

					try
					{
						double x3, y3;

						synchronized (pracovnýPriesečník)
						{
							// Skúsime nájsť priesečník
							Svet.priesečníkÚsečiek(aktuálneX, aktuálneY,
								x2, y2, x0, y0, x1, y1, pracovnýPriesečník);

							// Ak je nájdený, prevezmeme jeho súradnice do
							// premenných, ktoré si hodnoty budú uchovávať
							x3 = pracovnýPriesečník.getX();
							y3 = pracovnýPriesečník.getY();
						}

						// System.out.println("x3: " + x3);
						// System.out.println("y3: " + y3);

						// Vypočítame polomer kružnice oblúka
						double polomer = hypot(x3 - aktuálneX, y3 - aktuálneY);

						// System.out.println("polomer: " + polomer);

						// Podľa toho, či je odchýlka vypočítaná vyššie menšia
						// alebo väčšia než 180° nakreslíme iný typ oblúka
						if (δ < 180)
						{
							// — uhol kreslenia oblúka —
							double uhol = (toDegrees(atan2(y3 - y,
								x3 - x)) - pracovnýUhol2) % 360;
							if (uhol < 0) uhol += 360;

							// System.out.println("uhol 1: " + uhol);

							choďPoOblúku(uhol, polomer);
						}
						else
						{
							// — uhol kreslenia oblúka —
							double uhol = (180 + pracovnýUhol2 -
								toDegrees(atan2(y3 - y, x3 - x))) % 360;
							if (uhol < 0) uhol += 360;

							// System.out.println("uhol 2: " + uhol);

							choďPoOblúku(uhol, -polomer);
						}
					}
					catch (RuntimeException e)
					{
						// Keď ide o rovnobežné priamky, tak to znamená, že
						// robot smeruje „naopak“ (súhlasný smer bol vyriešený
						// vyššie, ten protichodný je tu)…
						// (Podobne ako pri riešení vyššie (hľadaj volanie
						// metódy choďNa) by sa aj tu dali nakresliť dve
						// úsečky – jedna smerujúca z pozície robota „do
						// nekonečna“ (mimo plátno) a druhá prichádzajúca
						// „z iného nekonečna“ a končiaca sa v cieľovom bode.
						// Výsledkom kreslenia by bola priamka, v ktorej by
						// chýbal úsek medzi pôvodnou polohou robota
						// a cieľovou polohou robota. Toto riešenie však bolo
						// zamietnuté. V prípade potreby ho môže skúsiť
						// doplniť programátor na základe vzniku tejto
						// výnimky.)
						throw new GRobotException(
							"Robot je obrátený presne opačným smerom od " +
							"cieľového miesta kreslenia oblúka – musel by " +
							"prejsť nekonečnom, aby sa do cieľa dostal.",
							"robotHeadsToOpositeDirection");
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaPoOblúku(double, double) choďNaPoOblúku}.</p> */
				public void chodNaPoObluku(double x, double y)
				{ choďNaPoOblúku(x, y); }

				/**
				 * <p>Funguje rovnako ako {@link #choďNaPoOblúku(double, double)
				 * choďNaPoOblúku(x, y)}, ale namiesto samostatných súradníc
				 * prijíma implementáciu rozhrania {@link Poloha Poloha}
				 * (napríklad {@link Bod Bod}).</p>
				 * 
				 * @param poloha objekt určujúci súradnice cieľového bodu
				 * 
				 * @throws GRobotException ak je robot obrátený opačným smerom
				 *     než sa nachádza cieľový bod (o 180° smerom od neho)
				 * 
				 * @see #choďPoOblúku(double, double)
				 * @see #skočPoOblúku(double, double)
				 * @see #choďNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(Poloha)
				 */
				public void choďNaPoOblúku(Poloha poloha)
				{ choďNaPoOblúku(poloha.polohaX(), poloha.polohaY()); }

				/** <p><a class="alias"></a> Alias pre {@link #choďNaPoOblúku(Poloha) choďNaPoOblúku}.</p> */
				public void chodNaPoObluku(Poloha poloha)
				{ choďNaPoOblúku(poloha.polohaX(), poloha.polohaY()); }


				/**
				 * <p>Pohne robotom po oblúku do cieľového bodu určeného
				 * súradnicami [x, y] s ohľadom na aktuálne otočenie robota
				 * bez nakreslenia oblúka. Ak robot smeruje približne na
				 * miesto súradníc (s odchýlkou ±0,0001°), tak sa pohne do
				 * cieľového miesta po úsečke (pričom bude pootočený
				 * o nepatrnú odchýlku). Robot nesmie smerovať presne opačným
				 * smerom od cieľového miesta, inak vznikne výnimka.</p>
				 * 
				 * @param x x-ová súradnica cieľového bodu
				 * @param y y-ová súradnica cieľového bodu
				 * 
				 * @throws GRobotException ak je robot obrátený opačným smerom
				 *     než sa nachádza cieľový bod (o 180° smerom od neho)
				 * 
				 * @see #skočNa(double, double) skočNa
				 * @see #choďPoOblúku(double, double)
				 * @see #skočPoOblúku(double, double)
				 * @see #choďNaPoOblúku(double, double)
				 */
				public void skočNaPoOblúku(double x, double y)
				{
					// Táto metóda bola zaplatená „krvou a potom.“ Výpočty,
					// testy, neúspechy… Trvalo to asi týždeň. Originál je
					// v súbore TestChoďNaPoOblúku.java

					if (aktuálneX == x && aktuálneY == y)
					{
						//‼‼ bod();
						return;
					}

					// Jeden pracovný uhol je uhol kolmý na cieľ
					double pracovnýUhol1 = (90 + toDegrees(atan2(
						y - aktuálneY, x - aktuálneX))) % 360;
					if (pracovnýUhol1 < 0) pracovnýUhol1 += 360;

					// Druhý pracovný uhol je kolmý na aktuálnu polohu
					double pracovnýUhol2 = (90 + aktuálnyUhol) % 360;
					if (pracovnýUhol2 < 0) pracovnýUhol2 += 360;

					// Rozdiel pracovných uhlov je odchýlka aktuálneho smeru od
					// polohy cieľa
					double δ = (pracovnýUhol1 - pracovnýUhol2) % 360;
					if (δ < 0) δ += 360;

					// Pri veľmi malej odchýlke je orientácia robota
					// považovaná za súhlasnú so smerom kreslenia oblúka
					// a preto sa nakreslí do cieľa úsečka – vykoná sa príkaz
					// choďNa(x, y) – je tu určité skreslenie, ktoré by však
					// nemalo prekážať, prekážalo by len pri veľmi veľkých
					// vzdialenostiach
					if (δ < 0.0001 || δ > 359.9999)
					{
						skočNa(x, y);
						double zálohaUhla = aktuálnyUhol;
						aktuálnyUhol += δ;
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;

						uhol(aktuálnyUhol);
						poslednýUhol = zálohaUhla;
						return;
					}

					// Počítame súradnice chýbajúcich bodov úsečiek, ktoré
					// budú použité na nájdenie priesečníka a ten určí stred
					// kružnice oblúka

					// Stred vzdialenosti medzi aktuálnou a cieľovou pozíciou
					double x0 = (x + aktuálneX) / 2;
					double y0 = (y + aktuálneY) / 2;

					// Podľa smeru sa prepočítajú súradnice druhého bodu
					double x1 = x0 + cos(toRadians(pracovnýUhol1));
					double y1 = y0 + sin(toRadians(pracovnýUhol1));

					// Aktuálnu polohu máme, takže len podľa smeru prepočítame
					// druhú súradnicu
					double x2 = aktuálneX + cos(toRadians(pracovnýUhol2));
					double y2 = aktuálneY + sin(toRadians(pracovnýUhol2));

					try
					{
						double x3, y3;

						synchronized (pracovnýPriesečník)
						{
							// Skúsime nájsť priesečník
							Svet.priesečníkÚsečiek(aktuálneX, aktuálneY,
								x2, y2, x0, y0, x1, y1, pracovnýPriesečník);

							// Ak je nájdený, prevezmeme jeho súradnice do
							// premenných, ktoré si hodnoty budú uchovávať
							x3 = pracovnýPriesečník.getX();
							y3 = pracovnýPriesečník.getY();
						}

						// Vypočítame polomer kružnice oblúka
						double polomer = hypot(x3 - aktuálneX, y3 - aktuálneY);

						// Podľa toho, či je odchýlka vypočítaná vyššie menšia
						// alebo väčšia než 180° nakreslíme iný typ oblúka
						if (δ < 180)
						{
							// — uhol kreslenia oblúka —
							double uhol = (toDegrees(atan2(y3 - y,
								x3 - x)) - pracovnýUhol2) % 360;
							if (uhol < 0) uhol += 360;

							skočPoOblúku(uhol, polomer);
						}
						else
						{
							// — uhol kreslenia oblúka —
							double uhol = (180 + pracovnýUhol2 -
								toDegrees(atan2(y3 - y, x3 - x))) % 360;
							if (uhol < 0) uhol += 360;

							skočPoOblúku(uhol, -polomer);
						}
					}
					catch (RuntimeException e)
					{
						// Keď ide o rovnobežné priamky, tak to znamená, že
						// robot smeruje „naopak“ (súhlasný smer bol vyriešený
						// vyššie, ten protichodný je tu)…
						// (Podobne ako pri riešení vyššie (hľadaj volanie
						// metódy choďNa) by sa aj tu dali nakresliť dve
						// úsečky – jedna smerujúca z pozície robota „do
						// nekonečna“ (mimo plátno) a druhá prichádzajúca
						// „z iného nekonečna“ a končiaca sa v cieľovom bode.
						// Výsledkom kreslenia by bola priamka, v ktorej by
						// chýbal úsek medzi pôvodnou polohou robota
						// a cieľovou polohou robota. Toto riešenie však bolo
						// zamietnuté. V prípade potreby ho môže skúsiť
						// doplniť programátor na základe vzniku tejto
						// výnimky.)
						throw new GRobotException(
							"Robot je obrátený presne opačným smerom od " +
							"cieľového miesta kreslenia oblúka – musel by " +
							"prejsť nekonečnom, aby sa do cieľa dostal.",
							"robotHeadsToOpositeDirection");
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaPoOblúku(double, double) skočNaPoOblúku}.</p> */
				public void skocNaPoObluku(double x, double y)
				{ skočNaPoOblúku(x, y); }

				/**
				 * <p>Funguje rovnako ako {@link #skočNaPoOblúku(double, double)
				 * skočNaPoOblúku(x, y)}, ale namiesto samostatných súradníc
				 * prijíma implementáciu rozhrania {@link Poloha Poloha}
				 * (napríklad {@link Bod Bod}).</p>
				 * 
				 * @param poloha objekt určujúci súradnice cieľového bodu
				 * 
				 * @throws GRobotException ak je robot obrátený opačným smerom
				 *     než sa nachádza cieľový bod (o 180° smerom od neho)
				 * 
				 * @see #choďPoOblúku(double, double)
				 * @see #skočPoOblúku(double, double)
				 * @see #choďNaPoOblúku(double, double)
				 * @see #skočNaPoOblúku(double, double)
				 * @see #choďNaPoOblúku(Poloha)
				 */
				public void skočNaPoOblúku(Poloha poloha)
				{ skočNaPoOblúku(poloha.polohaX(), poloha.polohaY()); }

				/** <p><a class="alias"></a> Alias pre {@link #skočNaPoOblúku(Poloha) skočNaPoOblúku}.</p> */
				public void skocNaPoObluku(Poloha poloha)
				{ skočNaPoOblúku(poloha.polohaX(), poloha.polohaY()); }


		// Aktivita

			// Aktivácia a deaktivácia

				/**
				 * <p>Overí, či je tento robot aktívny. Aktiváciu je možné
				 * dosiahnuť dvomi základnými spôsobmi:</p>
				 * 
				 * <ol>
				 * <li>klasickou {@linkplain #aktivuj() aktiváciou}, ktorá je
				 * preferovaná pri určovaní alebo zmene hodnôt {@linkplain 
				 * #rýchlosť(double) rýchlosti}, {@linkplain 
				 * #zrýchlenie(double) zrýchlenia} a pod.,</li>
				 * <li>{@linkplain #spusti() spustením}, ktoré je preferované
				 * pri stanovovaní a úprave {@linkplain #cieľ(double, double)
				 * cieľa}.</li>
				 * </ol>
				 * 
				 * @return {@code valtrue} ak je robot aktívny, inak {@code 
				 *     valfalse}
				 */
				public boolean aktívny() { return aktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #aktívny() aktívny}.</p> */
				public boolean aktivny() { return aktívny; }

				/**
				 * <p>Overí, či je tento robot neaktívny. Vracia presne opačnú
				 * informáciu ako metóda {@link #aktívny() aktívny}.</p>
				 * 
				 * @return {@code valtrue} ak nie je robot aktívny, inak
				 *     {@code valfalse}
				 */
				public boolean neaktívny() { return !aktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #neaktívny() neaktívny}.</p> */
				public boolean neaktivny() { return !aktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #neaktívny() neaktívny}.</p> */
				public boolean pasívny() { return !aktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #neaktívny() neaktívny}.</p> */
				public boolean pasivny() { return !aktívny; }

				/**
				 * <p>Aktivuje robot a {@linkplain Svet#spustiČasovač()
				 * spustí časovač} (ak je nečinný). Metóda upozorní robot
				 * na aktiváciu volaním metódy {@link #aktivácia() aktivácia}.
				 * 
				 * Táto metóda je automaticky spustená metódou {@link 
				 * #pracuj() pracuj}, po uplynutí času pasivity (pozri
				 * napríklad {@link #deaktivuj(int)
				 * deaktivuj(trvaniePasivity)}), ak bol tento čas určený.
				 * 
				 * Opakom aktivácie je {@linkplain #deaktivuj() deaktivácia}
				 * a alternatívou aktivácie je {@linkplain #spusti()
				 * spustenie}, ktoré je preferované v iných situáciách –
				 * pozri informácie pri metóde {@link #aktívny() aktívny}.</p>
				 * 
				 * @see #deaktivuj()
				 * @see #spusti()
				 */
				public void aktivuj() { aktivuj(0, true); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #aktivuj()
				 * aktivuj()}, ibaže dovoľuje programátorovi určiť trvanie
				 * aktivity. Trvanie je určené celým číslom, ktoré vyjadruje
				 * počet {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 * Svet#spustiČasovač(double) časovača}, po ktorých je robot
				 * automaticky {@linkplain #deaktivuj()
				 * deaktivovaný}<sup>[1]</sup>. Po uplynutí času trvania
				 * aktivity je robot deaktivovaný spustením metódy
				 * {@link #deaktivuj() deaktivuj}.</p>
				 * 
				 * <p><small>[1] – ak chceme získať údaj v sekundách, tak
				 * musíme trvanie aktivity násobiť
				 * {@linkplain Svet#intervalČasovača() intervalom časovača};
				 * avšak spúšťanie {@linkplain ObsluhaUdalostí#tik() tikov}
				 * {@linkplain Svet#spustiČasovač(double) časovača} nikdy nie
				 * je úplne presné, preto ani vypočítaný údaj v sekundách
				 * nikdy nebude úplne presný – skutočný čas aktivity robota
				 * sa môže líšiť podľa momentálneho zaťaženia
				 * systému…</small></p>
				 * 
				 * @param trvanieAktivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých nastane
				 *     automatická {@linkplain #deaktivuj() deaktivácia};
				 *     nula znamená aktiváciu na neurčitý čas (dokedy nie je
				 *     robot deaktivovaný iným spôsobom)
				 */
				public void aktivuj(int trvanieAktivity) { aktivuj(trvanieAktivity, true); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #aktivuj()
				 * aktivuj()} s tým, že dovoľuje programátorovi určiť, či má
				 * byť automaticky {@linkplain Svet#spustiČasovač() spustený
				 * časovač} (ak nie je v činnosti).</p>
				 * 
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 */
				public void aktivuj(boolean ajČasovač) { aktivuj(0, ajČasovač); }

				/**
				 * <p>Metóda spája funkcionalitu metód {@link #aktivuj(int)
				 * aktivuj(trvanieAktivity)} a {@link #aktivuj(boolean)
				 * aktivuj(ajČasovač)}. Platia rovnaké pravidlá ako pri
				 * spomenutých metódach…</p>
				 * 
				 * @param trvanieAktivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých nastane
				 *     automatická {@linkplain #deaktivuj() deaktivácia};
				 *     nula znamená aktiváciu na neurčitý čas (dokedy nie je
				 *     robot deaktivovaný iným spôsobom)
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 */
				public void aktivuj(int trvanieAktivity, boolean ajČasovač)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						aktívny = true;
						this.trvanieAktivity = trvanieAktivity;
					}
					if (ajČasovač)
					{
						Svet.spustiČasovač();
					}
					aktivácia();
					aktivacia();
				}

				/**
				 * <p>Deaktivuje robot (napríklad po skončení trvania
				 * aktivity). Účelom tejto metódy je deaktivovať robot
				 * a upozorniť na to inštanciu robota volaním prislúchajúcej
				 * metódy – pri spustení tejto metódy je automaticky zavolaná
				 * metóda {@link #deaktivácia() deaktivácia}. Metóda {@code 
				 * deaktivuj} je automaticky spustená aj metódou {@link 
				 * #pracuj() pracuj} po skončení trvania aktivity tohto
				 * robota (pozri napríklad {@link #aktivuj(int)
				 * aktivuj(trvanieAktivity)}). Táto metóda je opakom skupiny
				 * metód {@link #aktivuj() aktivuj} a alternatívou metódy
				 * {@link #zastav() zastav}, ktorá je preferovaná v iných
				 * prípadoch…</p>
				 * 
				 * @see #aktivuj()
				 * @see #deaktivuj()
				 * @see #deaktivuj(int)
				 * @see #deaktivuj(boolean)
				 * @see #deaktivuj(int, boolean)
				 * @see #zastav()
				 */
				public void deaktivuj() { deaktivuj(0, false); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #deaktivuj()
				 * deaktivuj()}, ibaže dovoľuje programátorovi určiť trvanie
				 * pasivity. Trvanie je určené celým číslom, ktoré vyjadruje
				 * počet {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 * Svet#spustiČasovač(double) časovača}, po ktorých je robot
				 * automaticky {@linkplain #aktivuj()
				 * aktivovaný}<sup>[1]</sup>. Po uplynutí času pasivity, je
				 * robot automaticky aktivovaný spustením metódy {@link 
				 * #aktivuj() aktivuj}.</p>
				 * 
				 * <p><small>[1] – ak chceme získať údaj v sekundách, tak
				 * musíme trvanie pasivity násobiť {@linkplain 
				 * Svet#intervalČasovača() intervalom časovača}; avšak
				 * spúšťanie {@linkplain ObsluhaUdalostí#tik() tikov}
				 * {@linkplain Svet#spustiČasovač(double) časovača} nikdy nie
				 * je úplne presné, preto ani vypočítaný údaj v sekundách
				 * nikdy nebude úplne presný – skutočný čas pasivity robota
				 * sa môže líšiť podľa momentálneho zaťaženia
				 * systému…</small></p>
				 * 
				 * @param trvaniePasivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých
				 *     nastane automatická {@linkplain #aktivuj() aktivácia};
				 *     nula znamená deaktiváciu na neurčitý čas (navždy alebo
				 *     kým nenastane aktivácia iným spôsobom)
				 */
				public void deaktivuj(int trvaniePasivity) { deaktivuj(trvaniePasivity, false); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #deaktivuj()
				 * deaktivuj()} s tým, že dovoľuje programátorovi určiť, či má
				 * byť automaticky {@linkplain Svet#spustiČasovač() spustený
				 * časovač} (ak nie je v činnosti).</p>
				 * 
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 */
				public void deaktivuj(boolean ajČasovač) { deaktivuj(0, ajČasovač); }

				/**
				 * <p>Metóda spája funkcionalitu metód {@link #deaktivuj(int)
				 * deaktivuj(trvaniePasivity)} a {@link #deaktivuj(boolean)
				 * deaktivuj(ajČasovač)}. Platia rovnaké pravidlá ako pri
				 * spomenutých metódach…</p>
				 * 
				 * @param trvaniePasivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých
				 *     nastane automatická {@linkplain #aktivuj() aktivácia};
				 *     nula znamená deaktiváciu na neurčitý čas (navždy alebo
				 *     kým nenastane aktivácia iným spôsobom)
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 * 
				 * @see #aktivuj()
				 * @see #deaktivuj()
				 * @see #deaktivuj(int)
				 * @see #deaktivuj(boolean)
				 * @see #zastav()
				 */
				public void deaktivuj(int trvaniePasivity, boolean ajČasovač)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						aktívny = false;
						this.trvaniePasivity = trvaniePasivity;
					}
					if (ajČasovač)
					{
						Svet.spustiČasovač();
					}
					deaktivácia();
					deaktivacia();
				}

				/**
				 * <p>Aktivuje robot alternatívnym spôsobom a {@linkplain 
				 * Svet#spustiČasovač() spustí časovač} (ak je nečinný).
				 * Metóda upozorní robot na spustenie (alternatívnu
				 * aktiváciu) volaním metódy {@link #spustenie() spustenie}.
				 * Opakom tohto spôsobu aktivácie je (okamžité) {@linkplain 
				 * #zastav() zastavenie} a alternatívou je klasická
				 * {@linkplain #aktivuj() aktivácia}, ktorá je preferovaná
				 * v iných situáciách – pozri informácie pri metóde {@link 
				 * #aktívny() aktívny}.</p>
				 * 
				 * @see #zastav()
				 * @see #aktivuj()
				 */
				public void spusti() { spusti(0, true); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #spusti()
				 * spusti()}, ibaže dovoľuje programátorovi určiť trvanie
				 * aktivity. Trvanie je určené celým číslom, ktoré vyjadruje
				 * počet {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 * Svet#spustiČasovač(double) časovača}, po ktorých je robot
				 * automaticky {@linkplain #deaktivuj()
				 * deaktivovaný}<sup>[1]</sup>. Bez ohľadu na to, že ide
				 * o alternatívny spôsob aktivácie, je po uplynutí trvania
				 * aktivity spustená metóda {@link #deaktivuj() deaktivuj}
				 * (čiže nie {@link #zastav() zastav}<sup>[2]</sup>).</p>
				 * 
				 * <p><small>[1] – ak chceme získať údaj v sekundách, musíme
				 * trvanie aktivity násobiť {@linkplain Svet#intervalČasovača()
				 * intervalom časovača}; avšak spúšťanie {@linkplain 
				 * ObsluhaUdalostí#tik() tikov} {@linkplain 
				 * Svet#spustiČasovač(double) časovača} nikdy nie je úplne
				 * presné, preto ani vypočítaný údaj v sekundách nikdy nebude
				 * úplne presný – skutočný čas aktivity robota sa môže líšiť
				 * podľa momentálneho zaťaženia systému…</small></p>
				 * 
				 * <p><small>[2] – vo všeobecnosti to, či je robot automaticky
				 * deaktivovaný metódou {@link #deaktivuj() deaktivuj} alebo
				 * {@link #zastav() zastav} závisí od situácie; zastavenie je
				 * viazané k dosiahnutiu cieľa, deaktivácia ku všetkým ostatným
				 * okolnostiam skončenia aktivity (vrátane tejto)…</small></p>
				 * 
				 * @param trvanieAktivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých nastane
				 *     automatická {@linkplain #deaktivuj() deaktivácia};
				 *     nula znamená deaktiváciu na neurčitý čas (navždy alebo
				 *     kým nenastane aktivácia iným spôsobom)
				 */
				public void spusti(int trvanieAktivity) { spusti(trvanieAktivity, true); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #spusti()
				 * spusti()} s tým, že dovoľuje programátorovi určiť, či má
				 * byť automaticky {@linkplain Svet#spustiČasovač() spustený
				 * časovač} (ak už nie je v činnosti).</p>
				 * 
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 */
				public void spusti(boolean ajČasovač) { spusti(0, ajČasovač); }

				/**
				 * <p>Metóda spája funkcionalitu metód {@link #spusti(int)
				 * spusti(trvanieAktivity)} a {@link #spusti(boolean)
				 * spusti(ajČasovač)}. Platia rovnaké pravidlá ako pri
				 * spomenutých metódach…</p>
				 * 
				 * @param trvanieAktivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých nastane
				 *     automatická {@linkplain #deaktivuj() deaktivácia};
				 *     nula znamená deaktiváciu na neurčitý čas (navždy alebo
				 *     kým nenastane aktivácia iným spôsobom)
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 */
				public void spusti(int trvanieAktivity, boolean ajČasovač)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						aktívny = true;
						this.trvanieAktivity = trvanieAktivity;
					}
					if (ajČasovač)
					{
						Svet.spustiČasovač();
					}
					spustenie();
					if (cieľAktívny) overDosiahnutieCieľa();
				}

				/**
				 * <p>Deaktivuje robot (napríklad po dosiahnutí cieľa).
				 * Účelom tejto metódy je deaktivovať robot, zastaviť
				 * (zrušiť) smerovanie do cieľa (pozri {@link #cieľ(double,
				 * double) cieľ} alebo niektorý jej „klon“) a upozorniť na
				 * to inštanciu robota volaním prislúchajúcej metódy – pri
				 * spustení tejto metódy je automaticky zavolaná metóda
				 * {@link #zastavenie() zastavenie}. Metóda {@code zastav}
				 * je automaticky spustená aj metódou {@link #pracuj() pracuj}
				 * po dosiahnutí určeného cieľa týmto robotom (pozri napríklad
				 * vyššie spomenutú metódu {@link #cieľ(double, double)
				 * cieľ(x, y)}). Táto metóda je opakom skupiny metód {@link 
				 * #spusti() spusti} a alternatívou metódy {@link #deaktivuj()
				 * deaktivuj}, ktorá je preferovaná v iných situáciách…</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Pozor na podobnosť názvu
				 * so skupinou metód {@link #zabrzdi() zabrzdi}, ktoré sú
				 * protikladom supiny metód {@link #rozbehniSa() rozbehniSa}
				 * a ich cieľom je zahájiť brzdenie pohybujúceho sa robota…</p>
				 * 
				 * @see #spusti()
				 * @see #zastav(int)
				 * @see #zastav(boolean)
				 * @see #zastav(int, boolean)
				 * @see #deaktivuj()
				 * @see #zastavPosun()
				 */
				public void zastav() { zastav(0, false); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #zastav()
				 * zastav()}, ibaže dovoľuje programátorovi naplánovať
				 * automatickú aktiváciu. Čas do automatickej aktivácie je
				 * určený celým číslom, ktoré vyjadruje počet {@linkplain 
				 * ObsluhaUdalostí#tik() tikov} {@linkplain 
				 * Svet#spustiČasovač(double) časovača}<sup>[1]</sup>. Bez
				 * ohľadu na to, že ide o alternatívny spôsob deaktivácie,
				 * je robot po uplynutí naplánovaného času aktivovaný metódou
				 * {@link #aktivuj() aktivuj} (čiže nie {@link #spusti()
				 * spusti}).</p>
				 * 
				 * <p><small>[1] – ak chceme získať údaj v sekundách, musíme
				 * trvanie aktivity násobiť {@linkplain Svet#intervalČasovača()
				 * intervalom časovača}; avšak spúšťanie {@linkplain 
				 * ObsluhaUdalostí#tik() tikov} {@linkplain 
				 * Svet#spustiČasovač(double) časovača} nikdy nie je úplne
				 * presné, preto ani vypočítaný údaj v sekundách nikdy nebude
				 * úplne presný – skutočný čas čakania robota v pasívnom
				 * režime na automatickú aktiváciu sa môže líšiť podľa
				 * momentálneho zaťaženia systému…</small></p>
				 * 
				 * @param trvaniePasivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých nastane
				 *     automatická {@linkplain #aktivuj() aktivácia};
				 *     nulová alebo záporná hodnota znamená, že automatická
				 *     aktivácia nie je je naplánovaná
				 * 
				 * @see #zastav()
				 * @see #zastav(boolean)
				 * @see #zastav(int, boolean)
				 * @see #zastavPosun()
				 */
				public void zastav(int trvaniePasivity) { zastav(trvaniePasivity, false); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #zastav()
				 * zastav()} s tým, že dovoľuje programátorovi určiť, či má
				 * byť automaticky {@linkplain Svet#spustiČasovač() spustený
				 * časovač} (ak už nie je v činnosti).</p>
				 * 
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 * 
				 * @see #zastav()
				 * @see #zastav(int)
				 * @see #zastav(int, boolean)
				 * @see #zastavPosun()
				 */
				public void zastav(boolean ajČasovač) { zastav(0, ajČasovač); }

				/**
				 * <p>Metóda spája funkcionalitu metód {@link #zastav(int)
				 * zastav(trvaniePasivity)} a {@link #zastav(boolean)
				 * zastav(ajČasovač)}. Platia rovnaké pravidlá ako pri
				 * spomenutých metódach…</p>
				 * 
				 * @param trvaniePasivity celé číslo určujúce počet
				 *     {@linkplain ObsluhaUdalostí#tik() tikov} {@linkplain 
				 *     Svet#spustiČasovač(double) časovača}, po ktorých nastane
				 *     automatická {@linkplain #aktivuj() aktivácia};
				 *     nulová alebo záporná hodnota znamená, že automatická
				 *     aktivácia nie je je naplánovaná
				 * @param ajČasovač ak je {@code valtrue}, je (v prípade, že
				 *     je nečinný) automaticky {@linkplain Svet#spustiČasovač()
				 *     spustený časovač}
				 * 
				 * @see #zastav()
				 * @see #zastav(int)
				 * @see #zastav(boolean)
				 * @see #zastavPosun()
				 */
				public void zastav(int trvaniePasivity, boolean ajČasovač)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						aktívny = false;
						cieľAktívny = false;
						this.trvaniePasivity = trvaniePasivity;
						if (zrýchlenie != 0.0) rýchlosť = 0.0;
						if (zrýchleniePosunu != 0.0) rýchlosťPosunu = 0.0;
						if (uhlovéZrýchlenie != 0.0) uhlováRýchlosť = 0.0;
					}
					if (ajČasovač)
					{
						Svet.spustiČasovač();
					}
					zastavenie();
				}

				/**
				 * <p>Volanie tejto metódy (či už automatické alebo ručné)
				 * spôsobí zastavenie pohybu v kolmom smere voči aktuálnej
				 * orientácii robota – zastavenie {@linkplain 
				 * #rýchlosťPosunu(double) posunu}.</p>
				 * 
				 * <p>Táto metóda je automaticky spustená pri splnení
				 * nasledujúcich podmienok:</p>
				 * 
				 * <ul>
				 * <li>{@linkplain #zrýchleniePosunu(double) zrýchlenie
				 * posunu} má nenulovú hodnotu,</li>
				 * <li>je nastavený príznak {@linkplain 
				 * #zastavPoSpomaleníPosunu() zastavenia po spomalení
				 * posunu}</li>
				 * <li>a {@linkplain #rýchlosťPosunu(double) rýchlosť posun}
				 * sa dotkla nulovej hranice.</li>
				 * </ul>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Ak je {@linkplain 
				 * #zrýchleniePosunu(double) zrýchlenie posunu} nenulové,
				 * tak nemá volanie tejto metódy zmysel. Vtedy sa dá posun
				 * zastaviť jedine nastavením nulovej {@linkplain 
				 * #rýchlosťPosunu(double) rýchlosti posunu}.</p>
				 * 
				 * <p>Úspešné vykonanie zastavenia posunu je signalizované
				 * udalosťou {@link #zastaveniePosunu() zastaveniePosunu}.</p>
				 * 
				 * @see #zastav()
				 * @see #zastav(int)
				 * @see #zastav(boolean)
				 * @see #zastav(int, boolean)
				 * @see #zastaveniePosunu()
				 * @see #rýchlosťPosunu()
				 * @see #zrýchleniePosunu()
				 * @see #zastavPoSpomaleníPosunu()
				 */
				public void zastavPosun()
				{
					if (zrýchleniePosunu != 0.0)
					{
						rýchlosťPosunu = 0.0;
						zrýchleniePosunu = 0.0;
						zastavPoSpomaleníPosunu = false;
						zastaveniePosunu();
					}
				}

				/**
				 * <p>Zisťuje aktuálnu hodnotu trvania aktivity, čo je vlastne
				 * čas meraný v {@linkplain ObsluhaUdalostí#tik() tikoch}
				 * aplikácie. Hodnota {@code num0} (alebo záporná hodnota)
				 * znamená explicitne neobmedzené trvanie aktivity. (To
				 * znamená, že nie je otvorene stanovený čas, po ktorom sa
				 * má robot deaktivovať a deaktivácia nastane buď po
				 * otvorenej výzve, alebo po vzniknutí inej vhodnej
				 * udalosti.)</p>
				 * 
				 * @return explicitne (otvorene) stanovený čas
				 *     v {@linkplain ObsluhaUdalostí#tik() tikoch} zostávajúci
				 *     do ukončenia stavu aktivity alebo nekladná hodnota
				 *     vypovedajúca o tom, že trvanie aktivity nie je
				 *     explicitne časovo obmedzené
				 */
				public int trvanieAktivity()
				{
					return trvanieAktivity;
				}

				/**
				 * <p>Umožňuje zmeniť aktuálne trvanie aktivity. Meniť túto
				 * hodnotu má zmysel len počas trvania stavu aktivity robota
				 * (napríklad v reakciách {@link #aktivácia() aktivácia}
				 * a {@link #aktivita() aktivita} alebo tesne po aktivovaní
				 * robota, napríklad metódou {@link #rýchlosť() rýchlosť}),
				 * pretože všetky metódy slúžiace na {@linkplain #aktivuj()
				 * aktiváciu} alebo {@linkplain #spusti() spustenie} robota
				 * túto hodnotu prepisujú (väčšinou na nulu, čo znamená
				 * neobmedzené trvanie).</p>
				 * 
				 * @param trvanieAktivity nový čas trvania stavu aktivity;
				 *     nekladné hodnoty (nula a záporné hodnoty) určujú,
				 *     že aktivita nemá byť otvorene časovo obmedzená
				 */
				public void trvanieAktivity(int trvanieAktivity)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.trvanieAktivity = trvanieAktivity;
					}
				}

				/**
				 * <p>Zisťuje aktuálnu hodnotu trvania pasivity. Tento čas
				 * je meraný v {@linkplain ObsluhaUdalostí#tik() tikoch}
				 * časovača. Hodnota {@code num0} (alebo záporná hodnota)
				 * znamená neobmedzené trvanie pasivity. (To znamená, že nie
				 * je stanovený čas, po ktorom sa má robot automaticky
				 * aktivovať a aktivácia nastane napríklad po vzniknutí
				 * vhodnej udalosti alebo po spustení príkazu aktivácie.)</p>
				 * 
				 * @return čas v {@linkplain ObsluhaUdalostí#tik() tikoch},
				 *     po ktorom má byť robot automaticky aktivovaný;
				 *     nulová alebo záporná hodnota znamená, že automatická
				 *     aktivácia nie je je naplánovaná
				 */
				public int trvaniePasivity()
				{
					return trvaniePasivity;
				}

				/**
				 * <p>Umožňuje zmeniť trvanie pasivity – naplánovať
				 * automatickú aktiváciu po uplynutí zadaného časového
				 * intervalu. Meniť túto hodnotu má zmysel len počas trvania
				 * stavu pasivity robota (napríklad v reakciách {@link 
				 * #deaktivácia() deaktivácia} a {@link #pasivita() pasivita}
				 * alebo tesne po deaktivácii robota, napríklad metódou {@link 
				 * #zastav() zastav}), pretože všetky metódy slúžiace na
				 * {@linkplain #deaktivuj() deaktiváciu} alebo {@linkplain 
				 * #zastav() zastavenie} robota túto hodnotu prepisujú
				 * (väčšinou na nulu, čo znamená nenaplánovanie automatickej
				 * aktivácie).</p>
				 * 
				 * @param trvaniePasivity nový čas trvania stavu pasivity;
				 *     nulová alebo záporná hodnota znamená, že automatická
				 *     aktivácia nie je je naplánovaná
				 */
				public void trvaniePasivity(int trvaniePasivity)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.trvaniePasivity = trvaniePasivity;
					}
				}


			// Rýchlosť

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu hodnotu
				 * {@linkplain #rýchlosť(double) rýchlosti} tohto robota.
				 * Nenulová rýchlosť ešte neznamená, že robot sa pohybuje.
				 * Pohybujú sa len {@linkplain #aktívny() aktívne} roboty.</p>
				 * 
				 * @return aktuálna rýchlosť tohto robota
				 */
				public double rýchlosť() { return rýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #rýchlosť() rýchlosť}.</p> */
				public double rychlost() { return rýchlosť; }

				/**
				 * <p><a class="setter"></a> Nastaví robotu novú hodnotu
				 * rýchlosti a ak je zadaná nenulová hodnota, automaticky ho
				 * {@linkplain #aktivuj() aktivuje} (čo môže viesť ku vzniku
				 * ďalších udalostí opísaných pri metóde {@link #aktivuj()
				 * aktivuj()}), aby sa mohol pohybovať. Ak je zadaná
				 * <b>nulová</b> hodnota rýchlosti, robot <b>nie je</b>
				 * automaticky {@linkplain #deaktivuj() deaktivovaný}.</p>
				 * 
				 * @param rýchlosť nová hodnota rýchlosti
				 */
				public void rýchlosť(double rýchlosť)
				{ rýchlosť(rýchlosť, true); }

				/** <p><a class="alias"></a> Alias pre {@link #rýchlosť(double) rýchlosť}.</p> */
				public void rychlost(double rýchlosť)
				{ rýchlosť(rýchlosť, true); }

				/**
				 * <p>Nastaví robotu novú hodnotu rýchlosti a dovolí
				 * programátorovi rozhodnúť, či má byť robot automaticky
				 * {@linkplain #aktivuj() aktivovaný}. Neaktívne roboty sa
				 * nepohybujú aj keď majú nastavenú nenulovú rýchlosť.</p>
				 * 
				 * @param rýchlosť nová hodnota rýchlosti
				 * @param aktivuj ak je {@code valtrue} a zadaná rýchlosť je
				 *     nenulová, automaticky aktivuje robot
				 */
				public void rýchlosť(double rýchlosť, boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.rýchlosť = rýchlosť;
						if (maximálnaRýchlosť != 0.0)
						{
							if (this.rýchlosť > maximálnaRýchlosť)
								this.rýchlosť = maximálnaRýchlosť;
							else if (this.rýchlosť < -maximálnaRýchlosť)
								this.rýchlosť = -maximálnaRýchlosť;
						}
					}

					if (aktivuj && this.rýchlosť != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #rýchlosť(double, boolean) rýchlosť}.</p> */
				public void rychlost(double rýchlosť, boolean aktivuj)
				{ rýchlosť(rýchlosť, aktivuj); }

				/**
				 * <p><a class="getter"></a> Zistí hodnotu {@linkplain 
				 * #maximálnaRýchlosť(double) maximálnej rýchlosti} tohto
				 * robota. Nula znamená „bez obmedzenia.“</p>
				 * 
				 * @return maximálna rýchlosť tohto robota
				 */
				public double maximálnaRýchlosť() { return maximálnaRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosť() maximálnaRýchlosť}.</p> */
				public double maximalnaRychlost() { return maximálnaRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosť() maximálnaRýchlosť}.</p> */
				public double najväčšiaRýchlosť() { return maximálnaRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosť() maximálnaRýchlosť}.</p> */
				public double najvacsiaRychlost() { return maximálnaRýchlosť; }

				/**
				 * <p><a class="setter"></a> Nastaví novú hodnotu maximálnej
				 * rýchlosti. Touto hodnotou bude limitovaná {@linkplain 
				 * #rýchlosť(double) rýchlosť} robota v kladom i zápornom
				 * smere. Nula znamená „bez obmedzenia.“</p>
				 * 
				 * @param maximálnaRýchlosť nová hodnota maximálnej
				 *     rýchlosti
				 */
				public void maximálnaRýchlosť(double maximálnaRýchlosť)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						if (maximálnaRýchlosť < 0.0)
							this.maximálnaRýchlosť = -maximálnaRýchlosť;
						else
							this.maximálnaRýchlosť = maximálnaRýchlosť;

						if (this.maximálnaRýchlosť != 0.0)
						{
							if (rýchlosť > this.maximálnaRýchlosť)
								rýchlosť = this.maximálnaRýchlosť;
							else if (rýchlosť < -this.maximálnaRýchlosť)
								rýchlosť = -this.maximálnaRýchlosť;
						}
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosť(double) maximálnaRýchlosť}.</p> */
				public void maximalnaRychlost(double maximálnaRýchlosť)
				{ maximálnaRýchlosť(maximálnaRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosť(double) maximálnaRýchlosť}.</p> */
				public void najväčšiaRýchlosť(double najväčšiaRýchlosť)
				{ maximálnaRýchlosť(najväčšiaRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosť(double) maximálnaRýchlosť}.</p> */
				public void najvacsiaRychlost(double najväčšiaRýchlosť)
				{ maximálnaRýchlosť(najväčšiaRýchlosť); }


			// Rýchlosť posunu

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu hodnotu
				 * {@linkplain #rýchlosťPosunu(double) rýchlosti posunu}
				 * tohto robota, čím je chápaná rýchlosť v smere kolmom
				 * na aktuálny {@linkplain #uhol() smer} robota. Nenulová
				 * rýchlosť posunu nemusí automaticky znamenať, že robot sa
				 * pohybuje. Pohybujú sa len {@linkplain #aktívny() aktívne}
				 * roboty. Kladná hodnota rýchlosti posunu znamená posúvanie
				 * sa „doprava“ – pri predvolenej orientácii robota „hore“
				 * (na sever – v uhle 90°) to znamená posun v smere uhla 0°
				 * (na východ). Záporná hodnota znamená opačný smer
				 * („doľava“).</p>
				 * 
				 * @return aktuálna rýchlosť posunu tohto robota
				 */
				public double rýchlosťPosunu() { return rýchlosťPosunu; }

				/** <p><a class="alias"></a> Alias pre {@link #rýchlosťPosunu() rýchlosťPosunu}.</p> */
				public double rychlostPosunu() { return rýchlosťPosunu; }

				/**
				 * <p><a class="setter"></a> Nastaví robotu novú hodnotu
				 * rýchlosti posunu tohto robota a ak je zadaná nenulová
				 * hodnota, tak robot automaticky {@linkplain #aktivuj()
				 * aktivuje} (čo môže viesť ku vzniku ďalších udalostí
				 * opísaných pri metóde {@link #aktivuj() aktivuj()}), aby
				 * sa mohol pohybovať. Rýchlosťou posunu sa rozumie rýchlosť
				 * v smere kolmom na aktuálny {@linkplain #uhol() smer}
				 * robota. Kladná hodnota rýchlosti posunu znamená posúvanie
				 * sa „doprava“ – pri predvolenej orientácii robota „hore“
				 * (na sever – v uhle 90°) to znamená posun v smere uhla 0°
				 * (na východ). Záporná hodnota znamená opačný smer
				 * („doľava“). Ak je zadaná <b>nulová</b> hodnota rýchlosti
				 * posunu, tak robot <b>nie je</b> automaticky {@linkplain 
				 * #deaktivuj() deaktivovaný}.</p>
				 * 
				 * @param rýchlosť posunu nová hodnota rýchlosti
				 */
				public void rýchlosťPosunu(double rýchlosťPosunu)
				{ rýchlosťPosunu(rýchlosťPosunu, true); }

				/** <p><a class="alias"></a> Alias pre {@link #rýchlosťPosunu(double) rýchlosťPosunu}.</p> */
				public void rychlostPosunu(double rýchlosťPosunu)
				{ rýchlosťPosunu(rýchlosťPosunu, true); }

				/**
				 * <p>Nastaví robotu novú hodnotu rýchlosti posunu a dovolí
				 * programátorovi rozhodnúť, či má byť robot automaticky
				 * {@linkplain #aktivuj() aktivovaný}. Neaktívne roboty sa
				 * nepohybujú aj keď majú nastavenú nenulovú rýchlosť
				 * posunu.</p>
				 * 
				 * @param rýchlosťPosunu nová hodnota rýchlosti posunu
				 * @param aktivuj ak je {@code valtrue} a zadaná rýchlosť
				 *     posunu je nenulová, tak automaticky aktivuje robot
				 */
				public void rýchlosťPosunu(double rýchlosťPosunu, boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.rýchlosťPosunu = rýchlosťPosunu;
						if (maximálnaRýchlosťPosunu != 0.0)
						{
							if (this.rýchlosťPosunu > maximálnaRýchlosťPosunu)
								this.rýchlosťPosunu = maximálnaRýchlosťPosunu;
							else if (this.rýchlosťPosunu <
								-maximálnaRýchlosťPosunu)
								this.rýchlosťPosunu = -maximálnaRýchlosťPosunu;
						}
					}

					if (aktivuj && this.rýchlosťPosunu != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #rýchlosťPosunu(double, boolean) rýchlosťPosunu}.</p> */
				public void rychlostPosunu(double rýchlosťPosunu,
					boolean aktivuj)
				{ rýchlosťPosunu(rýchlosťPosunu, aktivuj); }

				/**
				 * <p><a class="getter"></a> Zistí hodnotu {@linkplain 
				 * #maximálnaRýchlosťPosunu(double) maximálnej rýchlosti
				 * posunu} tohto robota. Nula znamená „bez obmedzenia.“</p>
				 * 
				 * @return maximálna rýchlosť posunu tohto robota
				 */
				public double maximálnaRýchlosťPosunu()
				{ return maximálnaRýchlosťPosunu; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosťPosunu() maximálnaRýchlosťPosunu}.</p> */
				public double maximalnaRychlostPosunu()
				{ return maximálnaRýchlosťPosunu; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosťPosunu() maximálnaRýchlosťPosunu}.</p> */
				public double najväčšiaRýchlosťPosunu()
				{ return maximálnaRýchlosťPosunu; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosťPosunu() maximálnaRýchlosťPosunu}.</p> */
				public double najvacsiaRychlostPosunu()
				{ return maximálnaRýchlosťPosunu; }

				/**
				 * <p><a class="setter"></a> Nastaví novú hodnotu maximálnej
				 * rýchlosti posunu. Touto hodnotou bude limitovaná
				 * {@linkplain #rýchlosťPosunu(double) rýchlosť posunu}
				 * tohto robota v kladom i zápornom smere. Nula znamená
				 * „bez obmedzenia.“</p>
				 * 
				 * @param maximálnaRýchlosťPosunu nová hodnota maximálnej
				 *     rýchlosti posunu
				 */
				public void maximálnaRýchlosťPosunu(
					double maximálnaRýchlosťPosunu)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						if (maximálnaRýchlosťPosunu < 0.0)
							this.maximálnaRýchlosťPosunu =
								-maximálnaRýchlosťPosunu;
						else
							this.maximálnaRýchlosťPosunu =
								maximálnaRýchlosťPosunu;

						if (this.maximálnaRýchlosťPosunu != 0.0)
						{
							if (rýchlosťPosunu > this.maximálnaRýchlosťPosunu)
								rýchlosťPosunu = this.maximálnaRýchlosťPosunu;
							else if (rýchlosťPosunu <
								-this.maximálnaRýchlosťPosunu)
								rýchlosťPosunu = -this.maximálnaRýchlosťPosunu;
						}
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosťPosunu(double) maximálnaRýchlosťPosunu}.</p> */
				public void maximalnaRychlostPosunu(double maximálnaRýchlosťPosunu)
				{ maximálnaRýchlosťPosunu(maximálnaRýchlosťPosunu); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosťPosunu(double) maximálnaRýchlosťPosunu}.</p> */
				public void najväčšiaRýchlosťPosunu(double najväčšiaRýchlosťPosunu)
				{ maximálnaRýchlosťPosunu(maximálnaRýchlosťPosunu); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaRýchlosťPosunu(double) maximálnaRýchlosťPosunu}.</p> */
				public void najvacsiaRychlostPosunu(double najväčšiaRýchlosťPosunu)
				{ maximálnaRýchlosťPosunu(najväčšiaRýchlosťPosunu); }


			// Uhlová rýchlosť

				/**
				 * <p><a class="getter"></a> Zistí aktuálnu hodnotu
				 * {@linkplain #uhlováRýchlosť(double) uhlovej rýchlosti}
				 * (rýchlosti otáčania) tohto robota. Kladné hodnoty znamenajú
				 * otáčanie robota doľava. Nenulová uhlová rýchlosť ešte
				 * neznamená, že robot sa otáča. Pohybujú a otáčajú sa len
				 * {@linkplain #aktívny() aktívne} roboty.</p>
				 * 
				 * @return aktuálna uhlová rýchlosť tohto robota
				 */
				public double uhlováRýchlosť() { return uhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť() uhlováRýchlosť}.</p> */
				public double uhlovaRychlost() { return uhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť() uhlováRýchlosť}.</p> */
				public double rýchlosťOtáčania() { return uhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť() uhlováRýchlosť}.</p> */
				public double rychlostOtacania() { return uhlováRýchlosť; }

				/**
				 * <p><a class="setter"></a> Nastaví novú hodnotu uhlovej
				 * rýchlosti (rýchlosti otáčania) tohto robota. Kladné
				 * hodnoty znamenajú otáčanie robota doľava. Ak je zadané
				 * nenulová hodnota, robot je automaticky {@linkplain 
				 * #aktivuj() aktivovaný}, aby sa mohol otáčať. Ak je zadaná
				 * <b>nulová</b> hodnota, robot <b>nie je</b> automaticky
				 * {@linkplain #deaktivuj() deaktivovaný}.</p>
				 * 
				 * @param uhlováRýchlosť nová hodnota uhlovej rýchlosti
				 *     (rýchlosti otáčania)
				 */
				public void uhlováRýchlosť(double uhlováRýchlosť)
				{ uhlováRýchlosť(uhlováRýchlosť, true); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť(double) uhlováRýchlosť}.</p> */
				public void uhlovaRychlost(double uhlováRýchlosť)
				{ uhlováRýchlosť(uhlováRýchlosť, true); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť(double) uhlováRýchlosť}.</p> */
				public void rýchlosťOtáčania(double uhlováRýchlosť)
				{ uhlováRýchlosť(uhlováRýchlosť, true); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť(double) uhlováRýchlosť}.</p> */
				public void rychlostOtacania(double uhlováRýchlosť)
				{ uhlováRýchlosť(uhlováRýchlosť, true); }

				/**
				 * <p>Nastaví novú hodnotu uhlovej rýchlosti (rýchlosti
				 * otáčania) tohto robota. Kladné hodnoty znamenajú otáčanie
				 * robota doľava. Argument {@code aktivuj} dovoľuje
				 * programátorovi určiť, či smie byť robot (v prípade zadania
				 * nenulovej hodnoty uhlovej rýchlosti) {@linkplain #aktivuj()
				 * aktivovaný}. Neaktívne roboty sa nepohybujú ani neotáčajú
				 * aj keď majú nastavenú nenulovú rýchlosť, resp. rýchlosť
				 * otáčania.</p>
				 * 
				 * @param uhlováRýchlosť nová hodnota uhlovej rýchlosti
				 *     (rýchlosti otáčania)
				 * @param aktivuj ak je {@code valtrue} a zadaná hodnota
				 *     uhlovej rýchlosti je nenulová, robot je {@linkplain 
				 *     #aktivuj() aktivovaný}
				 */
				public void uhlováRýchlosť(double uhlováRýchlosť,
					boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.uhlováRýchlosť = uhlováRýchlosť;
						if (maximálnaUhlováRýchlosť != 0.0)
						{
							if (this.uhlováRýchlosť >
								maximálnaUhlováRýchlosť)
								this.uhlováRýchlosť =
								maximálnaUhlováRýchlosť;
							else if (this.uhlováRýchlosť <
								-maximálnaUhlováRýchlosť)
								this.uhlováRýchlosť =
								-maximálnaUhlováRýchlosť;
						}
					}

					if (aktivuj && this.uhlováRýchlosť != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť(double, boolean) uhlováRýchlosť}.</p> */
				public void uhlovaRychlost(double uhlováRýchlosť, boolean aktivuj)
				{ uhlováRýchlosť(uhlováRýchlosť, aktivuj); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť(double, boolean) uhlováRýchlosť}.</p> */
				public void rýchlosťOtáčania(double uhlováRýchlosť, boolean aktivuj)
				{ uhlováRýchlosť(uhlováRýchlosť, aktivuj); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlováRýchlosť(double, boolean) uhlováRýchlosť}.</p> */
				public void rychlostOtacania(double uhlováRýchlosť, boolean aktivuj)
				{ uhlováRýchlosť(uhlováRýchlosť, aktivuj); }


				/**
				 * <p><a class="getter"></a> Zistí hodnotu {@linkplain 
				 * #maximálnaUhlováRýchlosť(double) maximálnej uhlovej
				 * rýchlosti} (maximálnej rýchlosti otáčania) tohto robota.
				 * Kladné hodnoty znamenajú otáčanie robota doľava. Nula
				 * znamená „bez obmedzenia.“</p>
				 * 
				 * @return maximálna uhlová rýchlosť tohto robota
				 */
				public double maximálnaUhlováRýchlosť() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double maximalnaUhlovaRychlost() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double maximálnaRýchlosťOtáčania() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double maximalnaRychlostOtacania() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double najväčšiaUhlováRýchlosť() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double najvacsiaUhlovaRychlost() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double najväčšiaRýchlosťOtáčania() { return maximálnaUhlováRýchlosť; }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť() maximálnaUhlováRýchlosť}.</p> */
				public double najvacsiaRychlostOtacania() { return maximálnaUhlováRýchlosť; }

				/**
				 * <p><a class="setter"></a> Nastaví novú hodnotu maximálnej
				 * uhlovej rýchlosti (rýchlosti otáčania). Touto hodnotou bude
				 * limitovaná {@linkplain #uhlováRýchlosť(double) rýchlosť
				 * otáčania} robota v kladom i zápornom smere. Kladné hodnoty
				 * znamenajú otáčanie robota doľava. Nulová maximálna uhlová
				 * rýchlosť znamená „bez obmedzenia.“</p>
				 * 
				 * @param maximálnaUhlováRýchlosť nová hodnota maximálnej
				 *     uhlovej rýchlosti
				 */
				public void maximálnaUhlováRýchlosť(
					double maximálnaUhlováRýchlosť)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						if (maximálnaUhlováRýchlosť < 0.0)
							this.maximálnaUhlováRýchlosť =
							-maximálnaUhlováRýchlosť;
						else
							this.maximálnaUhlováRýchlosť =
							maximálnaUhlováRýchlosť;

						if (this.maximálnaUhlováRýchlosť != 0.0)
						{
							if (uhlováRýchlosť >
								this.maximálnaUhlováRýchlosť)
								uhlováRýchlosť =
								this.maximálnaUhlováRýchlosť;
							else if (uhlováRýchlosť <
								-this.maximálnaUhlováRýchlosť)
								uhlováRýchlosť =
								-this.maximálnaUhlováRýchlosť;
						}
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void maximalnaUhlovaRychlost(double maximálnaUhlováRýchlosť)
				{ maximálnaUhlováRýchlosť(maximálnaUhlováRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void maximálnaRýchlosťOtáčania(double maximálnaUhlováRýchlosť)
				{ maximálnaUhlováRýchlosť(maximálnaUhlováRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void maximalnaRychlostOtacania(double maximálnaUhlováRýchlosť)
				{ maximálnaUhlováRýchlosť(maximálnaUhlováRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void najväčšiaUhlováRýchlosť(double najväčšiaUhlováRýchlosť)
				{ maximálnaUhlováRýchlosť(najväčšiaUhlováRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void najvacsiaUhlovaRychlost(double najväčšiaUhlováRýchlosť)
				{ maximálnaUhlováRýchlosť(najväčšiaUhlováRýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void najväčšiaRýchlosťOtáčania(double najväčšiaRýchlosťOtáčania)
				{ maximálnaUhlováRýchlosť(najväčšiaRýchlosťOtáčania); }

				/** <p><a class="alias"></a> Alias pre {@link #maximálnaUhlováRýchlosť(double) maximálnaUhlováRýchlosť}.</p> */
				public void najvacsiaRychlostOtacania(double najväčšiaRýchlosťOtáčania)
				{ maximálnaUhlováRýchlosť(najväčšiaRýchlosťOtáčania); }


			// Zrýchlenie

				/**
				 * <p><a class="getter"></a> Zistí hodnotu {@linkplain 
				 * #zrýchlenie(double) zrýchlenia} tohto robota. Nenulová
				 * hodnota ešte neznamená, že robot sa pohybuje. Pohybujú sa
				 * len {@linkplain #aktívny() aktívne} roboty.</p>
				 * 
				 * @return zrýchlenie tohto robota
				 */
				public double zrýchlenie() { return zrýchlenie; }

				/** <p><a class="alias"></a> Alias pre {@link #zrýchlenie() zrýchlenie}.</p> */
				public double zrychlenie() { return zrýchlenie; }

				/**
				 * <p><a class="setter"></a> Nastaví robotu novú hodnotu
				 * zrýchlenia. V prípade zadania nenulovej hodnoty, je robot
				 * automaticky {@linkplain #aktivuj() aktivovaný}, aby sa
				 * mohol začať pohybovať. Ak má robot nastavenú {@linkplain 
				 * #maximálnaRýchlosť(double) maximálnu rýchlosť}, bude
				 * zrýchľovať až kým ju nedosiahne, inak bude zrýchľovať
				 * donekonečna. Ak majú hodnoty {@linkplain #rýchlosť(double)
				 * rýchlosti} a zrýchlenia rôzne znamienka, robot postupne
				 * spomaľuje a keď dosiahne hranicu nulovej rýchlosti, tak sa
				 * buď zastaví (ak má prikázané {@linkplain 
				 * #zastavPoSpomalení() zastaviť po spomalení}), alebo sa
				 * začne pohybovať opačným smerom (t. j. ak išiel dopredu,
				 * začne cúvať a naopak).</p>
				 * 
				 * @param zrýchlenie nová hodnota zrýchlenia
				 */
				public void zrýchlenie(double zrýchlenie)
				{ zrýchlenie(zrýchlenie, true); }

				/** <p><a class="alias"></a> Alias pre {@link #zrýchlenie(double) zrýchlenie}.</p> */
				public void zrychlenie(double zrýchlenie)
				{ zrýchlenie(zrýchlenie, true); }

				/**
				 * <p>Metóda funguje rovnako ako metóda {@link 
				 * #zrýchlenie(double) zrýchlenie(double zrýchlenie)}, ale
				 * dovoľuje programátorovi určiť, či smie byť robot
				 * (v prípade zadania nenulového zrýchlenia) {@linkplain 
				 * #aktivuj() aktivovaný}.</p>
				 * 
				 * @param zrýchlenie nová hodnota zrýchlenia
				 * @param aktivuj ak je {@code valtrue} a zadaná hodnota
				 *     zrýchlenia je nenulová, robot je {@linkplain 
				 *     #aktivuj() aktivovaný}
				 */
				public void zrýchlenie(double zrýchlenie, boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.zrýchlenie = zrýchlenie;
					}
					if (aktivuj && zrýchlenie != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrýchlenie(double, boolean) zrýchlenie}.</p> */
				public void zrychlenie(double zrýchlenie, boolean aktivuj)
				{ zrýchlenie(zrýchlenie, aktivuj); }


			// Zrýchlenie posunu

				/**
				 * <p><a class="getter"></a> Zistí hodnotu {@linkplain 
				 * #zrýchleniePosunu(double) zrýchlenia posunu} tohto robota.
				 * (Je to zrýchlenie v smere kolmom na aktuálny {@linkplain 
				 * #uhol() smer} robota. Pozri aj {@linkplain 
				 * #rýchlosťPosunu(double) rýchlosťPosunu}.) Nenulová hodnota
				 * automaticky neznamená, že sa robot pohybuje. Pohybujú sa
				 * len {@linkplain #aktívny() aktívne} roboty.</p>
				 * 
				 * @return zrýchlenie posunu tohto robota
				 */
				public double zrýchleniePosunu() { return zrýchleniePosunu; }

				/** <p><a class="alias"></a> Alias pre {@link #zrýchleniePosunu() zrýchleniePosunu}.</p> */
				public double zrychleniePosunu() { return zrýchleniePosunu; }

				/**
				 * <p><a class="setter"></a> Nastaví robotu novú hodnotu
				 * zrýchlenia posunu. V prípade zadania nenulovej hodnoty,
				 * je robot automaticky {@linkplain #aktivuj() aktivovaný},
				 * aby sa mohol začať pohybovať. Ak má robot nastavenú
				 * {@linkplain #maximálnaRýchlosťPosunu(double) maximálnu
				 * rýchlosť posunu}, bude zrýchľovať až kým ju nedosiahne,
				 * inak bude zrýchľovať donekonečna. Ak majú hodnoty
				 * {@linkplain #rýchlosťPosunu(double) rýchlosti posunu}
				 * a zrýchlenia rôzne znamienka, tak robot postupne
				 * spomaľuje a keď dosiahne hranicu nulovej rýchlosti, tak
				 * sa buď zastaví (ak má prikázané {@linkplain 
				 * #zastavPoSpomaleníPosunu() zastaviť po spomalení posunu}),
				 * alebo sa začne pohybovať opačným smerom.</p>
				 * 
				 * @param zrýchleniePosunu nová hodnota zrýchlenia posunu
				 */
				public void zrýchleniePosunu(double zrýchleniePosunu)
				{ zrýchleniePosunu(zrýchleniePosunu, true); }

				/** <p><a class="alias"></a> Alias pre {@link #zrýchleniePosunu(double) zrýchleniePosunu}.</p> */
				public void zrychleniePosunu(double zrýchleniePosunu)
				{ zrýchleniePosunu(zrýchleniePosunu, true); }

				/**
				 * <p>Metóda funguje rovnako ako metóda {@link 
				 * #zrýchleniePosunu(double) zrýchleniePosunu(double
				 * zrýchlenie)}, ale dovoľuje programátorovi určiť, či smie
				 * byť robot (v prípade zadania nenulového zrýchlenia posunu)
				 * {@linkplain #aktivuj() aktivovaný}.</p>
				 * 
				 * @param zrýchleniePosunu nová hodnota zrýchlenia posunu
				 * @param aktivuj ak je {@code valtrue} a zadaná hodnota
				 *     zrýchlenia posunu je nenulová, tak je robot
				 *     {@linkplain #aktivuj() aktivovaný}
				 */
				public void zrýchleniePosunu(double zrýchleniePosunu,
					boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.zrýchleniePosunu = zrýchleniePosunu;
					}
					if (aktivuj && zrýchleniePosunu != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrýchleniePosunu(double, boolean) zrýchleniePosunu}.</p> */
				public void zrychleniePosunu(double zrýchleniePosunu, boolean aktivuj)
				{ zrýchleniePosunu(zrýchleniePosunu, aktivuj); }


			// Uhlové zrýchlenie

				/**
				 * <p><a class="getter"></a> Zistí hodnotu {@linkplain 
				 * #uhlovéZrýchlenie(double) uhlového zrýchlenia} (zrýchlenia
				 * otáčania) tohto robota. Kladné hodnoty znamenajú otáčanie
				 * robota doľava. Nenulová hodnota ešte neznamená, že robot
				 * sa otáča. Pohybujú a otáčajú sa len {@linkplain #aktívny()
				 * aktívne} roboty.</p>
				 * 
				 * @return uhlové zrýchlenie tohto robota
				 */
				public double uhlovéZrýchlenie() { return uhlovéZrýchlenie; }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie() uhlovéZrýchlenie}.</p> */
				public double uhloveZrychlenie() { return uhlovéZrýchlenie; }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie() uhlovéZrýchlenie}.</p> */
				public double zrýchlenieOtáčania() { return uhlovéZrýchlenie; }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie() uhlovéZrýchlenie}.</p> */
				public double zrychlenieOtacania() { return uhlovéZrýchlenie; }

				/**
				 * <p><a class="setter"></a> Nastaví robotu novú hodnotu
				 * uhlového zrýchlenia (zrýchlenia otáčania). V prípade
				 * zadania nenulovej hodnoty, je robot automaticky
				 * {@linkplain #aktivuj() aktivovaný}, aby sa mohol začať
				 * otáčať. Ak má robot nastavenú {@linkplain 
				 * #maximálnaUhlováRýchlosť(double) maximálnu uhlovú
				 * rýchlosť}, bude zvyšovať rýchlosť otáčania až kým
				 * nedosiahne stanovenú hranicu, inak bude zrýchľovať
				 * donekonečna. Ak majú hodnoty {@linkplain 
				 * #uhlováRýchlosť(double) rýchlosti otáčania} a uhlového
				 * zrýchlenia rôzne znamienka, robot bude postupne znižovať
				 * rýchlosť otáčania, kým sa nezačne otáčať opačným smerom.</p>
				 * 
				 * @param uhlovéZrýchlenie nová hodnota uhlového zrýchlenia
				 *     (zrýchlenia otáčania)
				 */
				public void uhlovéZrýchlenie(double uhlovéZrýchlenie)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, true); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie(double) uhlovéZrýchlenie}.</p> */
				public void uhloveZrychlenie(double uhlovéZrýchlenie)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, true); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie(double) uhlovéZrýchlenie}.</p> */
				public void zrýchlenieOtáčania(double uhlovéZrýchlenie)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, true); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie(double) uhlovéZrýchlenie}.</p> */
				public void zrychlenieOtacania(double uhlovéZrýchlenie)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, true); }

				/**
				 * <p>Metóda funguje rovnako ako metóda {@link 
				 * #uhlovéZrýchlenie(double) uhlovéZrýchlenie(double
				 * uhlovéZrýchlenie)}, ale dovoľuje programátorovi určiť, či
				 * smie byť robot (v prípade zadania nenulového zrýchlenia)
				 * {@linkplain #aktivuj() aktivovaný}.</p>
				 * 
				 * @param uhlovéZrýchlenie nová hodnota uhlového zrýchlenia
				 *     (zrýchlenia otáčania)
				 * @param aktivuj ak je {@code valtrue} a zadaná hodnota
				 *     uhlového zrýchlenia je nenulová, robot je {@linkplain 
				 *     #aktivuj() aktivovaný}
				 */
				public void uhlovéZrýchlenie(double uhlovéZrýchlenie, boolean aktivuj)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						this.uhlovéZrýchlenie = uhlovéZrýchlenie;
					}
					if (aktivuj && uhlovéZrýchlenie != 0.0) aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie(double, boolean) uhlovéZrýchlenie}.</p> */
				public void uhloveZrychlenie(double uhlovéZrýchlenie, boolean aktivuj)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, aktivuj); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie(double, boolean) uhlovéZrýchlenie}.</p> */
				public void zrýchlenieOtáčania(double uhlovéZrýchlenie, boolean aktivuj)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, aktivuj); }

				/** <p><a class="alias"></a> Alias pre {@link #uhlovéZrýchlenie(double, boolean) uhlovéZrýchlenie}.</p> */
				public void zrychlenieOtacania(double uhlovéZrýchlenie, boolean aktivuj)
				{ uhlovéZrýchlenie(uhlovéZrýchlenie, aktivuj); }


			// Dynamický pohyb

				/**
				 * <p>Metóda slúži na aktiváciu robota, ktorý má nenulové
				 * {@linkplain #zrýchlenie(double) zrýchlenie}.
				 * <!-- Nie: alebo {@linkplain #zrýchleniePosunu(double)
				 * zrýchleniePosunu}-->
				 * Ak má robot nulové zrýchlenie, tak volanie tejto
				 * metódy nemá žiadny efekt. (To znamená, že {@linkplain 
				 * #zrýchlenie(double) zrýchlenie}<!-- Nie: alebo {@linkplain 
				 * #zrýchleniePosunu(double) zrýchlenie posunu}--> robota je
				 * treba nastaviť vopred.) Vo vyšších verziách programovacieho
				 * rámca bolo správanie tejto metódy upravené tak, aby sa
				 * robot vždy rozbiehal dopredu (to znamená, že ak je
				 * zrýchlenie robota v čase volania tejto metódy záporné,
				 * upraví sa automaticky na kladné), zároveň bola pridaná
				 * metóda {@link #začniCúvať() začniCúvať}… Vlastnosť
				 * rýchlosti posunu bola pridaná v ešte neskorších verziách
				 * rámca a jej aspekty nie sú touto metódou ovplyvňované (to
				 * isté platí pri volaní metódy {@link #začniCúvať()
				 * začniCúvať}).</p>
				 * 
				 * @see #začniCúvať()
				 * @see #zabrzdi()
				 * @see #rozbehniSa(double)
				 * @see #rozbehniSa(double, double)
				 * @see #rozbehniSa(double, boolean)
				 * @see #rozbehniSa(double, double, boolean)
				 */
				public void rozbehniSa()
				{
					if (zrýchlenie != 0.0)
					{
						if (zrýchlenie < 0.0)
							zrýchlenie = -zrýchlenie;
						aktivuj();
					}
				}

				/**
				 * <p>Metóda slúži na aktiváciu robota, ktorý má nenulové
				 * {@linkplain #zrýchlenie(double) zrýchlenie}.
				 * <!-- Nie: alebo {@linkplain #zrýchleniePosunu(double)
				 * zrýchleniePosunu}-->
				 * Ak má robot nulové zrýchlenie, tak volanie tejto
				 * metódy nemá žiadny efekt. (To znamená, že {@linkplain 
				 * #zrýchlenie(double) zrýchlenie}<!-- Nie: alebo {@linkplain 
				 * #zrýchleniePosunu(double) zrýchlenie posunu}--> robota je
				 * treba nastaviť vopred.) Ak je zrýchlenie robota v čase
				 * volania tejto metódy kladné, upraví sa automaticky na
				 * záporné. Táto metóda bola pridaná do vyšších verzií
				 * programovacieho rámca ako protipól metódy {@link 
				 * #rozbehniSa() rozbehniSa}. Vlastnosť rýchlosti posunu bola
				 * pridaná v ešte neskorších verziách rámca a jej aspekty nie
				 * sú touto metódou ovplyvňované.</p>
				 * 
				 * @see #rozbehniSa()
				 * @see #zabrzdi()
				 */
				public void začniCúvať()
				{
					if (zrýchlenie != 0.0)
					{
						if (zrýchlenie > 0.0)
							zrýchlenie = -zrýchlenie;
						aktivuj();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #začniCúvať() začniCúvať}.</p> */
				public void zacniCuvat() { začniCúvať(); }

				/**
				 * <p>Metóda nastaví robotu zadané {@linkplain 
				 * #zrýchlenie(double) zrýchlenie} a v prípade zadania
				 * nenulovej hodnoty automaticky aktivuje robot.</p>
				 * 
				 * @param zrýchlenie nová hodnota {@linkplain 
				 *     #zrýchlenie(double) zrýchlenia}
				 * 
				 * @see #začniCúvať()
				 * @see #zabrzdi(double)
				 * @see #rozbehniSa()
				 * @see #rozbehniSa(double, double)
				 * @see #rozbehniSa(double, boolean)
				 * @see #rozbehniSa(double, double, boolean)
				 */
				public void rozbehniSa(double zrýchlenie)
				{
					zrýchlenie(zrýchlenie);
				}

				/**
				 * <p>Metóda nastaví robotu nové hodnoty {@linkplain 
				 * #zrýchlenie(double) zrýchlenia} a {@linkplain 
				 * #maximálnaRýchlosť(double) maximálnej rýchlosti}
				 * a v prípade zadania nenulovej hodnoty zrýchlenia
				 * automaticky aktivuje robot.</p>
				 * 
				 * @param zrýchlenie nová hodnota {@linkplain 
				 *     #zrýchlenie(double) zrýchlenia}
				 * @param maximálnaRýchlosť nová hodnota {@linkplain 
				 *     #maximálnaRýchlosť(double) maximálnej rýchlosti}
				 * 
				 * @see #zabrzdi(double)
				 * @see #rozbehniSa()
				 * @see #rozbehniSa(double)
				 * @see #rozbehniSa(double, boolean)
				 * @see #rozbehniSa(double, double, boolean)
				 */
				public void rozbehniSa(double zrýchlenie,
					double maximálnaRýchlosť)
				{
					zrýchlenie(zrýchlenie);
					maximálnaRýchlosť(maximálnaRýchlosť);
				}

				/**
				 * <p>Metóda nastaví robotu zadané {@linkplain 
				 * #zrýchlenie(double) zrýchlenie} a zároveň dovoľuje
				 * programátorovi určiť, či má byť robot v prípade zadania
				 * nenulovej hodnoty zrýchlenia automaticky {@linkplain 
				 * #aktivuj() aktivovaný}.</p>
				 * 
				 * @param zrýchlenie nová hodnota {@linkplain 
				 *     #zrýchlenie(double) zrýchlenia}
				 * @param aktivuj ak je {@code valtrue}, automaticky
				 *     aktivuje robot pri zadaní nenulového zrýchlenia
				 * 
				 * @see #zabrzdi(double)
				 * @see #rozbehniSa()
				 * @see #rozbehniSa(double)
				 * @see #rozbehniSa(double, double)
				 * @see #rozbehniSa(double, double, boolean)
				 */
				public void rozbehniSa(double zrýchlenie, boolean aktivuj)
				{
					zrýchlenie(zrýchlenie, aktivuj);
				}

				/**
				 * <p>Metóda nastaví robotu nové hodnoty {@linkplain 
				 * #zrýchlenie(double) zrýchlenia} a {@linkplain 
				 * #maximálnaRýchlosť(double) maximálnej rýchlosti} a dovoľuje
				 * programátorovi určiť, či má byť robot v prípade zadania
				 * nenulovej hodnoty zrýchlenia automaticky {@linkplain 
				 * #aktivuj() aktivovaný}.</p>
				 * 
				 * @param zrýchlenie nová hodnota {@linkplain 
				 *     #zrýchlenie(double) zrýchlenia}
				 * @param maximálnaRýchlosť nová hodnota {@linkplain 
				 *     #maximálnaRýchlosť(double) maximálnej rýchlosti}
				 * @param aktivuj ak je {@code valtrue}, automaticky
				 *     aktivuje robot pri zadaní nenulového zrýchlenia
				 * 
				 * @see #zabrzdi(double)
				 * @see #rozbehniSa()
				 * @see #rozbehniSa(double)
				 * @see #rozbehniSa(double, double)
				 * @see #rozbehniSa(double, boolean)
				 */
				public void rozbehniSa(double zrýchlenie,
					double maximálnaRýchlosť, boolean aktivuj)
				{
					// if (zrýchlenie < 0.0) zrýchlenie = -zrýchlenie; — môže aj cúvať…
					zrýchlenie(zrýchlenie, aktivuj);
					maximálnaRýchlosť(maximálnaRýchlosť);
				}


				/**
				 * <p>Prikáže robotu začať brzdiť a automaticky {@linkplain 
				 * #zastav() zastaviť} pri dosiahnutí nulovej rýchlosti.
				 * <!-- Nie: alebo rýchlosti posunu -->
				 * <b>Metóda vyžaduje, aby robot mal určitú úroveň
				 * {@linkplain #zrýchlenie(double) zrýchlenia} (kladnú alebo
				 * zápornú)!</b>
				 * <!-- Nie: alebo {@linkplain #zrýchleniePosunu(double)
				 * zrýchlenia posunu}-->
				 * Keď robot nie je {@linkplain #aktívny() aktívny} alebo má
				 * {@linkplain #zrýchlenie(double) nulové zrýchlenie}, tak
				 * <!-- Nie: a súčasne nulové {@linkplain 
				 * #zrýchleniePosunu(double) nulové zrýchlenie posunu}-->
				 * nemá volanie tejto metódy žiadny efekt. V opačnom prípade
				 * je vektor zrýchlenia robota upravený správnym smerom –
				 * keď robot cúva, tak je jeho zrýchlenie nastavené na kladnú
				 * hodnotu, keď sa pohybuje smerom dopredu, tak na zápornú.
				 * Vlastnosť rýchlosti posunu bola do programovacieho rámca
				 * pridaná v neskorších verziách a jej aspekty nie sú touto
				 * metódou ovplyvňované. (Pozri {@link #zastavPosun()
				 * zastavPosun}.)</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Pozor na podobnosť názvu
				 * s metódou {@link #zastav() zastav}, ktorá má na starosti
				 * deaktiváciu robota (napríklad po dosiahnutí cieľa)…</p>
				 * 
				 * @see #rozbehniSa()
				 * @see #začniCúvať()
				 * @see #zabrzdi(double)
				 * @see #zastavPosun()
				 */
				public void zabrzdi()
				{
					if (!aktívny || zrýchlenie == 0.0) return;

					if (rýchlosť == 0.0)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							zastavPoSpomalení = false;
							// Nie: zastavPoSpomaleníPosunu = false;
						}
						zastav();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						zastavPoSpomalení = true;
						// Nie: zastavPoSpomaleníPosunu = true;

						if (rýchlosť > 0.0 && zrýchlenie > 0.0)
							zrýchlenie = -zrýchlenie;
						else if (rýchlosť < 0.0 && zrýchlenie < 0.0)
							zrýchlenie = -zrýchlenie;
					}
				}

				/**
				 * <p>Prikáže robotu začať brzdiť so zadaným „zrýchlením“
				 * (spomalením) a automaticky {@linkplain #zastav() zastaviť}
				 * pri dosiahnutí nulovej rýchlosti. Keď robot nie je
				 * {@linkplain #aktívny() aktívny} alebo <b>je zadané
				 * zrýchlenie rovné nule, tak nemá volanie metódy žiadny
				 * efekt.</b>
				 * V opačnom prípade je vektor zrýchlenia robota upravený
				 * správnym smerom – keď robot práve cúva, tak je zrýchlenie
				 * nastavené na kladnú hodnotu, v opačných prípadoch na
				 * zápornú.
				 * Vlastnosť rýchlosti posunu bola do programovacieho rámca
				 * pridaná v neskorších verziách a jej aspekty nie sú touto
				 * metódou ovplyvňované. (Pozri {@link #zastavPosun()
				 * zastavPosun}.)</p>
				 * 
				 * <p class="caution"><b>Pozor!</b> Pozor na podobnosť názvu
				 * s metódou {@link #zastav() zastav}, ktorá má na starosti
				 * deaktiváciu robota (napríklad po dosiahnutí cieľa)…</p>
				 * 
				 * @param zrýchlenie nová hodnota zrýchlenia tohto robota
				 *     (<b>nesmie byť rovné nule</b>)
				 * 
				 * @see #rozbehniSa(double)
				 * @see #rozbehniSa(double, double)
				 * @see #rozbehniSa(double, boolean)
				 * @see #rozbehniSa(double, double, boolean)
				 * @see #zabrzdi()
				 * @see #zastavPosun()
				 */
				public void zabrzdi(double zrýchlenie)
				{
					if (!aktívny || zrýchlenie == 0.0) return;

					if (rýchlosť == 0.0)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							zastavPoSpomalení = false;
							// Nie: zastavPoSpomaleníPosunu = false;
						}
						zastav();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						zastavPoSpomalení = true;
						// Nie: zastavPoSpomaleníPosunu = true;

						if (rýchlosť > 0.0 && zrýchlenie > 0.0)
							zrýchlenie = -zrýchlenie;
						else if (rýchlosť < 0.0 && zrýchlenie < 0.0)
							zrýchlenie = -zrýchlenie;

						this.zrýchlenie = zrýchlenie;
					}
				}


				/**
				 * <p>Zistí, či má robot prikázané automaticky {@linkplain 
				 * #zastav() zastaviť} pri najbližšom dosiahnutí nulovej
				 * rýchlosti.</p>
				 * 
				 * @return {@code valtrue} – áno; {@code valfalse} – nie
				 */
				public boolean zastavíPoSpomalení() { return zastavPoSpomalení; }

				/** <p><a class="alias"></a> Alias pre {@link #zastavíPoSpomalení() zastavíPoSpomalení}.</p> */
				public boolean zastaviPoSpomaleni() { return zastavPoSpomalení; }

				/**
				 * <p>Prikáže robotu, aby najbližšie, keď dosiahne nulovú
				 * rýchlosť automaticky {@linkplain #zastav() zastavil}.</p>
				 */
				public void zastavPoSpomalení()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						zastavPoSpomalení = true;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #zastavPoSpomalení() zastavPoSpomalení}.</p> */
				public void zastavPoSpomaleni() { zastavPoSpomalení(); }

				/**
				 * <p>Zruší príkaz robota, ktorý mu určoval, aby sa najbližšie,
				 * keď dosiahne nulovú rýchlosť automaticky {@linkplain 
				 * #zastav() zastavil}.</p>
				 */
				public void nezastavujPoSpomalení()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						zastavPoSpomalení = false;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #nezastavujPoSpomalení() nezastavujPoSpomalení}.</p> */
				public void nezastavujPoSpomaleni() { nezastavujPoSpomalení(); }


				/**
				 * <p>Zistí, či má robot prikázané automaticky {@linkplain 
				 * #zastavPosun() zastaviť posun} pri najbližšom dosiahnutí
				 * nulovej rýchlosti posunu.</p>
				 * 
				 * @return {@code valtrue} – áno; {@code valfalse} – nie
				 */
				public boolean zastavíPoSpomaleníPosunu()
				{ return zastavPoSpomaleníPosunu; }

				/** <p><a class="alias"></a> Alias pre {@link #zastavíPoSpomaleníPosunu() zastavíPoSpomaleníPosunu}.</p> */
				public boolean zastaviPoSpomaleniPosunu()
				{ return zastavPoSpomaleníPosunu; }

				/**
				 * <p>Prikáže robotu, aby najbližšie, keď dosiahne nulovú
				 * rýchlosť posunu automaticky {@linkplain #zastavPosun() 
				 * zastavil posun}. Táto akcia automaticky nastaví nulové
				 * {@linkplain #zrýchleniePosunu() zrýchlenie posunu}.</p>
				 */
				public void zastavPoSpomaleníPosunu()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						zastavPoSpomaleníPosunu = true;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #zastavPoSpomaleníPosunu() zastavPoSpomaleníPosunu}.</p> */
				public void zastavPoSpomaleniPosunu() { zastavPoSpomaleníPosunu(); }

				/**
				 * <p>Zruší robotu príkaz, ktorý mu určoval, aby sa
				 * najbližšie, keď dosiahne nulovú rýchlosť posunu automaticky
				 * {@linkplain #zastavPosun() posun zastavil} (s nastavením
				 * nulového {@linkplain #zrýchleniePosunu() zrýchlenia
				 * posunu}).</p>
				 */
				public void nezastavujPoSpomaleníPosunu()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						zastavPoSpomaleníPosunu = false;
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #nezastavujPoSpomaleníPosunu() nezastavujPoSpomaleníPosunu}.</p> */
				public void nezastavujPoSpomaleniPosunu() { nezastavujPoSpomaleníPosunu(); }


			// Sledovanie cieľa

				/**
				 * <p>Zistí, či je robot práve v režime smerovania do
				 * cieľa.</p>
				 * 
				 * @return {@code valtrue} – áno; {@code valfalse} – nie
				 */
				public boolean cieľAktívny() { return cieľAktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľAktívny() cieľAktívny}.</p> */
				public boolean cielAktivny() { return cieľAktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľAktívny() cieľAktívny}.</p> */
				public boolean smerujeDoCieľa() { return cieľAktívny; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľAktívny() cieľAktívny}.</p> */
				public boolean smerujeDoCiela() { return cieľAktívny; }

				/**
				 * <p>Vráti x-ovú súradnicu naposledy definovaného cieľa.</p>
				 * 
				 * @return x-ová súradnica naposledy definovaného cieľa
				 * 
				 * @see #cieľ()
				 * @see #cieľY()
				 */
				public double cieľX() { return cieľX; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľX() cieľX}.</p> */
				public double cielX() { return cieľX; }

				/**
				 * <p>Vráti y-ovú súradnicu naposledy definovaného cieľa.</p>
				 * 
				 * @return y-ová súradnica naposledy definovaného cieľa
				 * 
				 * @see #cieľ()
				 * @see #cieľX()
				 */
				public double cieľY() { return cieľY; }

				/** <p><a class="alias"></a> Alias pre {@link #cieľY() cieľY}.</p> */
				public double cielY() { return cieľY; }

				/**
				 * <p>Vráti polohu naposledy definovaného cieľa.</p>
				 * 
				 * @return poloha naposledy definovaného cieľa
				 * 
				 * @see #cieľX()
				 * @see #cieľY()
				 */
				public Bod cieľ() { return new Bod(cieľX, cieľY); }

				/** <p><a class="alias"></a> Alias pre {@link #cieľ() cieľ}.</p> */
				public Bod ciel() { return cieľ(); }

				/**
				 * <p>Zistí, či má robot prikázané automaticky {@linkplain 
				 * #zastav() zastaviť} po dosiahnutí cieľa.</p>
				 * 
				 * @return {@code valtrue} – áno; {@code valfalse} – nie
				 */
				public boolean zastavíVCieli() { return zastavVCieli; }

				/** <p><a class="alias"></a> Alias pre {@link #zastavíVCieli() zastavíVCieli}.</p> */
				public boolean zastaviVCieli() { return zastavVCieli; }

				/**
				 * <p>Vypne smerovanie do cieľa, ktoré bolo zapnuté niektorou
				 * z verzií metódy {@link #cieľ(double, double) cieľ}. Robot
				 * je automaticky deaktivovaný rovnakým spôsobom ako pri metóde
				 * {@link #zastav() zastav}. Ak je automatická deaktivácia
				 * nežiaduca, tak treba použiť verziu metódy
				 * {@link #zrušCieľ(boolean) zrušCieľ(zastav)} s argumentom
				 * {@code zastav} rovným {@code valfalse}.</p>
				 * 
				 * @see #cieľ(double, double)
				 * @see #zrušCieľ(boolean)
				 */
				public void zrušCieľ()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = false;
						zastavVCieli = false;
					}
					zastav();
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľ() zrušCieľ}.</p> */
				public void zrusCiel() { zrušCieľ(); }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľ() zrušCieľ}.</p> */
				public void zrušSledovanieCieľa() { zrušCieľ(); }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľ() zrušCieľ}.</p> */
				public void zrusSledovanieCiela() { zrušCieľ(); }

				/**
				 * <p>Vypne smerovanie do cieľa, ktoré bolo zapnuté niektorou
				 * z verzií metódy {@link #cieľ(double, double) cieľ}.
				 * Parameter {@code zastav} dovoľuje programátorovi rozhodnúť,
				 * či má alebo nemá robot zostať aktívny.</p>
				 * 
				 * @param zastav ak je {@code valtrue}, tak je robot
				 *     deaktivovaný rovnakým spôsobom ako pri volaní metódy
				 *     {@link #zastav() zastav} (bez argumentu).
				 * 
				 * @see #cieľ(double, double)
				 * @see #zrušCieľ()
				 */
				public void zrušCieľ(boolean zastav)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = false;
						zastavVCieli = false;
					}
					if (zastav) zastav();
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľ(boolean) zrušCieľ}.</p> */
				public void zrusCiel(boolean zastav) { zrušCieľ(zastav); }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľ(boolean) zrušCieľ}.</p> */
				public void zrušSledovanieCieľa(boolean zastav) { zrušCieľ(zastav); }

				/** <p><a class="alias"></a> Alias pre {@link #zrušCieľ(boolean) zrušCieľ}.</p> */
				public void zrusSledovanieCiela(boolean zastav) { zrušCieľ(zastav); }

				// Súkromná metóda na účely stanovovania a zmeny cieľa
				private boolean overDosiahnutieCieľa()
				{
					/*!!!
					if (sqrt(pow(cieľX - aktuálneX, 2) +
						pow(cieľY - aktuálneY, 2)) <= rýchlosť)
					*/
					if (hypot(cieľX - aktuálneX, cieľY - aktuálneY) <= rýchlosť)
					{
						if (maximálnaUhlováRýchlosť != 0.0)
						{
							double β = smerNa(cieľX, cieľY);
							if (abs(aktuálnyUhol - β) <= 0.05 ||
								abs(360 + aktuálnyUhol - β) <= 0.05)
							{
								poslednýUhol = aktuálnyUhol;
								aktuálnyUhol = β;
							}
							else return true;
						}

						choďNa(cieľX, cieľY);
						cieľAktívny = false;
						if (zastavVCieli)
						{
							if (zrýchlenie != 0)
							{
								if ((rýchlosť > 0.0 &&
									zrýchlenie < 0.0) ||
									rýchlosť < 0.0)
								{
									zrýchlenie = -zrýchlenie;
								}
								rýchlosť = 0.0;
							}
							zastav();
						}
						dosiahnutieCieľa();
						dosiahnutieCiela();
						return false;
					}

					return true;
				}

				/**
				 * <p>Zapne automatické smerovanie do cieľa. Počas tejto
				 * činnosti je robot automaticky otáčaný smerom na cieľové
				 * súradnice (buď s ohľadom na aktuálnu {@linkplain 
				 * #uhlováRýchlosť(double) rýchlosť otáčania}, alebo
				 * okamžite) a v prípade, že má robot nenulovú {@linkplain 
				 * #rýchlosť(double) rýchlosť} (prípadne {@linkplain 
				 * #zrýchlenie(double) zrýchlenie}), pohybuje sa stanoveným
				 * smerom. Po dosiahnutí cieľa robot automaticky {@linkplain 
				 * #zastav() zastaví}. Metóda vynúti {@linkplain #spusti()
				 * spustenie} robota.
				 * Vlastnosť <b>{@linkplain #rýchlosťPosunu() rýchlosti
				 * posunu}</b> (ktorá bola v porovnaní s vlastnosťou
				 * smerovania do cieľa pridaná do programovacieho rámca
				 * omnoho neskôr) je pri smerovaní do cieľa <b>úplne
				 * ignorovaná.</b></p>
				 * 
				 * @param x x-ová súradnica cieľa
				 * @param y y-ová súradnica cieľa
				 */
				public void cieľ(double x, double y)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = x;
						cieľY = y;
						zastavVCieli = true;
					}
					spusti();
					// overDosiahnutieCieľa(); — deje sa v spusti();
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(double, double) cieľ}.</p> */
				public void ciel(double x, double y) { cieľ(x, y); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľ(double,
				 * double) cieľ(x, y)} (pozri jej opis), ibaže umožňuje
				 * programátorovi určiť, či smie byť robot automaticky
				 * {@linkplain #spusti() spustený} (aktivovaný).</p>
				 * 
				 * @param x x-ová súradnica cieľa
				 * @param y y-ová súradnica cieľa
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} a zároveň je robotu
				 *     prikázané, aby {@linkplain #zastavíVCieli() zastavil
				 *     v cieli}
				 */
				public void cieľ(double x, double y, boolean spusti)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = x;
						cieľY = y;
						zastavVCieli = spusti;
					}
					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(double, double, boolean) cieľ}.</p> */
				public void ciel(double x, double y, boolean spusti) { cieľ(x, y, spusti); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľ(double,
				 * double) cieľ(x, y)} (pozri jej opis), ibaže umožňuje
				 * programátorovi určiť, či smie byť robot automaticky
				 * {@linkplain #spusti() spustený} (aktivovaný) a či má
				 * zastaviť po dosiahnutí cieľa.</p>
				 * 
				 * @param x x-ová súradnica cieľa
				 * @param y y-ová súradnica cieľa
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} robota
				 * @param zastavVCieli určuje, či má robot automaticky
				 *     {@linkplain #zastavíVCieli() zastaviť v cieli}
				 */
				public void cieľ(double x, double y,
					boolean spusti, boolean zastavVCieli)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = x;
						cieľY = y;
						this.zastavVCieli = zastavVCieli;
					}
					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(double, double, boolean, boolean) cieľ}.</p> */
				public void ciel(double x, double y, boolean spusti, boolean zastavVCieli)
				{ cieľ(x, y, spusti, zastavVCieli); }


				/**
				 * <p>Zapne automatické smerovanie do cieľa. Metóda vynúti
				 * {@linkplain #spusti() spustenie} robota. Za nový cieľ sú
				 * zvolené aktuálne súradnice zadaného objektu a tie ním
				 * zostávajú, dokedy nie je určené inak. Keď chceme sledovať
				 * pohybujúci sa robot, musíme cieľ pravidelne
				 * aktualizovať metódou {@link #upravCieľ(Poloha)
				 * upravCieľ}.</p>
				 * 
				 * <p>Počas činnosti smerovania na cieľ je robot automaticky
				 * otáčaný smerom na cieľové súradnice (buď s ohľadom na
				 * aktuálnu {@linkplain #uhlováRýchlosť(double) rýchlosť
				 * otáčania}, alebo okamžite) a v prípade, že má robot
				 * nenulovú {@linkplain #rýchlosť(double) rýchlosť} (prípadne
				 * {@linkplain #zrýchlenie(double) zrýchlenie}), pohybuje sa
				 * stanoveným smerom. Po dosiahnutí cieľa robot automaticky
				 * {@linkplain #zastav() zastaví}.</p>
				 * 
				 * <p>Vlastnosť <b>{@linkplain #rýchlosťPosunu() rýchlosti
				 * posunu}</b> (ktorá bola v porovnaní s vlastnosťou
				 * smerovania do cieľa pridaná do programovacieho rámca
				 * omnoho neskôr) je pri smerovaní do cieľa <b>úplne
				 * ignorovaná.</b></p>
				 * 
				 * @param objekt objekt, ktorého poloha v čase volania tejto
				 *     metódy je zvolená za nový cieľ; ak je {@code valnull},
				 *     smerovanie do cieľa je {@linkplain #zrušCieľ()
				 *     zrušené}
				 */
				public void cieľ(Poloha objekt)
				{
					if (null == objekt)
					{
						zrušCieľ();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = objekt.polohaX();
						cieľY = objekt.polohaY();
						zastavVCieli = true;
					}

					spusti();
					// overDosiahnutieCieľa(); — deje sa v spusti();
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(Poloha) cieľ}.</p> */
				public void ciel(Poloha objekt) { cieľ(objekt); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľ(Poloha)
				 * cieľ(Poloha)} (pozri jej opis), ibaže umožňuje
				 * programátorovi určiť, či smie byť tento robot automaticky
				 * {@linkplain #spusti() spustený} (aktivovaný).</p>
				 * 
				 * @param objekt objekt, ktorého poloha v čase volania tejto
				 *     metódy je zvolená za nový cieľ; ak je {@code valnull},
				 *     smerovanie do cieľa je {@linkplain #zrušCieľ()
				 *     zrušené}
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} a zároveň je robotu
				 *     prikázané, aby {@linkplain #zastavíVCieli() zastavil
				 *     v cieli}
				 */
				public void cieľ(Poloha objekt, boolean spusti)
				{
					if (null == objekt)
					{
						zrušCieľ();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = objekt.polohaX();
						cieľY = objekt.polohaY();
						zastavVCieli = spusti;
					}

					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(Poloha, boolean) cieľ}.</p> */
				public void ciel(Poloha objekt, boolean spusti) { cieľ(objekt, spusti); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľ(Poloha)
				 * cieľ(Poloha)} (pozri jej opis), ibaže umožňuje
				 * programátorovi určiť, či smie byť tento robot automaticky
				 * {@linkplain #spusti() spustený} (aktivovaný) a či má
				 * zastaviť po dosiahnutí cieľa.</p>
				 * 
				 * @param objekt objekt, ktorého poloha v čase volania tejto
				 *     metódy je zvolená za nový cieľ; ak je {@code valnull},
				 *     smerovanie do cieľa je {@linkplain #zrušCieľ()
				 *     zrušené}
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} robota
				 * @param zastavVCieli určuje, či má robot automaticky
				 *     {@linkplain #zastavíVCieli() zastaviť v cieli}
				 */
				public void cieľ(Poloha objekt, boolean spusti,
					boolean zastavVCieli)
				{
					if (null == objekt)
					{
						zrušCieľ();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = objekt.polohaX();
						cieľY = objekt.polohaY();
						this.zastavVCieli = zastavVCieli;
					}

					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(Poloha, boolean, boolean) cieľ}.</p> */
				public void ciel(Poloha objekt, boolean spusti, boolean zastavVCieli)
				{ cieľ(objekt, spusti, zastavVCieli); }

				/**
				 * <p>Zapne automatické smerovanie do cieľa, ktorý je určený
				 * stredom hraníc<sup>[1]</sup> zadaného tvaru Javy ({@link 
				 * Shape Shape}). Počas tejto činnosti je robot automaticky
				 * otáčaný smerom na cieľové súradnice (buď s ohľadom na
				 * aktuálnu {@linkplain #uhlováRýchlosť(double) rýchlosť
				 * otáčania}, alebo okamžite) a v prípade, že má robot
				 * nenulovú {@linkplain #rýchlosť(double) rýchlosť} (prípadne
				 * {@linkplain #zrýchlenie(double) zrýchlenie}), pohybuje sa
				 * stanoveným smerom. Po dosiahnutí cieľa robot automaticky
				 * {@linkplain #zastav() zastaví}. Metóda vynúti {@linkplain 
				 * #spusti() spustenie} robota.
				 * Vlastnosť <b>{@linkplain #rýchlosťPosunu() rýchlosti
				 * posunu}</b> (ktorá bola v porovnaní s vlastnosťou
				 * smerovania do cieľa pridaná do programovacieho rámca
				 * omnoho neskôr) je pri smerovaní do cieľa <b>úplne
				 * ignorovaná.</b></p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * @param tvar tvar, ktorého stred hraníc je zvolený za nový
				 *     cieľ; ak je {@code valnull}, smerovanie do cieľa je
				 *     {@linkplain #zrušCieľ() zrušené}
				 */
				public void cieľ(Shape tvar)
				{
					if (null == tvar)
					{
						zrušCieľ();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						Rectangle2D hranice = tvar.getBounds2D();
						cieľAktívny = true;
						cieľX = Svet.prepočítajSpäťX(hranice.getX()) +
							hranice.getWidth() / 2;
						cieľY = Svet.prepočítajSpäťY(hranice.getY()) -
							hranice.getHeight() / 2;
						zastavVCieli = true;
					}

					spusti();
					// overDosiahnutieCieľa(); — deje sa v spusti();
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(Shape) cieľ}.</p> */
				public void ciel(Shape tvar) { cieľ(tvar); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľ(Shape)
				 * cieľ(tvar)} (pozri jej opis), ibaže umožňuje programátorovi
				 * určiť, či smie byť robot automaticky {@linkplain #spusti()
				 * spustený} (aktivovaný).</p>
				 * 
				 * @param tvar tvar, ktorého stred hraníc je zvolený za nový
				 *     cieľ; ak je {@code valnull}, smerovanie do cieľa je
				 *     {@linkplain #zrušCieľ() zrušené}
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} a zároveň je robotu
				 *     prikázané, aby {@linkplain #zastavíVCieli() zastavil
				 *     v cieli}
				 */
				public void cieľ(Shape tvar, boolean spusti)
				{
					if (null == tvar)
					{
						zrušCieľ();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						Rectangle2D hranice = tvar.getBounds2D();
						cieľAktívny = true;
						cieľX = Svet.prepočítajSpäťX(hranice.getX()) +
							hranice.getWidth() / 2;
						cieľY = Svet.prepočítajSpäťY(hranice.getY()) -
							hranice.getHeight() / 2;
						zastavVCieli = spusti;
					}

					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(Shape, boolean) cieľ}.</p> */
				public void ciel(Shape tvar, boolean spusti) { cieľ(tvar, spusti); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľ(Shape)
				 * cieľ(tvar)} (pozri jej opis), ibaže umožňuje programátorovi
				 * určiť, či smie byť robot automaticky {@linkplain #spusti()
				 * spustený} (aktivovaný) a či má zastaviť po dosiahnutí
				 * cieľa.</p>
				 * 
				 * @param tvar tvar, ktorého stred hraníc je zvolený za nový
				 *     cieľ; ak je {@code valnull}, smerovanie do cieľa je
				 *     {@linkplain #zrušCieľ() zrušené}
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} robota
				 * @param zastavVCieli určuje, či má robot automaticky
				 *     {@linkplain #zastavíVCieli() zastaviť v cieli}
				 */
				public void cieľ(Shape tvar, boolean spusti,
					boolean zastavVCieli)
				{
					if (null == tvar)
					{
						zrušCieľ();
						return;
					}

					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						Rectangle2D hranice = tvar.getBounds2D();
						cieľAktívny = true;
						cieľX = Svet.prepočítajSpäťX(hranice.getX()) +
							hranice.getWidth() / 2;
						cieľY = Svet.prepočítajSpäťY(hranice.getY()) -
							hranice.getHeight() / 2;
						this.zastavVCieli = zastavVCieli;
					}

					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľ(Shape, boolean, boolean) cieľ}.</p> */
				public void ciel(Shape tvar, boolean spusti, boolean zastavVCieli)
				{ cieľ(tvar, spusti, zastavVCieli); }

				/**
				 * <p>Zapne automatické smerovanie do cieľa, ktorý bude určený
				 * aktuálnymi súradnicami myši. Počas tejto činnosti je robot
				 * automaticky otáčaný smerom na cieľové súradnice (buď
				 * s ohľadom na aktuálnu {@linkplain #uhlováRýchlosť(double)
				 * rýchlosť otáčania}, alebo okamžite) a v prípade, že má
				 * robot nenulovú {@linkplain #rýchlosť(double) rýchlosť}
				 * (prípadne {@linkplain #zrýchlenie(double) zrýchlenie}),
				 * pohybuje sa stanoveným smerom. Po dosiahnutí cieľa robot
				 * automaticky {@linkplain #zastav() zastaví}. Metóda vynúti
				 * {@linkplain #spusti() spustenie} robota.
				 * Vlastnosť <b>{@linkplain #rýchlosťPosunu() rýchlosti
				 * posunu}</b> (ktorá bola v porovnaní s vlastnosťou
				 * smerovania do cieľa pridaná do programovacieho rámca
				 * omnoho neskôr) je pri smerovaní do cieľa <b>úplne
				 * ignorovaná.</b></p>
				 */
				public void cieľNaMyš()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = ÚdajeUdalostí.súradnicaMyšiX;
						cieľY = ÚdajeUdalostí.súradnicaMyšiY;
						zastavVCieli = true;
					}
					spusti();
					// overDosiahnutieCieľa(); — deje sa v spusti();
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľNaMyš() cieľNaMyš}.</p> */
				public void cielNaMys() { cieľNaMyš(); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľNaMyš()
				 * cieľNaMyš()} (pozri jej opis), ibaže umožňuje programátorovi
				 * určiť, či smie byť robot automaticky {@linkplain #spusti()
				 * spustený} (aktivovaný).</p>
				 * 
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} a zároveň je robotu
				 *     prikázané, aby {@linkplain #zastavíVCieli() zastavil
				 *     v cieli}
				 */
				public void cieľNaMyš(boolean spusti)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = ÚdajeUdalostí.súradnicaMyšiX;
						cieľY = ÚdajeUdalostí.súradnicaMyšiY;
						zastavVCieli = spusti;
					}
					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľNaMyš(boolean) cieľNaMyš}.</p> */
				public void cielNaMys(boolean spusti) { cieľNaMyš(spusti); }

				/**
				 * <p>Metóda má rovnaký účel ako metóda {@link #cieľNaMyš()
				 * cieľNaMyš()} (pozri jej opis), ibaže umožňuje programátorovi
				 * určiť, či smie byť robot automaticky {@linkplain #spusti()
				 * spustený} (aktivovaný) a či má zastaviť po dosiahnutí
				 * cieľa.</p>
				 * 
				 * @param spusti ak je rovné {@code valtrue}, je vynútené
				 *     {@linkplain #spusti() spustenie} robota
				 * @param zastavVCieli určuje, či má robot automaticky
				 *     {@linkplain #zastavíVCieli() zastaviť v cieli}
				 */
				public void cieľNaMyš(boolean spusti, boolean zastavVCieli)
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						cieľAktívny = true;
						cieľX = ÚdajeUdalostí.súradnicaMyšiX;
						cieľY = ÚdajeUdalostí.súradnicaMyšiY;
						this.zastavVCieli = zastavVCieli;
					}
					if (spusti)
					{
						spusti();
						// overDosiahnutieCieľa(); — deje sa v spusti();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #cieľNaMyš(boolean, boolean) cieľNaMyš}.</p> */
				public void cielNaMys(boolean spusti, boolean zastavVCieli)
				{ cieľNaMyš(spusti, zastavVCieli); }


				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice a v prípade, že sa nové súradnice dostatočne
				 * prekrývajú s aktuálnou polohou robota ukočí smerovanie
				 * do cieľa. Ak smerovanie aktívne nie je, tak má volanie
				 * tejto metódy rovnaký efekt ako volanie metódy {@link 
				 * #cieľ(double, double) cieľ} (pozri jej opis).</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Vlastnosť
				 * <b>{@linkplain #rýchlosťPosunu() rýchlosti posunu}</b>
				 * (ktorá bola v porovnaní s vlastnosťou smerovania do cieľa
				 * pridaná do programovacieho rámca omnoho neskôr) je pri
				 * smerovaní do cieľa <b>úplne ignorovaná.</b></p>
				 * 
				 * @param x nová x-ová súradnica cieľa
				 * @param y nová y-ová súradnica cieľa
				 */
				public void upravCieľ(double x, double y)
				{
					if (cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							cieľX = x;
							cieľY = y;
						}
						overDosiahnutieCieľa();
					}
					else cieľ(x, y);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľ(double, double) upravCieľ}.</p> */
				public void upravCiel(double x, double y) { upravCieľ(x, y); }

				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice a v prípade, že sa nové súradnice dostatočne
				 * prekrývajú s aktuálnou polohou robota ukočí smerovanie
				 * do cieľa. Ak smerovanie aktívne nie je, tak má volanie
				 * tejto metódy rovnaký efekt ako volanie metódy {@link 
				 * #cieľ(double, double, boolean) cieľ}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Vlastnosť
				 * <b>{@linkplain #rýchlosťPosunu() rýchlosti posunu}</b>
				 * (ktorá bola v porovnaní s vlastnosťou smerovania do cieľa
				 * pridaná do programovacieho rámca omnoho neskôr) je pri
				 * smerovaní do cieľa <b>úplne ignorovaná.</b></p>
				 * 
				 * @param x nová x-ová súradnica cieľa
				 * @param y nová y-ová súradnica cieľa
				 * @param spusti dovoľuje programátorovi rozhodnúť, či smie
				 *     byť (v prípade, že smerovanie do cieľa nie je
				 *     aktívne) automaticky volaná metóda {@link #spusti()
				 *     spusti}
				 */
				public void upravCieľ(double x, double y, boolean spusti)
				{
					if (cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							cieľX = x;
							cieľY = y;
						}
						overDosiahnutieCieľa();
					}
					else cieľ(x, y, spusti);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľ(double, double, boolean) upravCieľ}.</p> */
				public void upravCiel(double x, double y, boolean spusti)
				{ upravCieľ(x, y, spusti); }


				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice a v prípade, že sa nové súradnice dostatočne
				 * prekrývajú s aktuálnou polohou robota ukočí smerovanie
				 * do cieľa. Ak smerovanie aktívne nie je, tak má volanie
				 * tejto metódy rovnaký efekt ako volanie metódy {@link 
				 * #cieľ(Poloha) cieľ}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Vlastnosť
				 * <b>{@linkplain #rýchlosťPosunu() rýchlosti posunu}</b>
				 * (ktorá bola v porovnaní s vlastnosťou smerovania do cieľa
				 * pridaná do programovacieho rámca omnoho neskôr) je pri
				 * smerovaní do cieľa <b>úplne ignorovaná.</b></p>
				 * 
				 * @param objekt objekt, ktorého poloha bude použitá ako
				 *     nový cieľ
				 */
				public void upravCieľ(Poloha objekt)
				{
					if (null != objekt && cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							cieľX = objekt.polohaX();
							cieľY = objekt.polohaY();
						}
						overDosiahnutieCieľa();
					}
					else cieľ(objekt);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľ(Poloha) upravCieľ}.</p> */
				public void upravCiel(Poloha objekt) { upravCieľ(objekt); }

				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice a v prípade, že sa nové súradnice dostatočne
				 * prekrývajú s aktuálnou polohou robota ukočí smerovanie
				 * do cieľa. Ak smerovanie aktívne nie je, tak má volanie
				 * tejto metódy rovnaký efekt ako volanie metódy {@link 
				 * #cieľ(Poloha, boolean) cieľ}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Vlastnosť
				 * <b>{@linkplain #rýchlosťPosunu() rýchlosti posunu}</b>
				 * (ktorá bola v porovnaní s vlastnosťou smerovania do cieľa
				 * pridaná do programovacieho rámca omnoho neskôr) je pri
				 * smerovaní do cieľa <b>úplne ignorovaná.</b></p>
				 * 
				 * @param objekt objekt, ktorého poloha bude použitá ako nový
				 *     cieľ
				 * @param spusti dovoľuje programátorovi rozhodnúť, či smie
				 *     byť (v prípade, že smerovanie do cieľa nie je
				 *     aktívne) automaticky volaná metóda {@link #spusti()
				 *     spusti}
				 */
				public void upravCieľ(Poloha objekt, boolean spusti)
				{
					if (null != objekt && cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							cieľX = objekt.polohaX();
							cieľY = objekt.polohaY();
						}
						overDosiahnutieCieľa();
					}
					else cieľ(objekt, spusti);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľ(Poloha, boolean) upravCieľ}.</p> */
				public void upravCiel(Poloha objekt, boolean spusti)
				{ upravCieľ(objekt, spusti); }

				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové súradnice
				 * smerom do stredu hraníc<sup>[1]</sup> zadaného tvaru, inak
				 * má rovnaký efekt ako volanie metódy {@link #cieľ(Shape)
				 * cieľ}.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Vlastnosť
				 * <b>{@linkplain #rýchlosťPosunu() rýchlosti posunu}</b>
				 * (ktorá bola v porovnaní s vlastnosťou smerovania do cieľa
				 * pridaná do programovacieho rámca omnoho neskôr) je pri
				 * smerovaní do cieľa <b>úplne ignorovaná.</b></p>
				 * 
				 * @param tvar tvar, ktorého súradnice stredu hraníc budú
				 *     použité ako nový cieľ
				 */
				public void upravCieľ(Shape tvar)
				{
					if (null != tvar && cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							Rectangle2D hranice = tvar.getBounds2D();
							cieľX = Svet.prepočítajSpäťX(hranice.getX()) +
								hranice.getWidth() / 2;
							cieľY = Svet.prepočítajSpäťY(hranice.getY()) -
								hranice.getHeight() / 2;
						}
						overDosiahnutieCieľa();
					}
					else cieľ(tvar);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľ(Shape) upravCieľ}.</p> */
				public void upravCiel(Shape tvar) { upravCieľ(tvar); }

				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice smerom do stredu hraníc<sup>[1]</sup> zadaného
				 * tvaru a v prípade, že sa nové súradnice dostatočne
				 * prekrývajú s aktuálnou polohou robota ukočí smerovanie
				 * do cieľa. Ak smerovanie aktívne nie je, tak má volanie
				 * tejto metódy rovnaký efekt ako volanie metódy {@link 
				 * #cieľ(Shape, boolean) cieľ}.</p>
				 * 
				 * <p><small>[1] – nejde presne o stred útvaru; je použitý
				 * najrýchlejší a najjednoduchší spôsob zistenia približného
				 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí
				 * sa jeho stred – čiže „stred hraníc.“</small></p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Vlastnosť
				 * <b>{@linkplain #rýchlosťPosunu() rýchlosti posunu}</b>
				 * (ktorá bola v porovnaní s vlastnosťou smerovania do cieľa
				 * pridaná do programovacieho rámca omnoho neskôr) je pri
				 * smerovaní do cieľa <b>úplne ignorovaná.</b></p>
				 * 
				 * @param tvar tvar, ktorého súradnice stredu hraníc budú
				 *     použité ako nový cieľ
				 * @param spusti dovoľuje programátorovi rozhodnúť, či smie
				 *     byť (v prípade, že smerovanie do cieľa nie je
				 *     aktívne) automaticky volaná metóda {@link #spusti()
				 *     spusti}
				 */
				public void upravCieľ(Shape tvar, boolean spusti)
				{
					if (null != tvar && cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							Rectangle2D hranice = tvar.getBounds2D();
							cieľX = Svet.prepočítajSpäťX(hranice.getX()) +
								hranice.getWidth() / 2;
							cieľY = Svet.prepočítajSpäťY(hranice.getY()) -
								hranice.getHeight() / 2;
						}
						overDosiahnutieCieľa();
					}
					else cieľ(tvar, spusti);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľ(Shape, boolean) upravCieľ}.</p> */
				public void upravCiel(Shape tvar, boolean spusti)
				{ upravCieľ(tvar, spusti); }

				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice podľa aktuálnych súradníc myši a v prípade,
				 * že sa nové súradnice dostatočne prekrývajú s aktuálnou
				 * polohou robota ukočí smerovanie do cieľa. Ak smerovanie
				 * aktívne nie je, tak má volanie tejto metódy rovnaký efekt
				 * ako volanie metódy {@link #cieľNaMyš() cieľNaMyš} (pozri
				 * jej opis).</p>
				 */
				public void upravCieľNaMyš()
				{
					if (cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							cieľX = ÚdajeUdalostí.súradnicaMyšiX;
							cieľY = ÚdajeUdalostí.súradnicaMyšiY;
						}
						overDosiahnutieCieľa();
					}
					else cieľNaMyš();
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľNaMyš() upravCieľNaMyš}.</p> */
				public void upravCielNaMys() { upravCieľNaMyš(); }

				/**
				 * <p>Ak je smerovanie do cieľa aktívne, upraví cieľové
				 * súradnice podľa aktuálnych súradníc myši a v prípade, že
				 * sa nové súradnice dostatočne prekrývajú s aktuálnou
				 * polohou robota ukočí smerovanie do cieľa. Ak smerovanie
				 * aktívne nie je, tak má volanie tejto metódy rovnaký
				 * efekt ako volanie metódy {@link #cieľNaMyš(boolean)
				 * cieľNaMyš} (pozri jej opis).</p>
				 * 
				 * @param spusti dovoľuje programátorovi rozhodnúť, či smie
				 *     byť (v prípade, že smerovanie do cieľa nie je
				 *     aktívne) automaticky volaná metóda {@link #spusti()
				 *     spusti}
				 */
				public void upravCieľNaMyš(boolean spusti)
				{
					if (cieľAktívny)
					{
						synchronized (ÚdajeUdalostí.zámokAktivít)
						{
							cieľX = ÚdajeUdalostí.súradnicaMyšiX;
							cieľY = ÚdajeUdalostí.súradnicaMyšiY;
						}
						overDosiahnutieCieľa();
					}
					else cieľNaMyš(spusti);
				}

				/** <p><a class="alias"></a> Alias pre {@link #upravCieľNaMyš(boolean) upravCieľNaMyš}.</p> */
				public void upravCielNaMys(boolean spusti) { upravCieľNaMyš(spusti); }


				/**
				 * <p>Zistí smer (uhol) z aktuálneho miesta robota smerom
				 * k aktuálnym súradniciam cieľa. Ak sú súradnice cieľa zhodné
				 * so súradnicami robota, tak je vrátený uhol 360°. Pred
				 * volaním tejto metódy je vhodné metódou
				 * {@link #cieľAktívny() cieľAktívny} overiť, či je cieľ
				 * skutočne aktívny. Táto činnosť nie je vykonaná automaticky,
				 * pretože v niektorých prípadoch môže byť užitočné ignorovať
				 * to, či je cieľ aktívny, alebo nie.</p>
				 * 
				 * @return hodnota uhla určujúceho smer od robota
				 *     k aktuálnym súradniciam cieľa
				 * 
				 * @see #uholNaCieľ()
				 * @see #otočNaCieľ()
				 * @see #otočNaCieľ(double)
				 */
				public double smerNaCieľ()
				{
					// if (!cieľAktívny) return 360; // NO

					double Δx = cieľX - aktuálneX;
					double Δy = cieľY - aktuálneY;

					if (Δx == 0 && Δy == 0) return 360;

					double α = toDegrees(atan2(Δy, Δx));
					if (α < 0) return 360 + α;
					return α;
				}

				/** <p><a class="alias"></a> Alias pre {@link #smerNaCieľ() smerNaCieľ}.</p> */
				public double smerNaCiel() { return smerNaCieľ(); }

				/** <p><a class="alias"></a> Alias pre {@link #smerNaCieľ() smerNaCieľ}.</p> */
				public double uholNaCieľ() { return smerNaCieľ(); }

				/** <p><a class="alias"></a> Alias pre {@link #smerNaCieľ() smerNaCieľ}.</p> */
				public double uholNaCiel() { return smerNaCieľ(); }

				/**
				 * <p>Prikáže robotu, aby na podlahe (strope) prešiel na
				 * aktuálne súradnice cieľa. Keď je pero položené, tak kreslí
				 * čiaru. Robot nezmení smer, kam bol obrátený. Pred volaním
				 * tejto metódy je vhodné metódou {@link #cieľAktívny()
				 * cieľAktívny} overiť, či je cieľ skutočne aktívny. Táto
				 * činnosť nie je vykonaná automaticky, pretože v niektorých
				 * prípadoch môže byť užitočné ignorovať to, či je cieľ
				 * aktívny, alebo nie.</p>
				 * 
				 * @see #skočNaCieľ()
				 */
				public void choďNaCieľ()
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					if (peroPoložené)
					{
						úsečka(aktuálneX, aktuálneY, cieľX, cieľY);
						aktualizujPôsobisko();
						aktuálneX = cieľX;
						aktuálneY = cieľY;
						aktualizujPôsobisko();
					}
					else
					{
						aktuálneX = cieľX;
						aktuálneY = cieľY;
					}

					if (záznamCesty)
					{
						if (peroPoložené || záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(cieľX),
								Svet.prepočítajY(cieľY));
						else
							cesta.moveTo(
								Svet.prepočítajX(cieľX),
								Svet.prepočítajY(cieľY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							choďNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný || peroPoložené)
						Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #choďNaCieľ() choďNaCieľ}.</p> */
				public void chodNaCiel() { choďNaCieľ(); }

				/**
				 * <p>Prikáže robotu, aby v rámci podlahy (stropu) preskočil
				 * na aktuálne súradnice cieľa. Robot nekreslí čiaru, ani
				 * nezmení smer, kam bol obrátený. Pred volaním
				 * tejto metódy je vhodné metódou {@link #cieľAktívny()
				 * cieľAktívny} overiť, či je cieľ skutočne aktívny. Táto
				 * činnosť nie je vykonaná automaticky, pretože v niektorých
				 * prípadoch môže byť užitočné ignorovať to, či je cieľ
				 * aktívny, alebo nie.</p>
				 * 
				 * @see #choďNaCieľ()
				 */
				public void skočNaCieľ()
				{
					// Prvý krok ohraničenia (ak je aktívne)
					if (!kreslímVlastnýTvar)
					{
						zálohujÚdajeOhraničenia();
						poslednéX = aktuálneX;
						poslednéY = aktuálneY;
					}

					aktuálneX = cieľX;
					aktuálneY = cieľY;

					if (záznamCesty)
					{
						if (záznamCestyBezPolohyPera)
							cesta.lineTo(
								Svet.prepočítajX(cieľX),
								Svet.prepočítajY(cieľY));
						else
							cesta.moveTo(
								Svet.prepočítajX(cieľX),
								Svet.prepočítajY(cieľY));
					}

					// Kontrola ohraničenia
					if (!kreslímVlastnýTvar && vyriešOhraničenie())
					{
						registrujPretočOhraničenie(() ->
							skočNa(novýCieľX, novýCieľY));
						while (doriešOhraničenie());
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #skočNaCieľ() skočNaCieľ}.</p> */
				public void skocNaCiel() { skočNaCieľ(); }

				/**
				 * <p>Nasmeruje robot smerom na aktuálne súradnice cieľa.
				 * Ak sú súradnice cieľa zhodné so súradnicami robota, tak sa
				 * smer robota sa nezmení. Inak je vypočítaný uhol smeru medzi
				 * aktuálnou polohou robota a polohou cieľa, ktorý je použitý
				 * na nasmerovanie robota. Pred volaním
				 * tejto metódy je vhodné metódou {@link #cieľAktívny()
				 * cieľAktívny} overiť, či je cieľ skutočne aktívny. Táto
				 * činnosť nie je vykonaná automaticky, pretože v niektorých
				 * prípadoch môže byť užitočné ignorovať to, či je cieľ
				 * aktívny, alebo nie.</p>
				 * 
				 * @see #smerNaCieľ()
				 */
				public void otočNaCieľ()
				{
					double Δx = cieľX - aktuálneX;
					double Δy = cieľY - aktuálneY;

					if (Δx == 0 && Δy == 0) return;
					else
					{
						poslednýUhol = aktuálnyUhol;
						aktuálnyUhol = toDegrees(atan2(Δy, Δx));
						if (aktuálnyUhol < 0) aktuálnyUhol += 360;
					}

					if (viditeľný) Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNaCieľ() otočNaCieľ}.</p> */
				public void otocNaCiel() { otočNaCieľ(); }

				/**
				 * <p>Funguje podobne ako metóda {@link #otočNaCieľ()
				 * otočNaCieľ}, ibaže obmedzuje uhol pootočenia – neotočí
				 * robot okamžite smerom k súradniciam cieľa, iba ho pootočí
				 * stanoveným smerom o maximálnu zadanú hodnotu uhla. Pred
				 * volaním tejto metódy je vhodné metódou {@link #cieľAktívny()
				 * cieľAktívny} overiť, či je cieľ skutočne aktívny. Táto
				 * činnosť nie je vykonaná automaticky, pretože v niektorých
				 * prípadoch môže byť užitočné ignorovať to, či je cieľ
				 * aktívny, alebo nie.</p>
				 * 
				 * @param najviacO maximálna hodnota uhla, o ktorú sa môže
				 *     robot pootočiť smerom k aktuálnym súradniciam cieľa
				 * 
				 * @see #smerNaCieľ()
				 */
				public void otočNaCieľ(double najviacO)
				{
					double α = smerNaCieľ();
					if (α == 360) return;
					if (najviacO < 0) najviacO = -najviacO;

					α -= aktuálnyUhol;
					if (α > 180) α -= 360;
					if (α < -180) α += 360;
					if (α > 0 && α > najviacO) α = najviacO;
					if (α < 0 && α < -najviacO) α = -najviacO;

					vľavo(α);
				}

				/** <p><a class="alias"></a> Alias pre {@link #otočNaCieľ(double) otočNaCieľ}.</p> */
				public void otocNaCiel(double najviacO)
				{ otočNaCieľ(najviacO); }


			// Sledovanie dráhy po ceste

				/**
				 * <p>Vytvorí z aktuálnej {@linkplain #cesta() cesty} dráhu so
				 * zrnitosťou rovnou hodnote aktuálnej {@linkplain 
				 * #rýchlosť() rýchlosti} robota. Metóda vypočíta body dráhy
				 * tak, aby vzdialenosť medzi nimi bola čo najbližšie
				 * k hodnote rýchlosti (podľa ktorej bola určená zrnitosť
				 * dráhy).</p>
				 * 
				 * @see #cesta()
				 * @see #rýchlosť()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Bod> vytvorDráhu()
				{ return vytvorDráhu(cesta, rýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #vytvorDráhu() vytvorDráhu}.</p> */
				public Zoznam<Bod> vytvorDrahu()
				{ return vytvorDráhu(cesta, rýchlosť); }

				/**
				 * <p>Vytvorí z aktuálnej {@linkplain #cesta() cesty} dráhu so
				 * zadanou zrnitosťou. Metóda vypočíta body dráhy tak, aby
				 * vzdialenosť medzi nimi bola čo najbližšie k zadanej
				 * zrnitosti.</p>
				 * 
				 * @param zrnitosť určuje približnú vzdialenosť medzi
				 *     bodmi dráhy
				 * 
				 * @see #cesta()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Bod> vytvorDráhu(double zrnitosť)
				{ return vytvorDráhu(cesta, zrnitosť); }

				/** <p><a class="alias"></a> Alias pre {@link #vytvorDráhu(double) vytvorDráhu}.</p> */
				public Zoznam<Bod> vytvorDrahu(double zrnitosť)
				{ return vytvorDráhu(cesta, zrnitosť); }

				/**
				 * <p>Vytvorí zo zadaného tvaru dráhu so zrnitosťou rovnou
				 * hodnote aktuálnej {@linkplain #rýchlosť() rýchlosti}
				 * robota. Metóda vypočíta body dráhy tak, aby vzdialenosť
				 * medzi nimi bola čo najbližšie k hodnote rýchlosti (podľa
				 * ktorej bola určená zrnitosť dráhy).</p>
				 * 
				 * @see #rýchlosť()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Bod> vytvorDráhu(Shape tvar)
				{ return vytvorDráhu(tvar, rýchlosť); }

				/** <p><a class="alias"></a> Alias pre {@link #vytvorDráhu(Shape) vytvorDráhu}.</p> */
				public Zoznam<Bod> vytvorDrahu(Shape tvar)
				{ return vytvorDráhu(tvar, rýchlosť); }


				// Pomocné pole pri vytváraní dráhy
				private final double[] čítačIterátora = new double[6];

				/**
				 * <p>Vytvorí zo zadaného tvaru dráhu so zadanou zrnitosťou.
				 * Dráha by mala byť otvorená cesta, inak nie je isté to, kde
				 * presne robot začne (a kde skončí). Avšak ak na tom nezáleží
				 * (ak je dôležité len to, aby sa robot pohyboval po
				 * stanovenej dráhe), tak nie je nevyhnutné túto podmienku
				 * dodržať. Metóda vypočíta body dráhy tak, aby vzdialenosť
				 * medzi nimi bola čo najbližšie k zadanej zrnitosti.</p>
				 * 
				 * @param tvar určuje tvar dráhy
				 * @param zrnitosť určuje približnú vzdialenosť medzi bodmi dráhy
				 * @return zoznam bodov tvoriacich aktuálnu (novú) dráhu robota
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Bod> vytvorDráhu(Shape tvar, double zrnitosť)
				{
					// Táto metóda funguje takto:
					//   1. Vytvorí iterátor cesty.
					//   2. Interpoluje medzi bodmi, ktoré sú ďalej než
					//      stanovená zrnitosť a to tak, aby boli body vo
					//      vzdialenosti približne rovnej zrnitosti.
					//   3. Body, ktoré sú k poslednému pridanému bodu
					//      bližšie než je jedna šestnástina zrnitosti
					//      sú ignorované.

					PathIterator iterátor = new FlatteningPathIterator(
						tvar.getPathIterator(null), zrnitosť / 4.0);
					dráha.removeAllElements();
					kľúčovéFázy.clear();


					if (!iterátor.isDone())
					{
						iterátor.currentSegment(čítačIterátora);
						double x0 = Svet.prepočítajSpäťX(čítačIterátora[0]);
						double y0 = Svet.prepočítajSpäťY(čítačIterátora[1]);

						dráha.add(new Bod(x0, y0));
						// System.out.println("\nNová dráha: " + x0 + ", " + y0);
						while (!iterátor.isDone())
						{
							iterátor.currentSegment(čítačIterátora);
							double x1 = Svet.prepočítajSpäťX(čítačIterátora[0]);
							double y1 = Svet.prepočítajSpäťY(čítačIterátora[1]);

							double vzdialenosť = hypot(x0 - x1, y0 - y1);
							if (vzdialenosť > zrnitosť)
							{
								// System.out.println("(" + x1 + ", " + y1 + " – " + vzdialenosť + ")");
								double x2 = x0, y2 = y0;

								double Δt = zrnitosť / vzdialenosť;
								for (double t = Δt; t <= 1.0; t += Δt)
								{
									double x3 = Svet.lineárnaInterpolácia(
										x0, x1, t);
									double y3 = Svet.lineárnaInterpolácia(
										y0, y1, t);

									vzdialenosť = hypot(x2 - x3, y2 - y3);
									if (vzdialenosť >= zrnitosť / 16.0)
									{
										// System.out.println("  " + x3 + ", " + y3 + " – " + vzdialenosť);

										dráha.add(new Bod(x3, y3));
										x2 = x3; y2 = y3;
									}
									// else
									// {
									// 	// System.out.println("  /" + x3 + ", " + y3 + " – " + vzdialenosť + "/");
									// }
								}

								vzdialenosť = hypot(x2 - x1, y2 - y1);
								if (vzdialenosť >= zrnitosť / 16.0)
								{
									// System.out.println("  + " + x1 + ", " + y1 + " – " + vzdialenosť);

									dráha.add(new Bod(x1, y1));
									x0 = x1; y0 = y1;
								}
								else
								{
									// System.out.println("  //" + x1 + ", " + y1 + " – " + vzdialenosť + "//");

									x0 = x2; y0 = y2;
								}
							}
							else if (vzdialenosť >= zrnitosť / 16.0)
							{
								// System.out.println(x1 + ", " + y1 + " – " + vzdialenosť);

								dráha.add(new Bod(x1, y1));
								x0 = x1; y0 = y1;
							}
							// else
							// {
							// 	// System.out.println("/" + x1 + ", " + y1 + " – " + vzdialenosť + "/");
							// }

							iterátor.next();
						}
					}

					return new Zoznam<Bod>(dráha);
				}

				/** <p><a class="alias"></a> Alias pre {@link #vytvorDráhu(Shape, double) vytvorDráhu}.</p> */
				public Zoznam<Bod> vytvorDrahu(Shape tvar, double zrnitosť)
				{ return vytvorDráhu(tvar, zrnitosť); }


				/**
				 * <p><a class="getter"></a> Vráti zoznam bodov tvoriaci
				 * aktuálnu dráhu.</p>
				 * 
				 * @return zoznam bodov tvoriacich aktuálnu dráhu
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Bod> dráha() { return new Zoznam<Bod>(dráha); }

				/** <p><a class="alias"></a> Alias pre {@link #dráha() dráha}.</p> */
				public Zoznam<Bod> draha() { return new Zoznam<Bod>(dráha); }

				/**
				 * <p><a class="setter"></a> Nastaví aktuálnu dráhu podľa zadaného
				 * zoznamu. Hodnota {@code valnull} znamená vymazanie aktuálnej
				 * dráhy. Táto akcia má za následok vymazanie všetkých
				 * {@linkplain #označKľúčovúFázuDráhy(int) kľúčových fáz dráhy}.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void dráha(Vector<Bod> nováDráha)
				{
					kľúčovéFázy.clear();
					if (null == nováDráha)
					{
						dráha.removeAllElements();
					}
					else if (dráha != nováDráha)
					{
						dráha.removeAllElements();
						dráha.addAll(nováDráha);
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #dráha(Vector) dráha}.</p> */
				public void draha(Vector<Bod> nováDráha) { dráha(nováDráha); }


				/**
				 * <p>Prevráti poradie bodov dráhy.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void obráťDráhu()
				{
					Collections.reverse(dráha);

					if (0 != kľúčovéFázy.size())
					{
						int dĺžka = dráha.size() - 1;
						TreeSet<Integer> novéKľúčovéFázy = new TreeSet<>();

						for (Integer i : kľúčovéFázy)
							novéKľúčovéFázy.add(dĺžka - i);

						kľúčovéFázy.clear();
						kľúčovéFázy.addAll(novéKľúčovéFázy);
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #obráťDráhu() obráťDráhu}.</p> */
				public void obratDrahu() { obráťDráhu(); }

				/**
				 * <p>Posunie body dráhy o zadaný rozdiel súradníc Δx a Δy.</p>
				 * 
				 * <p>Táto metóda má dve verzie, ktoré však fungujú úplne
				 * odlišne. Toto je verzia, ktorá prijíma dva argumenty
				 * a posúva súradnice jednotlivých bodov dráhy.
				 * {@linkplain #posuňDráhu(int) Ďalšia verzia} prijíma jeden
				 * argument a tá posúva prvky dráhy, čo má zmysel najmä pri
				 * uzavretých dráhach, ktorým chceme posunúť začiatočný
				 * a koncový bod robota.</p>
				 * 
				 * @param Δx posunutie bodov v smere osi x
				 * @param Δy posunutie bodov v smere osi y
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void posuňDráhu(double Δx, double Δy)
				{
					for (Bod bod : dráha)
						if (null != bod) bod.setLocation(
							bod.getX() + Δx, bod.getY() + Δy);
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuňDráhu(double, double) posuňDráhu}.</p> */
				public void posunDrahu(double Δx, double Δy) { posuňDráhu(Δx, Δy); }

				/**
				 * <p>Posunie prvky v zozname bodov dráhy o zadaný počet doprava
				 * (pri zadaní kladného počtu prvkov) alebo doľava (pri zadaní
				 * záporného počtu prvkov). Prvky, ktoré sú pri posúvaní sa
				 * doprava na konci zoznamu sa ocitnú na jeho začiatku
				 * a naopak. Tým je ovplyvnené posunutie začiatočného
				 * a koncového bodu dráhy robota.</p>
				 * 
				 * <p>Táto metóda má dve verzie, ktoré však fungujú úplne
				 * odlišne. Toto je verzia, ktorá prijíma jeden argument
				 * a posúva prvky v zozname bodov dráhy, čo má zmysel najmä
				 * pri uzavretých dráhach, ktorým chceme posunúť začiatočný
				 * a koncový bod robota.
				 * {@linkplain #posuňDráhu(double, double) Ďalšia verzia}
				 * prijíma dva argumenty a tá posúva súradnice jednotlivých
				 * bodov dráhy.</p>
				 * 
				 * @param početPrvkov počet prvkov, o ktorý má byť dráha
				 *     posunutá
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void posuňDráhu(int početPrvkov)
				{
					Collections.rotate(dráha, početPrvkov);

					if (0 != kľúčovéFázy.size())
					{
						int dĺžka = dráha.size();
						TreeSet<Integer> novéKľúčovéFázy = new TreeSet<>();

						for (Integer i : kľúčovéFázy)
						{
							int novýPrvok = (i + početPrvkov) % dĺžka;
							if (novýPrvok < 0) novýPrvok += dĺžka;
							novéKľúčovéFázy.add(novýPrvok);
						}

						kľúčovéFázy.clear();
						kľúčovéFázy.addAll(novéKľúčovéFázy);
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #posuňDráhu(int) posuňDráhu}.</p> */
				public void posunDrahu(int početPrvkov) { posuňDráhu(početPrvkov); }


				/**
				 * <p>Vytvorí z aktuálnej {@linkplain #cesta() cesty} dráhu so
				 * zrnitosťou rovnou hodnote aktuálnej {@linkplain 
				 * #rýchlosť() rýchlosti} robota a z nej vytvorí mapu smerov, ktoré
				 * budú použité pri pohybe robota po jeho aktuálne dráhe. Tvar
				 * cesty slúžiaci na vytvorenie mapy smerov nemusí byť totožný
				 * s tvarom cesty, ktorý slúžil na vytvorenie dráhy.</p>
				 * 
				 * @see #cesta()
				 * @see #rýchlosť()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Double> vytvorMapuSmerov()
				{ return vytvorMapuSmerov(cesta, rýchlosť); }

				/**
				 * <p>Vytvorí z aktuálnej {@linkplain #cesta() cesty} dráhu so
				 * zadanou zrnitosťou a z nej vytvorí mapu smerov, ktoré budú
				 * použité pri pohybe robota po jeho aktuálne dráhe. Tvar cesty
				 * slúžiaci na vytvorenie mapy smerov nemusí byť totožný s tvarom
				 * cesty, ktorý slúžil na vytvorenie dráhy.</p>
				 * 
				 * @param zrnitosť určuje približnú vzdialenosť medzi
				 *     bodmi dráhy
				 * 
				 * @see #cesta()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Double> vytvorMapuSmerov(double zrnitosť)
				{ return vytvorMapuSmerov(cesta, zrnitosť); }

				/**
				 * <p>Vytvorí zo zadaného tvaru dráhu so zrnitosťou rovnou hodnote
				 * aktuálnej {@linkplain #rýchlosť() rýchlosti} robota a z nej
				 * vytvorí mapu smerov, ktoré budú použité pri pohybe robota po
				 * jeho aktuálne dráhe. Tvar slúžiaci na vytvorenie mapy smerov
				 * nemusí byť totožný s tvarom, ktorý slúžil na vytvorenie dráhy.</p>
				 * 
				 * @see #rýchlosť()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Double> vytvorMapuSmerov(Shape tvar)
				{ return vytvorMapuSmerov(tvar, rýchlosť); }


				/**
				 * <p>Vytvorí zo zadaného tvaru dráhu so zadanou zrnitosťou a z nej
				 * vytvorí mapu smerov, ktoré budú použité pri pohybe robota po
				 * jeho aktuálne dráhe. Tvar slúžiaci na vytvorenie mapy smerov
				 * nemusí byť totožný s tvarom, ktorý slúžil na vytvorenie dráhy.</p>
				 * 
				 * @param tvar určuje tvar, podľa ktorého bude vytvorená mapa smerov
				 * @param zrnitosť určuje približnú vzdialenosť medzi bodmi dráhy
				 * @return zoznam hodnôt tvoriacich mapu smerov
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Double> vytvorMapuSmerov(
					Shape tvar, double zrnitosť)
				{
					// Táto metóda funguje rovnako ako metóda
					// vytvorDráhu(Shape tvar, double zrnitosť),
					// ale namiesto polôh si pamätá smery.

					PathIterator iterátor = new FlatteningPathIterator(
						tvar.getPathIterator(null), zrnitosť / 4.0);

					mapaSmerov.removeAllElements();
					// dráha.removeAllElements();
					// kľúčovéFázy.clear();
					double smer = 0.0;

					if (!iterátor.isDone())
					{
						iterátor.currentSegment(čítačIterátora);
						double x0 = Svet.prepočítajSpäťX(čítačIterátora[0]);
						double y0 = Svet.prepočítajSpäťY(čítačIterátora[1]);

						mapaSmerov.add(null);

						// dráha.add(new Bod(x0, y0));
						// System.out.println("\nNová dráha: " + x0 + ", " + y0);
						while (!iterátor.isDone())
						{
							iterátor.currentSegment(čítačIterátora);
							double x1 = Svet.prepočítajSpäťX(čítačIterátora[0]);
							double y1 = Svet.prepočítajSpäťY(čítačIterátora[1]);

							double vzdialenosť = hypot(x0 - x1, y0 - y1);
							if (vzdialenosť > zrnitosť)
							{
								// System.out.println("(" + x1 + ", " + y1 + " – " + vzdialenosť + ")");
								double x2 = x0, y2 = y0;

								double Δt = zrnitosť / vzdialenosť;
								for (double t = Δt; t <= 1.0; t += Δt)
								{
									double x3 = Svet.lineárnaInterpolácia(
										x0, x1, t);
									double y3 = Svet.lineárnaInterpolácia(
										y0, y1, t);

									vzdialenosť = hypot(x2 - x3, y2 - y3);
									if (vzdialenosť >= zrnitosť / 16.0)
									{
										// System.out.println("  " + x3 + ", " + y3 + " – " + vzdialenosť);

										smer = smer(x3 - x2, y3 - y2);
										if (360.0 == smer)
											mapaSmerov.add(null);
										else
											mapaSmerov.add(smer);

										// dráha.add(new Bod(x3, y3));
										x2 = x3; y2 = y3;
									}
									// else
									// {
									// 	// System.out.println("  /" + x3 + ", " + y3 + " – " + vzdialenosť + "/");
									// }
								}

								vzdialenosť = hypot(x2 - x1, y2 - y1);
								if (vzdialenosť >= zrnitosť / 16.0)
								{
									// System.out.println("  + " + x1 + ", " + y1 + " – " + vzdialenosť);

									smer = smer(x1 - x2, y1 - y2);
									if (360.0 == smer)
										mapaSmerov.add(null);
									else
										mapaSmerov.add(smer);

									// dráha.add(new Bod(x1, y1));
									x0 = x1; y0 = y1;
								}
								else
								{
									// System.out.println("  //" + x1 + ", " + y1 + " – " + vzdialenosť + "//");

									x0 = x2; y0 = y2;
								}
							}
							else if (vzdialenosť >= zrnitosť / 16.0)
							{
								// System.out.println(x1 + ", " + y1 + " – " + vzdialenosť);

								smer = smer(x1 - x0, y1 - y0);
								if (360.0 == smer)
									mapaSmerov.add(null);
								else
									mapaSmerov.add(smer);

								// dráha.add(new Bod(x1, y1));
								x0 = x1; y0 = y1;
							}
							// else
							// {
							// 	// System.out.println("/" + x1 + ", " + y1 + " – " + vzdialenosť + "/");
							// }

							iterátor.next();
						}
					}

					// dráha
					return new Zoznam<Double>(mapaSmerov);
				}


				/**
				 * <p><a class="getter"></a> Vráti zoznam hodnôt tvoriaci aktuálnu mapu
				 * smerov.</p>
				 * 
				 * @return zoznam hodnôt tvoriacich mapu smerov
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public Zoznam<Double> mapaSmerov() { return new Zoznam<Double>(mapaSmerov); }

				/**
				 * <p><a class="setter"></a> Nastaví aktuálnu mapu smerov podľa zadaného
				 * zoznamu. Hodnota {@code valnull} znamená vymazanie aktuálnej mapy
				 * smerov.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void mapaSmerov(Vector<Double> nováMapaSmerov)
				{
					if (null == nováMapaSmerov)
					{
						mapaSmerov.removeAllElements();
					}
					else if (mapaSmerov != nováMapaSmerov)
					{
						mapaSmerov.removeAllElements();
						mapaSmerov.addAll(nováMapaSmerov);
					}
				}


				/**
				 * <p>Prevráti poradie prvkov mapy smerov.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void obráťMapuSmerov()
				{ Collections.reverse(mapaSmerov); }

				/** <p><a class="alias"></a> Alias pre {@link #obráťDráhu() obráťDráhu}.</p> */
				public void obratMapuSmerov()
				{ Collections.reverse(mapaSmerov); }

				/**
				 * <p>Pootočí hodnoty v mape smerov o zadaný uhol.</p>
				 * 
				 * @param uhol uhol pootočenia hodnôt mapy smerov
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void pootočMapuSmerov(double uhol)
				{
					for (int i = 0; i < mapaSmerov.size(); ++i)
					{
						Double smer = mapaSmerov.get(i);
						if (null != smer)
						{
							double smer2 = (smer + uhol) % 360;
							if (smer2 < 0) smer2 += 360;
							mapaSmerov.set(i, smer2);
						}
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #pootočMapuSmerov(double) pootočMapuSmerov}.</p> */
				public void pootocMapuSmerov(double uhol) { pootočMapuSmerov(uhol); }

				/**
				 * <p>Posunie prvky mapy smerov o zadanú hodnotu doprava.
				 * (pri zadaní kladnej hodnoty) alebo doľava (pri zadaní
				 * zápornej hodnoty). Prvky, ktoré sú pri posúvaní sa
				 * doprava na konci zoznamu sa ocitnú na jeho začiatku
				 * a naopak.</p>
				 * 
				 * @param početPrvkov počet prvkov, o ktorý má byť mapa
				 *     smerov posunutá
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void posuňMapuSmerov(int početPrvkov)
				{ Collections.rotate(mapaSmerov, početPrvkov); }

				/** <p><a class="alias"></a> Alias pre {@link #posuňMapuSmerov(int) posuňMapuSmerov}.</p> */
				public void posunMapuSmerov(int početPrvkov)
				{ Collections.rotate(mapaSmerov, početPrvkov); }


				/**
				 * <p>Aktivuje robot a zaháji jeho pohyb po aktuálnej dráhe.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * <table><tr><td>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} TestKráčajPoDráhe {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} TestKráčajPoDráhe()
						{
							{@code valsuper}({@code num400}, {@code num400});
							{@link #zdvihniPero() zdvihniPero}();
							{@link #uhol(double) uhol}({@code num80});
							{@link #skočNa(double, double) skočNa}(&#45;{@code num170}, &#45;{@code num80});

							{@link #začniCestu() začniCestu}();
							{@link #choďPoOblúku(double, double) choďPoOblúku}({@code num90}, {@code num100});
							{@link #dopredu(double) dopredu}({@code num120});
							{@link #choďPoOblúku(double, double) choďPoOblúku}({@code num90}, &#45;{@code num100});

							{@link #vytvorDráhu(double) vytvorDráhu}({@code num8});
							{@link #domov() domov}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link #klik() klik}()
						{
							{@code currkráčajPoDráhe}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link #kráčaniePoDráhe() kráčaniePoDráhe}()
						{
							{@link #náhodnáFarba() náhodnáFarba}();
							{@link #kružnica(double) kružnica}({@link Svet Svet}.{@link Svet#náhodnéReálneČíslo(double, double) náhodnéReálneČíslo}({@code num1.5}, {@code num4}));
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@code kwdnew} TestKráčajPoDráhe();
						}
					}
					</pre>
				 * </td><td>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>kracaniePoDrahe.png<alt/>Výsledok kráčania
				 * robota po definovanej dráhe.</image>Po kliknutí myšou
				 * začne robot kráčať po vopred vytvorenej dráhe a zanechá
				 * pri tom náhodnú farebnú stopu.</p></td></tr></table>
				 * 
				 * @see #aktivuj()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void kráčajPoDráhe()
				{
					fázaDráhy = 0;
					aktivuj();
				}

				/** <p><a class="alias"></a> Alias pre {@link #kráčajPoDráhe() kráčajPoDráhe}.</p> */
				public void kracajPoDrahe() { kráčajPoDráhe(); }

				/**
				 * <p>Deaktivuje robot a ukončí jeho pohyb po dráhe.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void zastavNaDráhe()
				{
					if (fázaDráhy >= 0)
					{
						fázaDráhy = -1;
						deaktivuj();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #zastavNaDráhe() zastavNaDráhe}.</p> */
				public void zastavNaDrahe() { zastavNaDráhe(); }

				/**
				 * <p>Obnoví pohyb robota po aktuálnej dráhe. Ak sa robot práve
				 * nenachádza na dráhe, tak metóda nájde najbližší bod
				 * na dráhe a presunie ho tam.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void pokračujVDráhe()
				{
					if (fázaDráhy < 0 && dráha.size() > 0)
					{
						int najbližší = 0;
						Bod bod = dráha.get(0);
						double najmenšiaVzdialenosť = hypot(
							aktuálneX - bod.x, aktuálneY - bod.y);
						for (int i = 1; i < dráha.size(); ++i)
						{
							bod = dráha.get(i);
							double vzdialenosť = hypot(
								aktuálneX - bod.x, aktuálneY - bod.y);
							if (vzdialenosť < najmenšiaVzdialenosť)
							{
								najbližší = i;
								najmenšiaVzdialenosť = vzdialenosť;
							}
						}
						fázaDráhy = najbližší;
						aktivuj();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #pokračujVDráhe() pokračujVDráhe}.</p> */
				public void pokracujVDrahe() { pokračujVDráhe(); }


				/**
				 * <p>Označí zadanú fázu dráhy za kľúčovú. V kľúčových fázach je
				 * spúšťaná metóda {@link #vstupDoKľúčovejFázyDráhy(int)}
				 * namiesto metódy {@link #kráčaniePoDráhe()}.</p>
				 * 
				 * @param fáza index fázy, ktorá má byť označená za kľúčovú
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void označKľúčovúFázuDráhy(int fáza)
				{ kľúčovéFázy.add(fáza); }

				/** <p><a class="alias"></a> Alias pre {@link #označKľúčovúFázuDráhy(int) označKľúčovúFázuDráhy}.</p> */
				public void oznacKlucovuFazuDrahy(int fáza)
				{ označKľúčovúFázuDráhy(fáza); }


				/**
				 * <p>Zruší označenie zadanej fázy dráhy za kľúčové.</p>
				 * 
				 * @param fáza index kľúčovej fázy, ktorá má byť zrušená
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void zrušKľúčovúFázuDráhy(int fáza)
				{ kľúčovéFázy.remove(fáza); }

				/** <p><a class="alias"></a> Alias pre {@link #zrušKľúčovúFázuDráhy(int) zrušKľúčovúFázuDráhy}.</p> */
				public void zrusKlucovuFazuDrahy(int fáza)
				{ zrušKľúčovúFázuDráhy(fáza); }


				/**
				 * <p>Označí takú fázu dráhy za kľúčovú, ktorej poloha je
				 * najbližšie k zadanej polohe. Pri vyhľadávaní vhodnej fázy
				 * na označenie sú brané do úvahy len tie fázy, ktoré nie sú
				 * označené a označená je potom taká fáza, ktorá ešte nebola
				 * označená a leží najbližšie k zadanej polohe. To znamená,
				 * že pri dostatočnom počte opakovaní pokusov o označenie by
				 * nakoniec boli označené všetky fázy dráhy.
				 * V kľúčových fázach je
				 * spúšťaná metóda {@link #vstupDoKľúčovejFázyDráhy(int)}
				 * namiesto metódy {@link #kráčaniePoDráhe()}.</p>
				 * 
				 * @param fáza približná poloha fázy, ktorá má byť označená
				 *     za kľúčovú
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void označKľúčovúFázuDráhy(Poloha poloha)
				{
					int najbližší;
					for (najbližší = 0; najbližší < dráha.size() &&
						!kľúčovéFázy.contains(najbližší); ++najbližší);
					if (najbližší >= dráha.size()) return;

					Bod bod = dráha.get(najbližší);
					double najmenšiaVzdialenosť = hypot(
						aktuálneX - bod.x, aktuálneY - bod.y);

					for (int i = najbližší + 1; i < dráha.size(); ++i)
					{
						if (kľúčovéFázy.contains(i)) continue;

						bod = dráha.get(i);
						double vzdialenosť = hypot(
							aktuálneX - bod.x, aktuálneY - bod.y);
						if (vzdialenosť < najmenšiaVzdialenosť)
						{
							najbližší = i;
							najmenšiaVzdialenosť = vzdialenosť;
						}
					}

					kľúčovéFázy.add(najbližší);
				}

				/** <p><a class="alias"></a> Alias pre {@link #označKľúčovúFázuDráhy(Poloha) označKľúčovúFázuDráhy}.</p> */
				public void oznacKlucovuFazuDrahy(Poloha poloha)
				{ označKľúčovúFázuDráhy(poloha); }


				/**
				 * <p>Zruší označenie takej fázy dráhy za kľúčové, ktorej poloha
				 * je najbližšie k zadanej polohe, pričom sú počas hľadania
				 * vhodnej fázy na zrušenie brané do úvahy len už označené
				 * fázy. To znamená, že ak jestvuje aspoň jedna kľúčová fáza
				 * v dráhe, tak s istotou nastane jedno zrušenie – tej
				 * označenej fázy, ktorá bude najbližšie k zadanej polohe.</p>
				 * 
				 * @param fáza približná poloha kľúčovej fázy, ktorá má byť
				 *     zrušená
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void zrušKľúčovúFázuDráhy(Poloha poloha)
				{
					if (0 == kľúčovéFázy.size()) return;

					int najbližší = kľúčovéFázy.first();

					Bod bod = dráha.get(najbližší);
					double najmenšiaVzdialenosť = hypot(
						aktuálneX - bod.x, aktuálneY - bod.y);

					Integer i = kľúčovéFázy.higher(najbližší);
					while (null != i)
					{
						bod = dráha.get(i);
						double vzdialenosť = hypot(
							aktuálneX - bod.x, aktuálneY - bod.y);

						if (vzdialenosť < najmenšiaVzdialenosť)
						{
							najbližší = i;
							najmenšiaVzdialenosť = vzdialenosť;
						}

						i = kľúčovéFázy.higher(i);
					}

					kľúčovéFázy.remove(najbližší);
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrušKľúčovúFázuDráhy(Poloha) zrušKľúčovúFázuDráhy}.</p> */
				public void zrusKlucovuFazuDrahy(Poloha poloha)
				{ zrušKľúčovúFázuDráhy(poloha); }


				/**
				 * <p>Označí takú fázu dráhy za kľúčovú, ktorej poloha je
				 * najbližšie k zadanej polohe a v rámci zadaného okruhu.
				 * Pri vyhľadávaní vhodnej fázy na označenie sú brané do úvahy
				 * len tie fázy, ktoré nie sú označené a sú bližšie než
				 * zadaná maximálna vzdialenosť. Označená je potom taká fáza,
				 * ktorá ešte nebola označená a leží najbližšie k zadanej
				 * polohe. Ak taká fáza nejestvuje, tak nie je označená žiadna
				 * fáza. V kľúčových fázach je
				 * spúšťaná metóda {@link #vstupDoKľúčovejFázyDráhy(int)}
				 * namiesto metódy {@link #kráčaniePoDráhe()}.</p>
				 * 
				 * @param fáza približná poloha fázy, ktorá má byť označená
				 *     za kľúčovú
				 * @param okruh vonkajší polomer okruhu bodov, ktoré sú brané
				 *     do úvahy
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void označKľúčovúFázuDráhy(Poloha poloha, double okruh)
				{
					int najbližší = -1;
					double najmenšiaVzdialenosť = -1;

					for (int i = 0; i < dráha.size(); ++i)
					{
						if (kľúčovéFázy.contains(i)) continue;

						Bod bod = dráha.get(i);
						double vzdialenosť = hypot(
							aktuálneX - bod.x, aktuálneY - bod.y);

						if (vzdialenosť < okruh)
						{
							if (-1 == najbližší ||
								vzdialenosť < najmenšiaVzdialenosť)
							{
								najbližší = i;
								najmenšiaVzdialenosť = vzdialenosť;
							}
						}
					}

					if (najbližší >= 0) kľúčovéFázy.add(najbližší);
				}

				/** <p><a class="alias"></a> Alias pre {@link #označKľúčovúFázuDráhy(Poloha, double) označKľúčovúFázuDráhy}.</p> */
				public void oznacKlucovuFazuDrahy(Poloha poloha, double okruh)
				{ označKľúčovúFázuDráhy(poloha, okruh); }


				/**
				 * <p>Zruší označenie takej fázy dráhy za kľúčové, ktorej poloha
				 * je najbližšie k zadanej polohe v rámci zadaného okruhu,
				 * pričom sú počas hľadania vhodnej fázy na zrušenie brané do
				 * úvahy len už označené fázy. To znamená, že z fáz v zadanom
				 * okruhu je zrušená tá, ktorá leží najbližšie k zadanej
				 * polohe. Ak taká fáza nejestvuje, nie je zrušená žiadna
				 * z fáz.</p>
				 * 
				 * @param fáza približná poloha kľúčovej fázy, ktorá má byť
				 *     zrušená
				 * @param okruh vonkajší polomer okruhu bodov, ktoré sú brané
				 *     do úvahy
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void zrušKľúčovúFázuDráhy(Poloha poloha, double okruh)
				{
					if (0 == kľúčovéFázy.size()) return;

					int najbližší = -1;
					double najmenšiaVzdialenosť = -1;

					Integer i = kľúčovéFázy.first();
					while (null != i)
					{
						Bod bod = dráha.get(i);
						double vzdialenosť = hypot(
							aktuálneX - bod.x, aktuálneY - bod.y);

						if (vzdialenosť < okruh)
						{
							if (-1 == najbližší ||
								vzdialenosť < najmenšiaVzdialenosť)
							{
								najbližší = i;
								najmenšiaVzdialenosť = vzdialenosť;
							}
						}

						i = kľúčovéFázy.higher(i);
					}

					if (najbližší >= 0) kľúčovéFázy.remove(najbližší);
				}

				/** <p><a class="alias"></a> Alias pre {@link #zrušKľúčovúFázuDráhy(Poloha, double) zrušKľúčovúFázuDráhy}.</p> */
				public void zrusKlucovuFazuDrahy(Poloha poloha, double okruh)
				{ zrušKľúčovúFázuDráhy(poloha, okruh); }


				/**
				 * <p>Metóda zistí, či sa robot práve nachádza v režime kráčania
				 * po dráhe. (Robot môže byť aj deaktivovaný, ale musí sa
				 * nachádzať v režime kráčania po dráhe.)</p>
				 * 
				 * @return ak je robot v režime kráčania po dráhe, tak je
				 *     návratová hodnota {@code valtrue}
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public boolean kráčamPoDráhe() { return fázaDráhy >= 0; }

				/** <p><a class="alias"></a> Alias pre {@link #kráčamPoDráhe() kráčamPoDráhe}.</p> */
				public boolean kracamPoDrahe() { return fázaDráhy >= 0; }

				/**
				 * <p>Zistí aktuálnu fázu pohybu robota po dráhe.</p>
				 * 
				 * @return aktuálna fáza pohybu po dráhe – index prvku
				 *     v zozname, ktorý určuje body dráhy
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public int fázaDráhy() { return fázaDráhy; }

				/** <p><a class="alias"></a> Alias pre {@link #fázaDráhy() fázaDráhy}.</p> */
				public int fazaDrahy() { return fázaDráhy; }

				/**
				 * <p>Zmení fázu pohybu robota po dráhe. Ak je hodnota novej fázy
				 * záporná, pohyb po dráhe je zastavený. Ak je hodnota kladná,
				 * robot sa presunie na bod s indexom novej fázy a pokračuje
				 * v pohybe po dráhe.</p>
				 * 
				 * @param nováFáza nová hodnota fázy pohybu robota po dráhe –
				 *     nový index prvku v zozname, ktorý určuje body dráhy
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void fázaDráhy(int nováFáza)
				{
					if (fázaDráhy >= 0)
					{
						if (nováFáza < 0) deaktivuj();
					}
					else
					{
						if (nováFáza >= 0) aktivuj();
					}

					fázaDráhy = nováFáza;
				}

				/** <p><a class="alias"></a> Alias pre {@link #fázaDráhy(int) fázaDráhy}.</p> */
				public void fazaDrahy(int nováFáza) { fázaDráhy(nováFáza); }

				/**
				 * <p>Táto metóda je predvolene prázdna. Je určená na prekrytie
				 * a je spúšťaná v pravidelnom časovom intervale počas pohybu
				 * robota po dráhe, okrem prípadov
				 * {@linkplain #označKľúčovúFázuDráhy(int) kľúčových fáz
				 * dráhy}, kedy je namiesto tejto metódy spustená metóda
				 * {@link #vstupDoKľúčovejFázyDráhy(int)
				 * vstupDoKľúčovejFázyDráhy}. V režime pohybu robota po dráhe
				 * nahrádza táto metóda spolu s metódou
				 * {@link #vstupDoKľúčovejFázyDráhy(int)
				 * vstupDoKľúčovejFázyDráhy} reakciu {@link #aktivita()}.</p>
				 * 
				 * @see #aktivita()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void kráčaniePoDráhe() {}

				/** <p><a class="alias"></a> Alias pre {@link #kráčaniePoDráhe() kráčaniePoDráhe}.</p> */
				public void kracaniePoDrahe() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je určená na
				 * prekrytie a je spúšťaná v {@linkplain 
				 * #označKľúčovúFázuDráhy(int) kľúčových fázach} počas
				 * pohybu robota po dráhe, kedy nahrádza volanie metódy
				 * {@link #kráčaniePoDráhe() kráčaniePoDráhe}. V režime
				 * pohybu robota po dráhe nahrádza táto metóda spolu s metódou
				 * {@link #kráčaniePoDráhe() kráčaniePoDráhe} reakciu
				 * {@link #aktivita()}.</p>
				 * 
				 * @param fáza aktuálne číslo fázy pohybu
				 * 
				 * @see #aktivita()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #státieNaDráhe()
				 * @see #koniecDráhy()
				 */
				public void vstupDoKľúčovejFázyDráhy(int fáza) {}

				/** <p><a class="alias"></a> Alias pre {@link #vstupDoKľúčovejFázyDráhy(int) vstupDoKľúčovejFázyDráhy}.</p> */
				public void vstupDoKlucovejFazyDrahy(int fáza) {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je určená na
				 * prekrytie a je spúšťaná v pravidelnom časovom
				 * intervale počas deaktivácie robota v režime pohybu
				 * po dráhe. V režime pohybu robota po dráhe nahrádza táto
				 * metóda reakciu {@link #pasivita()}.</p>
				 * 
				 * @see #pasivita()
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #koniecDráhy()
				 */
				public void státieNaDráhe() {}

				/** <p><a class="alias"></a> Alias pre {@link #státieNaDráhe() státieNaDráhe}.</p> */
				public void statieNaDrahe() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je určená na
				 * prekrytie a je spustená po dokončení pohybu robota
				 * po dráhe.</p>
				 * 
				 * @see #vytvorDráhu()
				 * @see #vytvorDráhu(double)
				 * @see #vytvorDráhu(Shape)
				 * @see #vytvorDráhu(Shape, double)
				 * @see #dráha()
				 * @see #dráha(Vector)
				 * @see #obráťDráhu()
				 * @see #posuňDráhu(double, double)
				 * @see #posuňDráhu(int)
				 * @see #vytvorMapuSmerov()
				 * @see #vytvorMapuSmerov(double)
				 * @see #vytvorMapuSmerov(Shape)
				 * @see #vytvorMapuSmerov(Shape, double)
				 * @see #mapaSmerov()
				 * @see #mapaSmerov(Vector)
				 * @see #obráťMapuSmerov()
				 * @see #pootočMapuSmerov(double)
				 * @see #posuňMapuSmerov(int)
				 * @see #kráčajPoDráhe()
				 * @see #zastavNaDráhe()
				 * @see #pokračujVDráhe()
				 * @see #označKľúčovúFázuDráhy(int)
				 * @see #zrušKľúčovúFázuDráhy(int)
				 * @see #označKľúčovúFázuDráhy(Poloha)
				 * @see #zrušKľúčovúFázuDráhy(Poloha)
				 * @see #označKľúčovúFázuDráhy(Poloha, double)
				 * @see #zrušKľúčovúFázuDráhy(Poloha, double)
				 * @see #kráčamPoDráhe()
				 * @see #fázaDráhy()
				 * @see #fázaDráhy(int)
				 * @see #kráčaniePoDráhe()
				 * @see #vstupDoKľúčovejFázyDráhy(int)
				 * @see #státieNaDráhe()
				 */
				public void koniecDráhy() {}

				/** <p><a class="alias"></a> Alias pre {@link #koniecDráhy() koniecDráhy}.</p> */
				public void koniecDrahy() {}


			// Metóda pracuj

				/**
				 * <p>Táto metóda je automaticky spúšťaná {@link 
				 * Svet#spustiČasovač(double) časovačom}. Tvorí model
				 * správania {@linkplain #aktívny() aktívne} roboty
				 * a zároveň pravidelne spúšťa metódu {@link #aktivita()
				 * aktivita} pre aktívne roboty a {@link #pasivita()
				 * pasivita} pre pasívne roboty. Aktívny robot môže mať
				 * definovaný {@linkplain #cieľ(double, double) cieľ} alebo
				 * trvanie aktivity (pozri {@link #aktivuj(int)
				 * aktivuj(trvanieAktivity)}. Na to, aby sa robot mohol
				 * pohybovať (a dostať sa do cieľa), musí mať definovanú
				 * hodnotu {@linkplain #rýchlosť(double) rýchlosti}, prípadne
				 * {@linkplain #zrýchlenie() zrýchlenia}. Ďalšie atribúty ako
				 * {@linkplain #maximálnaRýchlosť(double) maximálna
				 * rýchlosť}, {@linkplain #uhlováRýchlosť(double) rýchlosť
				 * otáčania}, {@linkplain #uhlovéZrýchlenie(double)
				 * zrýchlenie otáčania} a {@linkplain 
				 * #maximálnaUhlováRýchlosť(double) maximálna rýchlosť
				 * otáčania} sú nepovinné. Iba menia správanie robota pri
				 * pohybe, ktorý sa tým môže stať o niečo prirodzenejším.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Prekrytím tejto metódy
				 * by sme mohli úplne prepracovať správanie robota – aktívneho
				 * aj neaktívneho, avšak odporúčame ponechať predvolené
				 * správanie a iba korigovať správanie robotov prepisovaním
				 * metód {@link #aktivita() aktivita} a {@link #pasivita()
				 * pasivita}.</p>
				 */
				public void pracuj()
				{
					synchronized (ÚdajeUdalostí.zámokAktivít)
					{
						if (aktívny)
						{
							if (fázaDráhy >= 0)
							{
								if (fázaDráhy >= dráha.size())
								{
									fázaDráhy = -1;
									deaktivuj();
									koniecDráhy();
									koniecDrahy();
								}
								else
								{
									Bod bod = dráha.elementAt(fázaDráhy);
									Double smer = null;
									if (fázaDráhy < mapaSmerov.size())
										smer = mapaSmerov.elementAt(fázaDráhy);

									if (null == bod)
									{
										if (null != smer) smer(smer);
									}
									else
									{
										if (null == smer)
										{
											if (fázaDráhy >= mapaSmerov.size())
												otočNa(bod.x, bod.y);
										}
										else
											smer(smer);
										choďNa(bod.x, bod.y);
									}

									if (0 != kľúčovéFázy.size() &&
										kľúčovéFázy.contains(fázaDráhy))
									{
										vstupDoKľúčovejFázyDráhy(fázaDráhy);
										vstupDoKlucovejFazyDrahy(fázaDráhy);
									}
									else
									{
										kráčaniePoDráhe();
										kracaniePoDrahe();
									}
									++fázaDráhy;
								}
								return;
							}

							aspoňJedenAktívny = true;

							if (trvanieAktivity > 0 && --trvanieAktivity == 0)
							{
								deaktivuj();
							}

							if (cieľAktívny)
							{
								uhlováRýchlosť += uhlovéZrýchlenie;
								if (maximálnaUhlováRýchlosť != 0.0)
								{
									if (uhlováRýchlosť >
										maximálnaUhlováRýchlosť)
									{
										uhlováRýchlosť =
											maximálnaUhlováRýchlosť;
									}
									else if (uhlováRýchlosť <
										-maximálnaUhlováRýchlosť)
									{
										uhlováRýchlosť =
											-maximálnaUhlováRýchlosť;
									}
								}

								if (uhlováRýchlosť != 0.0)
								{
									otočNa(cieľX, cieľY, uhlováRýchlosť);
								}
								else
								{
									if (uhlovéZrýchlenie == 0.0)
									{
										otočNa(cieľX, cieľY);
									}
								}

								if (zrýchlenie != 0.0)
								{
									rýchlosť += zrýchlenie;
									if (maximálnaRýchlosť != 0.0)
									{
										if (rýchlosť > maximálnaRýchlosť)
											rýchlosť = maximálnaRýchlosť;
										else if (rýchlosť < -maximálnaRýchlosť)
											rýchlosť = -maximálnaRýchlosť;
									}

									if ((rýchlosť > 0.0 && zrýchlenie > 0.0) ||
										(rýchlosť < 0.0 && zrýchlenie < 0.0))
									{
										double brzdnáDráha =
											(rýchlosť * rýchlosť) /
												(2 * zrýchlenie);

										/*!!!
										if (sqrt(pow(cieľX - aktuálneX, 2) +
											pow(cieľY - aktuálneY, 2)) <
											brzdnáDráha)
										*/
										if (hypot(cieľX - aktuálneX,
											cieľY - aktuálneY) < brzdnáDráha)
										{
											zrýchlenie = -zrýchlenie;
										}
									}
								}

								overDosiahnutieCieľa();

								/*
								if (sqrt(pow(cieľX - aktuálneX, 2) +
									pow(cieľY - aktuálneY, 2)) <= rýchlosť)
								{
									double β = smerNa(cieľX, cieľY);
									if (abs(aktuálnyUhol - β) <= 0.01 ||
										abs(360 + aktuálnyUhol - β) <= 0.01)
									{
										poslednýUhol = aktuálnyUhol;
										aktuálnyUhol = β;
										choďNa(cieľX, cieľY);
										cieľAktívny = false;
										if (zastavVCieli)
										{
											if (zrýchlenie != 0)
											{
												if ((rýchlosť > 0.0 &&
													zrýchlenie < 0.0) ||
													rýchlosť < 0.0)
												{
													zrýchlenie = -zrýchlenie;
												}
												rýchlosť = 0.0;
											}
											zastav();
										}
										dosiahnutieCieľa();
										dosiahnutieCiela();
									}
								}
								*/

								if (cieľAktívny)
								{
									dopredu(rýchlosť);
									// doľava(uhlováRýchlosť);

									if (zrýchlenie != 0.0)
									{
										if (zastavPoSpomalení)
										{
											if (zrýchlenie > 0.0)
											{
												if (rýchlosť >= 0.0)
												{
													rýchlosť = 0.0;
													zastavPoSpomalení = false;
													zastav();
												}
											}
											else
											{
												if (rýchlosť <= 0.0)
												{
													rýchlosť = 0.0;
													zastavPoSpomalení = false;
													zastav();
												}
											}
										}
										else if (zrýchlenie < 0.0 &&
											rýchlosť <= 0.0)
											zrýchlenie = -zrýchlenie;
									}
								}
							}
							else if (
								rýchlosť != 0.0 ||
								rýchlosťPosunu != 0.0 ||
								uhlováRýchlosť != 0.0 ||
								zrýchlenie != 0.0 ||
								zrýchleniePosunu != 0.0 ||
								uhlovéZrýchlenie != 0.0)
							{
								rýchlosť += zrýchlenie;
								if (maximálnaRýchlosť != 0.0)
								{
									if (rýchlosť > maximálnaRýchlosť)
										rýchlosť = maximálnaRýchlosť;
									else if (rýchlosť < -maximálnaRýchlosť)
										rýchlosť = -maximálnaRýchlosť;
								}

								rýchlosťPosunu += zrýchleniePosunu;
								if (maximálnaRýchlosťPosunu != 0.0)
								{
									if (rýchlosťPosunu >
										maximálnaRýchlosťPosunu)
										rýchlosťPosunu =
										maximálnaRýchlosťPosunu;
									else if (rýchlosťPosunu <
										-maximálnaRýchlosťPosunu)
										rýchlosťPosunu =
										-maximálnaRýchlosťPosunu;
								}

								uhlováRýchlosť += uhlovéZrýchlenie;
								if (maximálnaUhlováRýchlosť != 0.0)
								{
									if (uhlováRýchlosť >
										maximálnaUhlováRýchlosť)
									{
										uhlováRýchlosť =
											maximálnaUhlováRýchlosť;
									}
									else if (uhlováRýchlosť <
										-maximálnaUhlováRýchlosť)
									{
										uhlováRýchlosť =
											-maximálnaUhlováRýchlosť;
									}
								}

								/* dopredu(rýchlosť);
								posuňVpravo(rýchlosťPosunu);*/
								posuň(rýchlosťPosunu, rýchlosť);
								doľava(uhlováRýchlosť);

								if (zastavPoSpomalení &&
									zrýchlenie != 0.0)
								{
									if (zrýchlenie > 0.0)
									{
										if (rýchlosť >= 0.0)
										{
											rýchlosť = 0.0;
											zastavPoSpomalení = false;
											// nie: zastavPoSpomaleníPosunu = false;
											zastav();
										}
									}
									else
									{
										if (rýchlosť <= 0.0)
										{
											rýchlosť = 0.0;
											zastavPoSpomalení = false;
											// nie: zastavPoSpomaleníPosunu = false;
											zastav();
										}
									}
								}

								if (zastavPoSpomaleníPosunu &&
									zrýchleniePosunu != 0.0)
								{
									if (zrýchleniePosunu > 0.0)
									{
										if (rýchlosťPosunu >= 0.0)
										{
											rýchlosťPosunu = 0.0;
											// nie: zastavPoSpomalení = false;
											zastavPoSpomaleníPosunu = false;
											// pozor‼
											// zrýchleniePosunu = 0.0;
											// ^ toto je vnútri nasledujúcej
											// (volanej) metódy a keby to bolo
											// nulové, metóda by neurobila nič‼
											zastavPosun();
										}
									}
									else
									{
										if (rýchlosťPosunu <= 0.0)
										{
											rýchlosťPosunu = 0.0;
											// nie: zastavPoSpomalení = false;
											zastavPoSpomaleníPosunu = false;
											// pozor‼
											// zrýchleniePosunu = 0.0;
											// ^ toto je vnútri nasledujúcej
											// (volanej) metódy a keby to bolo
											// nulové, metóda by neurobila nič‼
											zastavPosun();
										}
									}
								}
							}

							if (null != gyroskop)
							{
								if (0.0 != otáčanieTvaru)
								{
									gyroskop += otáčanieTvaru;
									gyroskop %= 360;
									if (gyroskop < 0)
										gyroskop += 360;
								}

								pootočenieTvaru = gyroskop - aktuálnyUhol;

								pootočenieTvaru %= 360;
								if (pootočenieTvaru < 0)
									pootočenieTvaru += 360;
							}
							else if (0.0 != otáčanieTvaru)
							{
								pootočenieTvaru += otáčanieTvaru;
								pootočenieTvaru %= 360;
								if (pootočenieTvaru < 0)
									pootočenieTvaru += 360;
							}

							aktivita();
						}
						else
						{
							if (fázaDráhy >= 0)
							{
								státieNaDráhe();
								statieNaDrahe();
								return;
							}

							if (trvaniePasivity > 0 &&
								--trvaniePasivity == 0)
								aktivuj();

							pasivita();
						}
					}
				}


			// Výzvy

				/**
				 * <p>Spustením tejto metódy sa pre každý robot (podľa ich
				 * aktuálneho poradia) vykoná reakcia
				 * {@link GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy},
				 * pričom autorom výzvy bude tento robot a hodnota argumentu
				 * {@code kľúč} bude rovná {@code -}{@code num1}. Prvotné
				 * poradie robotov je určené poradím ich vytvorenia (čiže ak
				 * sme nijako neovplyvnili poradie robotov, je prvý vyzvaný
				 * ten robot, ktorý bol vytvorený ako prvý, to jest robot,
				 * ktorý je nakreslený pod všetkými ostatnými robotmi).
				 * Dodatočne môžeme poradie ovplyvniť volaním metód {@link 
				 * GRobot#naVrch() naVrch}, {@link GRobot#naSpodok()
				 * naSpodok}, {@link GRobot#vyššie() vyššie}, {@link 
				 * GRobot#nižšie() nižšie}, {@link GRobot#pred(GRobot) pred}
				 * a {@link GRobot#za(GRobot) za}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Ak je poradie robotov
				 * zmenené počas {@linkplain GRobot#prijatieVýzvy(GRobot, int)
				 * spracovania výzviev}, dôjde z technických príčin
				 * k opätovnému spusteniu posielania výziev (inak povedané –
				 * posielanie výziev sa „reštartuje“). To znamená, že niektoré
				 * roboty budú vyzvané dva alebo viac ráz. Buďte preto opatrní
				 * so zmenami poradia v rámci spracovania výziev, aby ste
				 * nespôsobili vznik nekonečného cyklu… (Rovnaký efekt má
				 * prípadné vytvorenie nového robota, resp. ľubovoľnej
				 * inštancie triedy odvodenej od robota.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Mechanizmus výziev nie
				 * je taký efektívny ako definícia vlastného {@linkplain Zoznam
				 * zoznamu robotov} (prípadne inštancií odvodených tried)
				 * a vykonanie hromadnej akcie s pomocou tohto zoznamu. Slúži
				 * predovšedkým na umožnenie hromadného spracovania bez
				 * nevyhnutnosti vytvárania takého zoznamu (napríklad pri
				 * malom počte robotov alebo predtým, než sa programátor
				 * podrobnejšie oboznámi s možnosťami zoznamov).</p>
				 * 
				 * <p>Príklad použitia mechanizmu výziev je napríklad
				 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
				 * mimoHraníc}.</p>
				 * 
				 * @see #prijatieVýzvy(GRobot, int)
				 * @see #vyzviRoboty(int)
				 * @see #vyzviRoboty(int, boolean)
				 * @see Svet#vyzviRoboty()
				 */
				public void vyzviRoboty()
				{
					if (zámokZoznamuRobotov2)
					{
						GRobotException.vypíšChybovéHlásenie(
							"Zdvojená výzva bola zamietnutá!");
					}
					else
					{
						zámokZoznamuRobotov2 = true;

						boolean reštart;
						do {
							zoznamZmenený2 = false;
							reštart = false;
							for (GRobot tento : zoznamRobotov)
							{
								tento.prijatieVýzvy(this, -1);
								tento.prijatieVyzvy(this, -1);
								if (zoznamZmenený2)
								{
									reštart = true;
									break;
								}
							}
						} while (reštart);

						zámokZoznamuRobotov2 = false;
						zlúčiťZoznamy();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #vyzviRoboty() vyzviRoboty}.</p> */
				public void vyzviRobotov() { vyzviRoboty(); }

				/**
				 * <p>Spustením tejto metódy sa pre každý robot (podľa ich
				 * aktuálneho poradia) vykoná reakcia {@link 
				 * GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}, pričom
				 * autorom výzvy bude tento robot. S pomocou argumentu
				 * {@code kľúč} môžeme odlišovať rôzne druhy výziev
				 * a ovplyvňovať tým správanie reakcie {@link 
				 * GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}. Prvotné
				 * poradie robotov je určené poradím ich vytvorenia (čiže ak
				 * sme nijako neovplyvnili poradie robotov, je prvý vyzvaný
				 * ten robot, ktorý bol vytvorený ako prvý, to jest robot,
				 * ktorý je nakreslený pod všetkými ostatnými robotmi).
				 * Dodatočne môžeme poradie ovplyvniť volaním metód {@link 
				 * GRobot#naVrch() naVrch}, {@link GRobot#naSpodok()
				 * naSpodok}, {@link GRobot#vyššie() vyššie}, {@link 
				 * GRobot#nižšie() nižšie}, {@link GRobot#pred(GRobot) pred}
				 * a {@link GRobot#za(GRobot) za}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Ak je poradie robotov
				 * zmenené počas {@linkplain GRobot#prijatieVýzvy(GRobot, int)
				 * spracovania výzviev}, dôjde z technických príčin
				 * k opätovnému spusteniu posielania výziev (inak povedané –
				 * posielanie výziev sa „reštartuje“). To znamená, že niektoré
				 * roboty budú vyzvané dva alebo viac ráz. Buďte preto opatrní
				 * so zmenami poradia v rámci spracovania výziev, aby ste
				 * nespôsobili vznik nekonečného cyklu… (Rovnaký efekt má
				 * prípadné vytvorenie nového robota, resp. ľubovoľnej
				 * inštancie triedy odvodenej od robota.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Mechanizmus výziev nie
				 * je taký efektívny ako definícia vlastného {@linkplain Zoznam
				 * zoznamu robotov} (prípadne inštancií odvodených tried)
				 * a vykonanie hromadnej akcie s pomocou tohto zoznamu. Slúži
				 * predovšedkým na umožnenie hromadného spracovania bez
				 * nevyhnutnosti vytvárania takého zoznamu (napríklad pri
				 * malom počte robotov alebo predtým, než sa programátor
				 * podrobnejšie oboznámi s možnosťami zoznamov).</p>
				 * 
				 * <p>Príklad použitia mechanizmu výziev je napríklad
				 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
				 * mimoHraníc}.</p>
				 * 
				 * @param kľúč celočíselná hodnota, ktorá je poslaná do
				 *     reakcie {@link GRobot#prijatieVýzvy(GRobot, int)
				 *     prijatieVýzvy} každého robota; takto je možné
				 *     odlíšiť rôzne druhy výziev, vďaka čomu môžeme
				 *     ovplyvniť správanie reakcie {@link 
				 *     GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}
				 * 
				 * @see #prijatieVýzvy(GRobot, int)
				 * @see #vyzviRoboty()
				 * @see #vyzviRoboty(int, boolean)
				 * @see Svet#vyzviRoboty(int)
				 */
				public void vyzviRoboty(int kľúč)
				{
					if (zámokZoznamuRobotov2)
					{
						GRobotException.vypíšChybovéHlásenie(
							"Zdvojená výzva bola zamietnutá!");
					}
					else
					{
						zámokZoznamuRobotov2 = true;

						boolean reštart;
						do {
							zoznamZmenený2 = false;
							reštart = false;
							for (GRobot tento : zoznamRobotov)
							{
								tento.prijatieVýzvy(this, kľúč);
								tento.prijatieVyzvy(this, kľúč);
								if (zoznamZmenený2)
								{
									reštart = true;
									break;
								}
							}
						} while (reštart);

						zámokZoznamuRobotov2 = false;
						zlúčiťZoznamy();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #vyzviRoboty(int) vyzviRoboty}.</p> */
				public void vyzviRobotov(int kľúč) { vyzviRoboty(kľúč); }

				/**
				 * <p>Spustením tejto metódy sa pre každý robot (podľa ich
				 * aktuálneho poradia) vykoná reakcia {@link 
				 * GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}, pričom
				 * autorom výzvy bude tento robot. S pomocou argumentu
				 * {@code kľúč} môžeme odlišovať rôzne druhy výziev
				 * a ovplyvňovať tým správanie reakcie {@link 
				 * GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}. Argument
				 * {@code obrátene} určuje smer spracovania. Ak je rovný
				 * {@code valtrue}, zoznam robotov bude spracovaný od konca,
				 * to znamená, že prvý bude vyzvaný buď naposledy vytvorený
				 * robot, alebo robot aktuálne umiestnený na konci vnútorného
				 * zoznamu robotov. Záleží od toho, či sme dodatočne
				 * ovplyvňovali poradie robotov metódami {@link 
				 * GRobot#naVrch() naVrch}, {@link GRobot#naSpodok()
				 * naSpodok}, {@link GRobot#vyššie() vyššie}, {@link 
				 * GRobot#nižšie() nižšie}, {@link GRobot#pred(GRobot) pred}
				 * a {@link GRobot#za(GRobot) za}. Ak je hodnota argumentu
				 * {@code obrátene} rovná {@code valfalse}, metóda sa správa
				 * rovnako ako {@link #vyzviRoboty(int)}.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Ak je poradie robotov
				 * zmenené počas {@linkplain GRobot#prijatieVýzvy(GRobot, int)
				 * spracovania výzviev}, dôjde z technických príčin
				 * k opätovnému spusteniu posielania výziev (inak povedané –
				 * posielanie výziev sa „reštartuje“). To znamená, že niektoré
				 * roboty budú vyzvané dva alebo viac ráz. Buďte preto opatrní
				 * so zmenami poradia v rámci spracovania výziev, aby ste
				 * nespôsobili vznik nekonečného cyklu… (Rovnaký efekt má
				 * prípadné vytvorenie nového robota, resp. ľubovoľnej
				 * inštancie triedy odvodenej od robota.)</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Mechanizmus výziev nie
				 * je taký efektívny ako definícia vlastného {@linkplain Zoznam
				 * zoznamu robotov} (prípadne inštancií odvodených tried)
				 * a vykonanie hromadnej akcie s pomocou tohto zoznamu. Slúži
				 * predovšedkým na umožnenie hromadného spracovania bez
				 * nevyhnutnosti vytvárania takého zoznamu (napríklad pri
				 * malom počte robotov alebo predtým, než sa programátor
				 * podrobnejšie oboznámi s možnosťami zoznamov).</p>
				 * 
				 * <p>Príklad použitia mechanizmu výziev je napríklad
				 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
				 * mimoHraníc}.</p>
				 * 
				 * @param kľúč celočíselná hodnota, ktorá je poslaná do
				 *     reakcie {@link GRobot#prijatieVýzvy(GRobot, int)
				 *     prijatieVýzvy} každého robota; takto je možné
				 *     odlíšiť rôzne druhy výziev, vďaka čomu môžeme
				 *     ovplyvniť správanie reakcie {@link 
				 *     GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}
				 * @param obrátene týmto argumentom môžeme ovplyvniť smer
				 *     spracovania; {@code valtrue} znamená spracovanie
				 *     vnútorného zoznamu robotov od konca; {@code valfalse}
				 *     znamená rovnaký spôsob spracovania ako pri metóde
				 *     {@link #vyzviRoboty(int)}
				 * 
				 * @see #prijatieVýzvy(GRobot, int)
				 * @see #vyzviRoboty()
				 * @see #vyzviRoboty(int)
				 * @see Svet#vyzviRoboty(int, boolean)
				 */
				public void vyzviRoboty(int kľúč, boolean obrátene)
				{
					if (zámokZoznamuRobotov2)
					{
						GRobotException.vypíšChybovéHlásenie(
							"Zdvojená výzva bola zamietnutá!");
					}
					else
					{
						zámokZoznamuRobotov2 = true;

						if (obrátene)
						{
							boolean reštart;
							do {
								zoznamZmenený2 = false;
								reštart = false;
								for (int i = zoznamRobotov.size() - 1;
									i >= 0; --i)
								{
									GRobot tento = zoznamRobotov.get(i);
									tento.prijatieVýzvy(this, kľúč);
									tento.prijatieVyzvy(this, kľúč);
									if (zoznamZmenený2)
									{
										reštart = true;
										break;
									}
								}
							} while (reštart);
						}
						else
						{
							boolean reštart;
							do {
								zoznamZmenený2 = false;
								reštart = false;
								for (GRobot tento : zoznamRobotov)
								{
									tento.prijatieVýzvy(this, kľúč);
									tento.prijatieVyzvy(this, kľúč);
									if (zoznamZmenený2)
									{
										reštart = true;
										break;
									}
								}
							} while (reštart);
						}

						zámokZoznamuRobotov2 = false;
						zlúčiťZoznamy();
					}
				}

				/** <p><a class="alias"></a> Alias pre {@link #vyzviRoboty(int, boolean) vyzviRoboty}.</p> */
				public void vyzviRobotov(int kľúč, boolean obrátene)
				{ vyzviRoboty(kľúč, obrátene); }


			// Metódy aktivít na prekrytie

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spúšťaná
				 * metódou {@link #pracuj() pracuj} pri aktívnom robote. Jej
				 * prekrytím môžete upraviť správanie aktívneho robota.
				 * V režime pohybu robota po dráhe je táto metóda nahradená
				 * reakciami {@link #kráčaniePoDráhe()}
				 * a {@link #vstupDoKľúčovejFázyDráhy(int)}.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Robot v tomto príklade kreslí šedý chuchvalec.
				 * V konštruktore je robot aktivovaný a nastavuje svoju farbu
				 * na šedú. Po aktivácii je až do ukončenia aplikácie
				 * neustále automaticky spúšťaná metóda {@code aktivita},
				 * v ktorej robot náhodne mení smer a posúva sa o jeden a pol
				 * boda dopredu. Výsledný efekt je nekonečné kreslenie
				 * chuchvalca šedého vlákna…</p>
				 * 
				 * <table><tr><td>
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} HlavnáTrieda {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} HlavnáTrieda()
						{
							{@link #farba(Color) farba}({@link Farebnosť#šedá šedá});
							{@link #aktivuj() aktivuj}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code curraktivita}()
						{
							{@link #náhodnýSmer() náhodnýSmer}();
							{@link #dopredu(double) dopredu}({@code num1.5});
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@code kwdnew} HlavnáTrieda();
						}
					}
					</pre>
				 * </td><td>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>chuchvalec.png<alt/>Výsledok náhodného kreslenia
				 * počas aktivity robota.</image>Ukážka možného výstupu
				 * náhodného kreslenia na zmenšenom plátne<br />(robot i tak
				 * väčšinou veľmi rýchlo opustí plochu
				 * plátna).</p></td></tr></table>
				 * 
				 * @see #pasivita()
				 * @see #aktivácia()
				 * @see #deaktivácia()
				 * @see #spustenie()
				 * @see #zastavenie()
				 * @see #dosiahnutieCieľa()
				 * @see #kráčaniePoDráhe()
				 */
				public void aktivita() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spúšťaná
				 * metódou {@link #pracuj() pracuj} pri pasívnom robote. Jej
				 * prekrytím môžete upraviť správanie pasívneho robota.
				 * V režime pohybu robota po dráhe je táto metóda nahradená
				 * reakciou {@link #státieNaDráhe()}.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Príklad ukazuje implementáciu blikania robota v dvoch
				 * odtieňoch oranžovej farby.</p>
				 * 
				 * <p>V tomto príklade musíme ručne spustiť {@linkplain 
				 * Svet#spustiČasovač(double) časovač} (pretože ten nie je
				 * spúšťaný automaticky a keďže ideme pracovať s pasívnym
				 * robotom, nepoužívame žiadny príkaz, ktorý spúšťa časovač
				 * automaticky). V dôsledku toho je v pravidelnom časovom
				 * intervale spúšťaná metóda {@code pasivita}, v ktorej je
				 * umiestnené jednoduché vetvenie spôsobujúce blikanie robota
				 * v dvoch odtieňoch oranžovej farby, čo má symbolizovať
				 * pohotovostný režim. Konštruktor má za úlohu iba
				 * inicializovať farbu robota na jeden z odtieňov oranžovej.</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} HlavnáTrieda {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} HlavnáTrieda()
						{
							{@link #farba(Color) farba}({@link Farebnosť#oranžová oranžová});

							{@code comm// Nastavíme predvolený vyplnený tvar robota a zväčšíme}
							{@code comm// jeho veľkosť, aby bol efekt lepšie viditeľný:}
							{@link #predvolenýVyplnenýTvar() predvolenýVyplnenýTvar}();
							{@link #veľkosť() veľkosť}({@code num30});
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code currpasivita}()
						{
							{@code kwdif} ({@link Farebnosť#oranžová oranžová} == {@link #farba() farba}())
								{@link #farba(Color) farba}({@link Farebnosť#tmavooranžová tmavooranžová});
							{@code kwdelse}
								{@link #farba(Color) farba}({@link Farebnosť#oranžová oranžová});
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@code kwdnew} HlavnáTrieda();
							{@link Svet Svet}.{@link Svet#spustiČasovač(double) spustiČasovač}({@code num0.5});
						}
					}
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>blikaj-oranzovy.gif<alt/>Oranžový blikajúci
				 * robot.</image>Výrez plochy s blikajúcim oranžovým
				 * robotom.</p>
				 * 
				 * @see #aktivita()
				 * @see #aktivácia()
				 * @see #deaktivácia()
				 * @see #spustenie()
				 * @see #zastavenie()
				 * @see #dosiahnutieCieľa()
				 * @see #státieNaDráhe()
				 */
				public void pasivita() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spustená
				 * pri volaní metódy {@link #aktivuj() aktivuj} (alebo jej
				 * „klonu“). Jej prekrytím môžete upraviť správanie robota pri
				 * aktivácii.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Tento príklad je podobný ako ten pri metóde {@link 
				 * #spustenie() spustenie}. Oba sa vzájomne odlišujú
				 * v spôsobe aktivácie robota fungujúceho v úlohe strely a aj
				 * v dĺžke aktivity. Tento príklad otočí robot pri kliknutí
				 * myšou na pozíciu ukazovateľa myši a aktivuje ho na {@code 
				 * num10} tikov. Ide o klasickú aktiváciu (v zmysle
				 * vysvetlenia v opise metódy {@link #aktívny() aktívny}),
				 * preto sú prekryté metódy {@code curraktivácia} a {@link 
				 * #deaktivácia() deaktivácia}. Tie zariadia, že robot
				 * (strela) sa po aktivácii zobrazí a pri deaktivácii, naopak,
				 * skryje.</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} HlavnáTrieda {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} HlavnáTrieda()
						{
							{@link #zdvihniPero() zdvihniPero}();
							{@link #rýchlosť(double, boolean) rýchlosť}({@code num10}, {@code valfalse});
							{@link #skry() skry}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code curraktivácia}()
						{
							{@link #zobraz() zobraz}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link #deaktivácia() deaktivácia}()
						{
							{@link #skry() skry}();
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@code kwdfinal} {@link GRobot GRobot} strela = {@code kwdnew} HlavnáTrieda();

							{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
							{
								{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#klik() klik}()
								{
									strela.{@link #otočNaMyš() otočNaMyš}();
									strela.{@link #aktivuj(int) aktivuj}({@code num10});
								}
							};
						}
					}
					</pre>
				 * 
				 * @see #aktivita()
				 * @see #pasivita()
				 * @see #deaktivácia()
				 * @see #spustenie()
				 * @see #zastavenie()
				 * @see #dosiahnutieCieľa()
				 */
				public void aktivácia() {}

				/** <p><a class="alias"></a> Alias pre {@link #aktivácia() aktivácia}.</p> */
				public void aktivacia() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spustená
				 * pri volaní metódy {@link #deaktivuj() deaktivuj}. Jej
				 * prekrytím môžete upraviť správanie robota pri deaktivácii.<p>
				 * 
				 * <p>Príklad použitia tejto metódy je pri opise metódy
				 * {@link #aktivácia() aktivácia}.</p>
				 * 
				 * @see #aktivita()
				 * @see #pasivita()
				 * @see #aktivácia()
				 * @see #spustenie()
				 * @see #zastavenie()
				 * @see #dosiahnutieCieľa()
				 */
				public void deaktivácia() {}

				/** <p><a class="alias"></a> Alias pre {@link #deaktivácia() deaktivácia}.</p> */
				public void deaktivacia() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spustená
				 * pri volaní metódy {@link #spusti() spusti} (alebo jej
				 * „klonu“). Jej prekrytím môžete upraviť správanie robota pri
				 * „spustení“ (čo je chápané ako druh akcie s individuálnym
				 * robotom, nie v zmysle spustenia aplikácie, ani nič podobné).</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Tento príklad je podobný ako ten pri metóde {@link 
				 * #aktivácia() aktivácia}. Oba sa vzájomne odlišujú
				 * v spôsobe aktivácie robota fungujúceho v úlohe strely a aj
				 * v dĺžke aktivity. Tento príklad funguje na princípe
				 * sledovania cieľa. Pri kliknutí myšou je zahájené smerovanie
				 * robota (strely) do cieľa, pričom cieľom je pozícia myši
				 * v čase kliknutia. Ide o alternatívnu aktiváciu (v zmysle
				 * vysvetlenia v opise metódy {@link #aktívny() aktívny}),
				 * preto sú prekryté metódy {@code currspustenie} a {@link 
				 * #zastavenie() zastavenie}. Tie zariadia, že robot (strela)
				 * sa po zahájení smerovania na cieľ zobrazí a po dosiahnutí
				 * cieľa, naopak, skryje.</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} HlavnáTrieda {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} HlavnáTrieda()
						{
							{@link #zdvihniPero() zdvihniPero}();
							{@link #rýchlosť(double, boolean) rýchlosť}({@code num10}, {@code valfalse});
							{@link #skry() skry}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code currspustenie}()
						{
							{@link #zobraz() zobraz}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link #zastavenie() zastavenie}()
						{
							{@link #skry() skry}();
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@code kwdfinal} {@link GRobot GRobot} strela = {@code kwdnew} HlavnáTrieda();

							{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
							{
								{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#klik() klik}()
								{
									strela.{@link #cieľNaMyš(boolean) cieľNaMyš}({@code valtrue});
								}
							};
						}
					}
					</pre>
				 * 
				 * @see #aktivita()
				 * @see #pasivita()
				 * @see #aktivácia()
				 * @see #deaktivácia()
				 * @see #zastavenie()
				 * @see #dosiahnutieCieľa()
				 */
				public void spustenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spustená
				 * pri volaní metódy {@link #zastav() zastav}. Jej prekrytím
				 * môžete upraviť správanie robota pri „zastavení“ (čo je
				 * chápané ako opak „{@linkplain #spustenie() spustenia}“).</p>
				 * 
				 * <p>Príklad použitia tejto metódy je pri opise metódy
				 * {@link #spustenie() spustenie}.</p>
				 * 
				 * @see #aktivita()
				 * @see #pasivita()
				 * @see #aktivácia()
				 * @see #deaktivácia()
				 * @see #spustenie()
				 * @see #dosiahnutieCieľa()
				 */
				public void zastavenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky
				 * spustená pri volaní metódy {@link #zastavPosun()
				 * zastavPosun} po splnení podmienok, ktoré sú pri nej určené.
				 * Prekrytím tejto metódy môžete upraviť správanie robota pri
				 * zastavení {@linkplain #rýchlosťPosunu() posunu} (čo je druh
				 * pohybu kolmý na aktuálny smer robota).</p>
				 * 
				 * @see #zastavenie()
				 * @see #zastavPosun()
				 * @see #rýchlosťPosunu()
				 * @see #zrýchleniePosunu()
				 * @see #zastavPoSpomaleníPosunu()
				 */
				public void zastaveniePosunu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spustená
				 * metódou {@link #pracuj() pracuj} po dosiahnutí {@linkplain 
				 * #cieľ(double, double) cieľa}. Jej prekrytím môžete upraviť
				 * správanie robota pri dosiahnutí cieľa.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>V tomto jednoduchom príklade robot pri každom kliknutí
				 * zamieri na pozíciu myši v čase kliknutia a po dosiahnutí
				 * stanoveného cieľa náhodne zmení veľkosť v rozmedzí {@code 
				 * num5} až {@code num25}.</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} HlavnáTrieda {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} HlavnáTrieda()
						{
							{@link #zdvihniPero() zdvihniPero}();
							{@link #rýchlosť(double, boolean) rýchlosť}({@code num10}, {@code valfalse});

							{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
							{
								{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#klik() klik}()
								{
									{@link #cieľNaMyš(boolean) cieľNaMyš}({@code valtrue});
								}
							};
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code currdosiahnutieCieľa}()
						{
							{@link #veľkosť(double) veľkosť}({@link Svet Svet}.{@link Svet#náhodnéCeléČíslo(long, long) náhodnéCeléČíslo}({@code num5}, {@code num25}));
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@code kwdnew} HlavnáTrieda();
						}
					}
					</pre>
				 * 
				 * @see #aktivita()
				 * @see #pasivita()
				 * @see #aktivácia()
				 * @see #deaktivácia()
				 * @see #spustenie()
				 * @see #zastavenie()
				 */
				public void dosiahnutieCieľa() {}

				/** <p><a class="alias"></a> Alias pre {@link #dosiahnutieCieľa() dosiahnutieCieľa}.</p> */
				public void dosiahnutieCiela() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky
				 * spustená pri zobrazení robota, napríklad počas konštrukcie
				 * robota, po volaní metódy {@link #zobraz() zobraz} (alebo
				 * jej „klonu“), prípadne po zmene viditeľnosti (to jest
				 * zobrazení) robota počas prechodu na domovskú pozíciu.
				 * Jej prekrytím sa dá upraviť správanie robota počas jeho
				 * zobrazenia.</p>
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>V tomto príklade sú reakcie {@code currzobrazenie}
				 * a {@link #skrytie() skrytie} využité na synchronizované
				 * zobrazovanie a skrývanie dvoch robotov, z ktorých jeden
				 * predstavuje podvozok a druhý delo tanku (z ktorých oboje
				 * môže mať samostatný smer). Smerovanie dela sa riadi
				 * jednoducho pohybom myši nad plátnom a na ovládanie podvozku
				 * tanku slúžia klávesy {@code A}, {@code S}, {@code W},
				 * {@code D}. Na synchronizované zobrazovanie a skrývanie
				 * dvojice robotov slúžia medzerník a ľubovoľné tlačidlo
				 * myši.</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} ZobrazenieRobota {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdprivate} {@code kwdstatic} {@link GRobot GRobot} delo;

						{@code kwdprivate} ZobrazenieRobota()
						{
							{@link GRobot#ohranič() ohranič}();
							{@link GRobot#zaoblenie(double) zaoblenie}({@code num5});
							{@link GRobot#pomer(double) pomer}({@code num0.8});
							{@link GRobot#zdvihniPero() zdvihniPero}();
							{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num2.5});
							{@link Svet Svet}.{@link Svet#zbaľ() zbaľ}();
							{@link Svet Svet}.{@link Svet#prekresli() prekresli}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#kresliTvar() kresliTvar}()
						{
							{@link GRobot#obdĺžnik() obdĺžnik}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code currzobrazenie}()
						{
							delo.{@link GRobot#zobraz() zobraz}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#skrytie() skrytie}()
						{
							delo.{@link GRobot#skry() skry}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#stlačenieKlávesu() stlačenieKlávesu}()
						{
							{@code kwdswitch} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#kláves() kláves}())
							{
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_W VK_W}: {@link GRobot#rýchlosť(double) rýchlosť}({@code num10}); {@code kwdbreak};
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_S VK_S}: {@link GRobot#rýchlosť(double) rýchlosť}(-{@code num10}); {@code kwdbreak};
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_A VK_A}: {@link GRobot#rýchlosťOtáčania(double) rýchlosťOtáčania}({@code num10}); {@code kwdbreak};
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_D VK_D}: {@link GRobot#rýchlosťOtáčania(double) rýchlosťOtáčania}(-{@code num10}); {@code kwdbreak};
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#MEDZERA MEDZERA}: {@link GRobot#skry() skry}(); {@code kwdbreak};
							}
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#uvoľnenieKlávesu() uvoľnenieKlávesu}()
						{
							{@code kwdswitch} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#kláves() kláves}())
							{
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_W VK_W}: {@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_S VK_S}: {@link GRobot#rýchlosť(double) rýchlosť}({@code num0}); {@code kwdbreak};
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_A VK_A}: {@code kwdcase} {@link Kláves Kláves}.{@link Kláves#VK_D VK_D}: {@link GRobot#rýchlosťOtáčania(double) rýchlosťOtáčania}({@code num0}); {@code kwdbreak};
							{@code kwdcase} {@link Kláves Kláves}.{@link Kláves#MEDZERA MEDZERA}: {@link GRobot#zobraz() zobraz}(); {@code kwdbreak};
							}
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#aktivita() aktivita}()
						{
							delo.{@link GRobot#skočNa(Poloha) skočNa}({@code valthis});
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#pohybMyši() pohybMyši}()
						{
							delo.{@link GRobot#otočNaMyš() otočNaMyš}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#stlačenieTlačidlaMyši() stlačenieTlačidlaMyši}()
						{
							{@link GRobot#skry() skry}();
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#uvoľnenieTlačidlaMyši() uvoľnenieTlačidlaMyši}()
						{
							{@link GRobot#zobraz() zobraz}();
						}

						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
						{
							{@link Svet Svet}.{@link Svet#použiKonfiguráciu(String) použiKonfiguráciu}({@code srg"ZobrazenieRobota.cfg"});
							delo = {@code kwdnew} {@link GRobot GRobot}({@code num500}, {@code num400});
							delo.{@link GRobot#vlastnýTvar(KreslenieTvaru) vlastnýTvar}(r -&gt; r.{@link GRobot#vpred() vpred}());
							delo.{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num5});
							delo.{@link GRobot#veľkosť(double) veľkosť}({@code num15});
							{@code kwdnew} ZobrazenieRobota();
						}
					}
					</pre>
				 * 
				 * <p><image>zobrazenie-robota.png<alt/>Ukážka fungovania
				 * príkladu ZobrazenieRobota.</image>Ukážka fungovania
				 * príkladu synchronizovaného zobrazenia a skrytia robotov
				 * (podvozku a dela tanku).</p>
				 * 
				 * @see #skrytie()
				 */
				public void zobrazenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky
				 * spustená pri skrytí robota, napríklad po volaní metódy
				 * {@link #skry() skry} alebo po zmene viditeľnosti (to jest
				 * skrytí) robota počas prechodu na domovskú pozíciu. Jej
				 * prekrytím sa dá upraviť správanie robota počas jeho
				 * skrytia.<p>
				 * 
				 * <p>Príklad použitia tejto metódy je v opise metódy
				 * {@link #zobrazenie() zobrazenie}.</p>
				 * 
				 * @see #zobrazenie()
				 */
				public void skrytie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je automaticky spustená
				 * pri vykonaní metódy {@link Svet#vyzviRoboty(int)
				 * Svet.vyzviRoboty(kľúč)} alebo {@link 
				 * GRobot#vyzviRoboty(int) GRobot.vyzviRoboty(kľúč)}.
				 * Rozhodovanie o účele aktuálnej výzvy v tele tejto reakcie
				 * je možné určiť s pomocou hodnoty kľúča, ktorého hodnotu
				 * zadávame pri volaní metód {@link Svet#vyzviRoboty(int)
				 * Svet.vyzviRoboty(kľúč)}, {@link GRobot#vyzviRoboty(int)
				 * GRobot.vyzviRoboty(kľúč)}.</p>
				 * 
				 * <p class="tip"><b>Tip:</b> Parameter {@code kľúč} poskytuje
				 * potrebný základ k mechanizmu spracovania výziev. Širšie
				 * možnosti poskytuje parameter {@code autor}. Stačí si
				 * uvedomiť, že to nemusí byť nevyhnutne objekt typu
				 * {@link GRobot GRobot}, ale aj ľubovoľný objekt odvodeného
				 * údajového typu, ktorý môže obsahovať množstvo doplnkových
				 * údajov. Autora môžeme vždy spracovať s pomocou mechanizmu
				 * pretypovania. <b>Pozri nasledujúci kód.</b></p>
				 * 
				 * <pre CLASS="example">
					{@code kwdif} (autor {@code typeinstanceof} OdvodenýTyp)
					{
						OdvodenýTyp odvodenáInštancia = (OdvodenýTyp)autor;
						{@code comm// práca s údajmi odvodenej inštancie…}
					}
					</pre>
				 * 
				 * @param autor obsahuje buď objekt, ktorý výzvu poslal
				 *     (autora výzvy), alebo {@code valnull} ak išlo o výzvu
				 *     zo strany sveta ({@link Svet#vyzviRoboty(int)
				 *     Svet.vyzviRoboty(kľúč)})
				 * @param kľúč hodnota prijímaná z metód
				 *     {@link Svet#vyzviRoboty(int)
				 *     Svet.vyzviRoboty(kľúč)}, {@link 
				 *     GRobot#vyzviRoboty(int) GRobot.vyzviRoboty(kľúč)}
				 * 
				 * @see #vyzviRoboty()
				 * @see #vyzviRoboty(int)
				 * @see #vyzviRoboty(int, boolean)
				 * @see Svet#vyzviRoboty()
				 * @see Svet#vyzviRoboty(int)
				 * @see Svet#vyzviRoboty(int, boolean)
				 */
				public void prijatieVýzvy(GRobot autor, int kľúč) {}

				/** <p><a class="alias"></a> Alias pre {@link #prijatieVýzvy(GRobot, int) prijatieVýzvy}.</p> */
				public void prijatieVyzvy(GRobot autor, int kľúč) {}

				/**
				 * <p>Táto metóda je predvolene prázdna. Je určená na prekrytie
				 * v niektorej z tried odvodených od robota. Je automaticky
				 * spúšťaná počas kontroly polohy robota v dôsledku aktivácie
				 * funkcie {@linkplain #ohranič(double, double, double,
				 * double, int) ohraničenia} polohy robota pri jeho pohybe.</p>
				 * 
				 * <p>Metóda prijme štvorprvkové pole bodov, ktoré opisuje
				 * situáciu v čase kolízie robota s niektorou z hraníc
				 * ohraničenia. Prvý bod poľa obsahuje súradnice robota pred
				 * začatím pohybu, druhý cieľové súradnice, na ktoré bude robot
				 * presunutý, ak táto metóda dovolí ďalšie spracovanie
				 * ohraničenia (návratovou hodnotou) a ďalšie dva body
				 * vymedzujú úsečku tej hranice ohraničenia, na ktorú robot
				 * narazil. Aktuálna poloha robota je presne tá, ktorá je mimo
				 * hraníc.</p>
				 * 
				 * <p>Posledný parameter určuje orientáciu robota pred
				 * začatím pohybu (ak sa robot nepohyboval po oblúku, mala
				 * by byť zhodná s aktuálnou orientáciou robota).</p>
				 * 
				 * <p>Návratová hodnota tejto reakcie určí, či má spracovanie
				 * pokračovať vnútorným mechanizmom triedy {@link GRobot
				 * GRobot}. Ak autor prekrytia určí, že nie (návratovou
				 * hodnotou {@code valfalse}), tak cieľové hodnoty nebudú
				 * nastavené.</p>
				 * 
				 * <p class="remark"><b>Poznámka:</b> Pole bodov je opisné
				 * a jeho akákoľvek zmena neovplyvní situáciu za hranicami
				 * tejto metódy. To znamená, že úpravy polôh bodov alebo
				 * zámena prvkov poľa nezmenia skutočné hodnoty polôh, ktoré
				 * odzrkadľujú.</p>
				 * 
				 * <p>Keď zapneme spôsob spracovania ohraničenia {@link #ODRAZ
				 * ODRAZ} a chceme, aby sa pri odraze korektne menil smer
				 * robota, môžeme na prepočet použiť nasledujúci kód umiestnený
				 * v rámci reakcie {@code currmimoHraníc}:</p>
				 * 
				 * <pre CLASS="example">
					{@code kwd@}Override {@code kwdpublic} {@code typeboolean} {@code currmimoHraníc}({@link Bod Bod}[] poleBodov, {@code typedouble} uhol)
					{
						{@link Bod Bod} priesečník = {@link Svet Svet}.{@link Svet#priesečníkÚsečiek(Poloha, Poloha, Poloha, Poloha) priesečníkÚsečiek}(poleBodov[{@code num0}],
							{@link GRobot#poloha() poloha}(), poleBodov[{@code num2}], poleBodov[{@code num3}]);
						{@code kwdif} ({@code valnull} != priesečník)
							{@link GRobot#smer(double) smer}({@link Svet Svet}.{@link Svet#smer(Poloha, Poloha) smer}(priesečník, poleBodov[{@code num1}]));
						{@code kwdreturn} {@code valtrue};
					}
					</pre>
				 * 
				 * <p><image>odraz-mimo-hranic.svg<alt/>Znázornenie
				 * situácie.<onerror>odraz-mimo-hranic.png</onerror></image>Grafické
				 * znázornenie situácie.</p>
				 * 
				 * 
				 * <p><b>Príklad:</b></p>
				 * 
				 * <p>Tento príklad je implementáciou jednoduchej zábavky.
				 * Oplotené roboty sú naprogramovaní tak, aby sa každý z nich
				 * pohyboval vo svojom vymedzenom priestore. Roboty reagujú na
				 * kliknutie myšou, ale vždy len jeden z nich – ten, ktorý
				 * je takzvane dotknutý. Ak aktuálne dotknutý robot narazí
				 * na hranice svojho ohraničenia, posunie stav dotknutia
				 * nasledujúcemu robotu v poradí.</p>
				 * 
				 * <pre CLASS="example">
					{@code kwdimport} knižnica.*;

					{@code kwdpublic} {@code typeclass} OplotenéRoboty {@code kwdextends} {@link GRobot GRobot}
					{
						{@code comm// Statická premenná slúžiaca na detekciu kolízií priestorov ohraničenia}
						{@code comm// robotov.}
						{@code kwdprivate} {@code kwdstatic} {@code typeboolean} kolíziaPolôh = {@code valfalse};

						{@code comm// Statická premenná počítajúca vytvorené inštancie ohraničených robotov.}
						{@code kwdprivate} {@code kwdstatic} {@code typeint} početRobotov = {@code num0};

						{@code comm// Statická premenná slúžiaca ako ukazovadlo práve dotknutého robota.}
						{@code kwdprivate} {@code kwdstatic} {@code typeint} ukazovadloRobota = {@code num0};

						{@code comm// Inštančná premenná slúžiaca ako príznak dotknutia tohto robota.}
						{@code kwdprivate} {@code typeboolean} dotknutý = {@code valfalse};

						{@code comm// Inštančná premenná slúžiaca na uchovanie indexu (poradia vytvorenia)}
						{@code comm// tohto robota.}
						{@code kwdprivate} {@code typeint} indexRobota;

						{@code comm// Konštruktor – vykoná základné nastavenia tejto inštancie robota.}
						{@code kwdprivate} OplotenéRoboty()
						{
							indexRobota = početRobotov++;
							nájdiPolohu();
							{@link GRobot#ohranič(double, double, int) ohranič}({@code num100}, {@code num50}, {@link GRobot#ODRAZ ODRAZ});
							{@link GRobot#obdĺžnik(double, double) obdĺžnik}({@code num100}, {@code num50});
							{@link GRobot#maximálnaRýchlosť(double) maximálnaRýchlosť}({@code num50});
							{@link GRobot#zrýchlenie(double, boolean) zrýchlenie}({@code num1.25}, {@code valfalse});
							{@link GRobot#zdvihniPero() zdvihniPero}();
						}

						{@code comm// Vyhľadá polohu, ktorá nekoliduje so žiadnym vytvoreným robotom.}
						{@code kwdprivate} {@code typevoid} nájdiPolohu()
						{
							{@link GRobot#farba(Color) farba}({@link Farebnosť#šedá šedá});
							{@code kwddo}
							{
								kolíziaPolôh = {@code valfalse};

								{@code comm// Zvolenie náhodnej polohy robota:}
								{@link GRobot#domov(double, double) domov}(
									{@link Svet Svet}.{@link Svet#náhodnéReálneČíslo(double, double) náhodnéReálneČíslo}(
										{@link Svet Svet}.{@link Svet#najmenšieX() najmenšieX}() + {@code num110},
										{@link Svet Svet}.{@link Svet#najväčšieX() najväčšieX}() &#45; {@code num110}),
									{@link Svet Svet}.{@link Svet#náhodnéReálneČíslo(double, double) náhodnéReálneČíslo}(
										{@link Svet Svet}.{@link Svet#najmenšieY() najmenšieY}() + {@code num60},
										{@link Svet Svet}.{@link Svet#najväčšieY() najväčšieY}() &#45; {@code num60}));

								{@code comm// Nakreslenie šedého obdĺžnika:}
								{@link GRobot#obdĺžnik(double, double) obdĺžnik}({@code num100}, {@code num50});

								{@code comm// Overenie kolízií:}
								{@link GRobot#vyzviRoboty(int) vyzviRoboty}(-{@code num2});
							}
							{@code kwdwhile} (kolíziaPolôh);
							{@link GRobot#farba(Color) farba}({@link Farebnosť#modrá modrá});
						}

						{@code comm// Viacúčelová reakcia na hromadnú výzvu vytvorených robotov.}
						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#prijatieVýzvy(GRobot, int) prijatieVýzvy}({@link GRobot GRobot} autor, {@code typeint} kľúč)
						{
							{@code comm// Kladné kľúče slúžia na dotknutie požadovaného robota.}
							{@code kwdif} ({@code num0} &lt;= kľúč)
							{
								dotknutý = indexRobota == kľúč % početRobotov;
								{@code kwdif} (dotknutý) {@link GRobot#farba(Color) farba}({@link Farebnosť#tyrkysová tyrkysová});
								{@code kwdelse} {@link GRobot#farba(Color) farba}({@link Farebnosť#oranžová oranžová});
							}
							{@code comm// Kľúč −2 je rezervovaný na hľadanie kolízií priestorov ohraničenia}
							{@code comm// robotov.}
							{@code kwdelse} {@code kwdif} (-{@code num2} == kľúč)
							{
								{@code kwdif} ({@code valthis} != autor)
								{
									{@code kwdif} ({@link GRobot#bodVObdĺžniku(Poloha, double, double) bodVObdĺžniku}(autor, {@code num210}, {@code num110}))
									{
										{@link GRobot#farba(Color) farba}({@link Farebnosť#červená červená});
										{@link GRobot#krúžok() krúžok}();
										kolíziaPolôh = {@code valtrue};
									}
									{@code kwdelse}
									{
										{@link GRobot#farba(Color) farba}({@link Farebnosť#zelená zelená});
										{@link GRobot#krúžok() krúžok}();
									}
								}
							}
							{@code comm// Kľúč −3 je rezervovaný na vyplnenie priestoru ohraničenia tohto robota.}
							{@code kwdelse} {@code kwdif} (-{@code num3} == kľúč)
							{
								{@link GRobot#domov() domov}();
								{@link GRobot#farba(Color) farba}({@link Farebnosť#biela biela});
								{@link GRobot#vyplňObdĺžnik(double, double) vyplňObdĺžnik}({@code num100}, {@code num50});
							}
							{@code comm// Kľúč −2 je rezervovaný na nakreslenie orámovania priestoru ohraničenia}
							{@code comm// tohto robota.}
							{@code kwdelse} {@code kwdif} (-{@code num4} == kľúč)
							{
								{@link GRobot#domov() domov}();
								{@link GRobot#farba(Color) farba}({@link Farebnosť#čierna čierna});
								{@link GRobot#kresliObdĺžnik(double, double) kresliObdĺžnik}({@code num100}, {@code num50});
							}
						}

						{@code comm// Na kliknutie zareaguje len dotknutý robot a to stanovením nového cieľa}
						{@code comm// pohybu podľa polohy myši v čase kliknutia.}
						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#klik() klik}()
						{
							{@code kwdif} (dotknutý) {@link GRobot#cieľNaMyš() cieľNaMyš}();
						}

						{@code comm// Reakcia na narazenie na hranice ohraničenia robota. Tento robot dokončí}
						{@code comm// svoj pohyb a s pomocou mechanizmu výzvy bude dotknutý ďalší robot v poradí.}
						{@code kwd@}Override {@code kwdpublic} {@code typeboolean} {@code currmimoHraníc}({@link Bod Bod}[] poleBodov, {@code typedouble} uhol)
						{
							{@link Bod Bod} poloha = {@link GRobot#poloha() poloha}();
							{@link Bod Bod} cieľ = poleBodov[{@code num1}];
							{@link Svet Svet}.{@link Svet#vyzviRoboty(int) vyzviRoboty}(++ukazovadloRobota);
							poleBodov[{@code num1}] = poloha;

							{@link Bod Bod} priesečník = {@link Svet Svet}.{@link Svet#priesečníkPriamok(Poloha[]) priesečníkPriamok}(poleBodov);
							{@code kwdif} ({@code valnull} != priesečník)
							{
								{@link GRobot#skočNa(Poloha) skočNa}(priesečník);
								{@link GRobot#otočNa(Poloha) otočNa}(cieľ);
								{@link GRobot#zrušCieľ(boolean) zrušCieľ}({@code valfalse});
								{@link GRobot#zabrzdi() zabrzdi}();
								{@code kwdreturn} {@code valfalse};
							}

							{@code kwdreturn} {@code valtrue};
						}

						{@code comm// Hlavná metóda – vstupný bod aplikácie.}
						{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}... args)
						{
							{@link Svet Svet}.{@link Svet#použiKonfiguráciu(String) použiKonfiguráciu}({@code srg"OplotenéRoboty.cfg"});

							{@code comm// Vytvorenie niekoľkých ohraničených robotov. Každý robot si nájde}
							{@code comm// unikátnu polohu, ktorá nekoliduje s ostatnými robotmi. (Ak by bolo}
							{@code comm// robotov príliš veľa, aplikácia sa z tohto cyklu nikdy nevymaní.)}
							{@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; {@code num7}; ++i) {@code kwdnew} OplotenéRoboty();

							{@code comm// Zbalenie a vystredenie sveta pri prvom spustení aplikácie.}
							{@code kwdif} ({@link Svet Svet}.{@link Svet#prvéSpustenie() prvéSpustenie}())
							{
								{@link Svet Svet}.{@link Svet#zbaľ() zbaľ}();
								{@link Svet Svet}.{@link Svet#vystreď() vystreď}();
							}

							{@code comm// Vymazanie priebehu hľadania unikátnych polôh robotov, nakreslenie}
							{@code comm// priestoru ohraničenia pre každý robot a dotknutie prvého robota}
							{@code comm// v poradí.}
							{@link Plátno podlaha}.{@link Plátno#vymažGrafiku() vymažGrafiku}();
							{@link Svet Svet}.{@link Svet#farbaPozadia(Color) farbaPozadia}({@link Farebnosť#šedá šedá});
							{@link Svet Svet}.{@link Svet#vyzviRoboty(int) vyzviRoboty}(-{@code num3});
							{@link Svet Svet}.{@link Svet#vyzviRoboty(int) vyzviRoboty}(-{@code num4});
							{@link Svet Svet}.{@link Svet#vyzviRoboty(int) vyzviRoboty}(ukazovadloRobota);
						}
					}
					</pre>
				 * 
				 * <p><b>Výsledok:</b></p>
				 * 
				 * <p><image>ohranicene-roboty.png<alt/>Výrez plochy zábavky
				 * s názvom „oplotené roboty.“</image>Výrez plochy zábavky
				 * s názvom „oplotené roboty.“</p>
				 * 
				 * @param poleBodov pole bodov obsahujúce súradnice bodov,
				 *     ktoré súvisia s kolíziou s niektorou z hraníc
				 *     ohraničenia – podrobnosti sú v opise vyššie
				 * @param uhol uhol (smer) robota pred začatím pohybu
				 * @return {@code valtrue} znamená, že spracovanie má
				 *     pokračovať vnútorným mechanizmom triedy
				 *     {@link GRobot GRobot}
				 */
				public boolean mimoHraníc(Bod[] poleBodov, double uhol)
				{ return true; }

				/** <p><a class="alias"></a> Alias pre {@link #mimoHraníc(Bod[], double) mimoHraníc}.</p> */
				public boolean mimoHranic(Bod[] poleBodov, double uhol)
				{ return true; }

				/**
				 * <p>Táto metóda je predvolene prázdna. Je určená na prekrytie
				 * v niektorej z tried odvodených od robota. Je automaticky
				 * spúšťaná po kontrole polohy robota v dôsledku aktivácie
				 * funkcie {@linkplain #ohranič(double, double, double,
				 * double, int) ohraničenia} polohy robota pri jeho pohybe.</p>
				 * 
				 * <p>Táto metóda slúži na stručné upozornenie na nedávne
				 * prekročenie hraníc robotom. Neposkytuje žiadne doplňujúce
				 * informácie o tom, ako táto udalosť vznikla. Metóda je
				 * zjednodušenou alternatívou metódy {@link #mimoHraníc(Bod[],
				 * double) mimoHraníc(poleBodov, uhol)}, ktorá prijíma
				 * podrobnosti vo svojich parametroch a po ktorej je volaná,
				 * ak to uvedená metóda dovolí.</p>
				 * 
				 * <p>To znamená, že táto metóda je spustená len v prípade,
				 * ak jej podrobnejšia verzia vrátila hodnotu {@code valtrue},
				 * čím povolila ďalšie spracovanie. To tiež znamená, že
				 * v čase spustenia tejto metódy je robot na cieľovom mieste
				 * určenom pravidlami ohraničenia.</p>
				 * 
				 * <!-- Poznámka:
				 * 	Metóda mimoHraníc(Bod[] poleBodov, double uhol) by mohla
				 * 	niesť pomyselné meno „jeMimoHraníc“ a táto metóda (t. j.
				 * 	mimoHraníc()) by zase mohla byť pomyselne pomenovaná
				 * 	„bolMimoHraníc.“
				 * -->
				 */
				public void mimoHraníc() {}

				/** <p><a class="alias"></a> Alias pre {@link #mimoHraníc() mimoHraníc}.</p> */
				public void mimoHranic() {}


			// Metódy obsluhy udalostí na prekrytie

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#tik() tik}{@code ()}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void tik() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#klik() klik}{@code ()}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void klik() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#voľbaPoložkyPonuky()
				 * voľbaPoložkyPonuky}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void voľbaPoložkyPonuky() {}

				/** <p><a class="alias"></a> Alias pre {@link #voľbaPoložkyPonuky() voľbaPoložkyPonuky}.</p> */
				public void volbaPolozkyPonuky() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#voľbaKontextovejPoložky()
				 * voľbaKontextovejPoložky}{@code ()}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void voľbaKontextovejPoložky() {}

				/** <p><a class="alias"></a> Alias pre {@link #voľbaKontextovejPoložky() voľbaKontextovejPoložky}.</p> */
				public void volbaKontextovejPolozky() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#voľbaTlačidla() voľbaTlačidla}{@code ()},
				 * ktorá je historicky staršia (preto mohla nájsť širšie
				 * použitie).</p>
				 */
				public void voľbaTlačidla() {}

				/** <p><a class="alias"></a> Alias pre {@link #voľbaTlačidla() voľbaTlačidla}.</p> */
				public void volbaTlacidla() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zmenaPosunuLišty()
				 * zmenaPosunuLišty}{@code ()}.</p>
				 */
				public void zmenaPosunuLišty() {}

				/** <p><a class="alias"></a> Alias pre {@link #zmenaPosunuLišty() zmenaPosunuLišty}.</p> */
				public void zmenaPosunuListy() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#voľbaSystémovejIkony()
				 * voľbaSystémovejIkony}{@code ()}.</p>
				 */
				public void voľbaSystémovejIkony() {}

				/** <p><a class="alias"></a> Alias pre {@link #voľbaSystémovejIkony() voľbaSystémovejIkony}.</p> */
				public void volbaSystemovejIkony() {}


				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#voľbaSystémovejPoložky()
				 * voľbaSystémovejPoložky}{@code ()}.</p>
				 */
				public void voľbaSystémovejPoložky() {}

				/** <p><a class="alias"></a> Alias pre {@link #voľbaSystémovejPoložky() voľbaSystémovejPoložky}.</p> */
				public void volbaSystemovejPolozky() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#vymazanie()
				 * vymazanie}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void vymazanie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#prekreslenie()
				 * prekreslenie}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void prekreslenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#dokreslenie() dokreslenie}{@code ()}, ktorá
				 * je historicky staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void dokreslenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zobrazenieOkna()
				 * zobrazenieOkna}{@code ()}.</p>
				 */
				public void zobrazenieOkna() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#skrytieOkna() skrytieOkna}{@code ()}.</p>
				 */
				public void skrytieOkna() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#presunutieOkna() presunutieOkna}{@code ()},
				 * ktorá je historicky staršia (preto mohla nájsť širšie
				 * použitie).</p>
				 */
				public void presunutieOkna() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zmenaVeľkostiOkna()
				 * zmenaVeľkostiOkna}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void zmenaVeľkostiOkna() {}

				/** <p><a class="alias"></a> Alias pre {@link #zmenaVeľkostiOkna() zmenaVeľkostiOkna}.</p> */
				public void zmenaVelkostiOkna() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#aktiváciaOkna() aktiváciaOkna}{@code ()},
				 * ktorá je historicky staršia (preto mohla nájsť širšie
				 * použitie).</p>
				 */
				public void aktiváciaOkna() {}

				/** <p><a class="alias"></a> Alias pre {@link #aktiváciaOkna() aktiváciaOkna}.</p> */
				public void aktivaciaOkna() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#deaktiváciaOkna() deaktiváciaOkna}{@code ()},
				 * ktorá je historicky staršia (preto mohla nájsť širšie
				 * použitie).</p>
				 */
				public void deaktiváciaOkna() {}

				/** <p><a class="alias"></a> Alias pre {@link #deaktiváciaOkna() deaktiváciaOkna}.</p> */
				public void deaktivaciaOkna() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#maximalizovanie()
				 * maximalizovanie}{@code ()}.</p>
				 */
				public void maximalizovanie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#minimalizovanie()
				 * minimalizovanie}{@code ()}.</p>
				 */
				public void minimalizovanie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#obnovenie()
				 * obnovenie}{@code ()}.</p>
				 */
				public void obnovenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link ObsluhaUdalostí#otvorenie()
				 * otvorenie}{@code ()}.</p>
				 */
				public void otvorenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link ObsluhaUdalostí#zavretie()
				 * zavretie}{@code ()}.</p>
				 */
				public boolean zavretie() { return true; }

				/** <p><a class="alias"></a> Alias pre {@link #zavretie() zavretie}.</p> */
				public boolean zatvorenie() { return true; }

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link ObsluhaUdalostí#ukončenie()
				 * ukončenie}{@code ()}, ktorá je historicky staršia (preto
				 * mohla nájsť širšie použitie).</p>
				 * 
				 * <p>Priorita spúšťania tejto obsluhy udalosti v prekrytých
				 * metódach robota a v obsluhe udalostí je upravená tak, aby
				 * bola udalosť v obsluhe udalostí spustená pred automatickým
				 * uložením konfigurácie a udalosti v robotoch po ňom.</p>
				 */
				public void ukončenie() {}

				/** <p><a class="alias"></a> Alias pre {@link #ukončenie() ukončenie}.</p> */
				public void ukoncenie() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#potvrdenieÚdajov()
				 * potvrdenieÚdajov}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void potvrdenieÚdajov() {}

				/** <p><a class="alias"></a> Alias pre {@link #potvrdenieÚdajov() potvrdenieÚdajov}.</p> */
				public void potvrdenieUdajov() {}

				/** <p><a class="alias"></a> Alias pre {@link #potvrdenieÚdajov() potvrdenieÚdajov}.</p> */
				public void potvrdenieVstupu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#spracovaniePríkazu()
				 * spracovaniePríkazu}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void spracovaniePríkazu() {}

				/** <p><a class="alias"></a> Alias pre {@link #spracovaniePríkazu() spracovaniePríkazu}.</p> */
				public void spracovaniePrikazu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zrušenieÚdajov() zrušenieÚdajov}{@code ()},
				 * ktorá je historicky staršia (preto mohla nájsť širšie
				 * použitie).</p>
				 */
				public void zrušenieÚdajov() {}

				/** <p><a class="alias"></a> Alias pre {@link #zrušenieÚdajov() zrušenieÚdajov}.</p> */
				public void zrusenieUdajov() {}

				/** <p><a class="alias"></a> Alias pre {@link #zrušenieÚdajov() zrušenieÚdajov}.</p> */
				public void zrušenieVstupu() {}

				/** <p><a class="alias"></a> Alias pre {@link #zrušenieÚdajov() zrušenieÚdajov}.</p> */
				public void zrusenieVstupu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania rovnomennej metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#spracujRiadokVstupu(String)
				 * spracujRiadokVstupu}{@code (riadokVstupu)}.</p>
				 * 
				 * @param riadokVstupu riadok údajov prijatých zo
				 *     štandardného vstupu – pozri aj metódu {@link 
				 *     Svet#aktivujŠtandardnýVstup()}
				 */
				public void spracujRiadokVstupu(String riadokVstupu) {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania rovnomennej metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#koniecVstupu() koniecVstupu}{@code ()}.</p>
				 */
				public void koniecVstupu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom
				 * fungovania rovnomennej metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#vzniklaChyba(GRobotException.Chyba)
				 * vzniklaChyba}{@code (chyba)}.</p>
				 */
				public void vzniklaChyba(GRobotException.Chyba chyba) {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#stlačenieTlačidlaMyši()
				 * stlačenieTlačidlaMyši}{@code ()}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void stlačenieTlačidlaMyši() {}

				/** <p><a class="alias"></a> Alias pre {@link #stlačenieTlačidlaMyši() stlačenieTlačidlaMyši}.</p> */
				public void stlacenieTlacidlaMysi() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#uvoľnenieTlačidlaMyši()
				 * uvoľnenieTlačidlaMyši}{@code ()}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void uvoľnenieTlačidlaMyši() {}

				/** <p><a class="alias"></a> Alias pre {@link #uvoľnenieTlačidlaMyši() uvoľnenieTlačidlaMyši}.</p> */
				public void uvolnenieTlacidlaMysi() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#pohybMyši() pohybMyši}{@code ()}, ktorá je
				 * historicky staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void pohybMyši() {}

				/** <p><a class="alias"></a> Alias pre {@link #pohybMyši() pohybMyši}.</p> */
				public void pohybMysi() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#ťahanieMyšou() ťahanieMyšou}{@code ()}, ktorá
				 * je historicky staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void ťahanieMyšou() {}

				/** <p><a class="alias"></a> Alias pre {@link #ťahanieMyšou() ťahanieMyšou}.</p> */
				public void tahanieMysou() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#rolovanieKolieskomMyši()
				 * rolovanieKolieskomMyši}{@code ()}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void rolovanieKolieskomMyši() {}

				/** <p><a class="alias"></a> Alias pre {@link #rolovanieKolieskomMyši() rolovanieKolieskomMyši}.</p> */
				public void rolovanieKolieskomMysi() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code 
				 * .}{@link ObsluhaUdalostí#stlačenieKlávesu()
				 * stlačenieKlávesu}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void stlačenieKlávesu() {}

				/** <p><a class="alias"></a> Alias pre {@link #stlačenieKlávesu() stlačenieKlávesu}.</p> */
				public void stlacenieKlavesu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code 
				 * .}{@link ObsluhaUdalostí#uvoľnenieKlávesu()
				 * uvoľnenieKlávesu}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 */
				public void uvoľnenieKlávesu() {}

				/** <p><a class="alias"></a> Alias pre {@link #uvoľnenieKlávesu() uvoľnenieKlávesu}.</p> */
				public void uvolnenieKlavesu() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zadanieZnaku() zadanieZnaku}{@code ()}, ktorá
				 * je historicky staršia (preto mohla nájsť širšie použitie).</p>
				 */
				public void zadanieZnaku() {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#klávesováSkratka()
				 * klávesováSkratka}{@code ()}.</p>
				 */
				public void klávesováSkratka() {}

				/** <p><a class="alias"></a> Alias pre {@link #klávesováSkratka() klávesováSkratka}.</p> */
				public void klavesovaSkratka() {}


				/* *
				 * <p>Táto metóda je predvolene prázdna, je vyhradená na
				 * prekrytie v triede {@linkplain Svet#hlavnýRobot() hlavného
				 * robota} a jej prekrytie nemá význam pri ostatných robotoch.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#povoliťPustenieSúboru()
				 * povoliťPustenieSúboru}{@code ()}.</p>
				 * 
				 * @return {@code valtrue} ak má byť pustenie súboru povolené,
				 *     inak {@code valfalse}
				 * /
				public boolean povoliťPustenieSúboru() { return false; }

				/** <p><a class="alias"></a> Alias pre {@link #povoliťPustenieSúboru() povoliťPustenieSúboru}.</p> * /
				public boolean povolitPustenieSuboru() { return false; }*/



				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#ťahanieSúborov() ťahanieSúborov}{@code ()}.</p>
				 */
				public void ťahanieSúborov() {}

				/** <p><a class="alias"></a> Alias pre {@link #ťahanieSúborov() ťahanieSúborov}.</p> */
				public void tahanieSuborov() {}


				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#pustenieSúboru(String)
				 * pustenieSúboru}{@code ()}.</p>
				 * 
				 * @param súbor úplná cesta a meno súboru
				 */
				public void pustenieSúboru(String súbor) {}

				/** <p><a class="alias"></a> Alias pre {@link #pustenieSúboru(String) pustenieSúboru}.</p> */
				public void pustenieSuboru(String súbor) {}


				/**
				 * <p>Táto metóda je predvolene prázdna, resp. predvolene vracia
				 * hodnotu {@code valnull}. Je určená na prekrytie v niektorej
				 * z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#farbaAktívnehoSlova(String)
				 * farbaAktívnehoSlova}{@code ()}.</p>
				 * 
				 * @param slovo identifikátor aktívneho slova vnútornej konzoly
				 * @return nová farba aktívneho slova alebo {@code valnull}
				 * 
				 * @see Plátno#vypíšAktívneSlovo(String, Object[])
				 */
				public Color farbaAktívnehoSlova(String slovo) { return null; }

				/** <p><a class="alias"></a> Alias pre {@link #farbaAktívnehoSlova(String) farbaAktívnehoSlova}.</p> */
				public Color farbaAktivnehoSlova(String slovo) { return null; }


				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#aktiváciaOdkazu() aktiváciaOdkazu}{@code ()},
				 * ktorá je historicky staršia (preto mohla nájsť širšie
				 * použitie).</p>
				 */
				public void aktiváciaOdkazu() {}

				/** <p><a class="alias"></a> Alias pre {@link #aktiváciaOdkazu() aktiváciaOdkazu}.</p> */
				public void aktivaciaOdkazu() {}


				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#konfiguráciaZmenená()
				 * konfiguráciaZmenená}{@code ()}, ktorá je historicky staršia
				 * (preto mohla nájsť širšie použitie).</p>
				 * 
				 * <p class="attention"><b>Upozornenie:</b> Pri prekrývaní
				 * tejto reakcie majte na pamäti, že nie je garantované jej
				 * automatické vykonanie pri ukončovaní aplikácie (ak vyššia
				 * vrstva zistí, že konfigurácia bola zmenená, tak ďalej
				 * nevyšetruje, či ju treba, alebo netreba ukladať
				 * a automaticky pristúpi k procesu uloženia konfigurácie).
				 * Vložte do do tela tejto reakcie len taký kód, ktorý rýchlo
				 * overí, či nastali nejaké zmeny v konfigurácii, ktoré
				 * treba uložiť a vráti túto informáciu vyššej vrstve.</p>
				 *
				 * @see Svet#použiKonfiguráciu()
				 */
				public boolean konfiguráciaZmenená() { return false; }

				/** <p><a class="alias"></a> Alias pre {@link #konfiguráciaZmenená() konfiguráciaZmenená}.</p> */
				public boolean konfiguraciaZmenena() { return false; }

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#čítajKonfiguráciu(Súbor)
				 * čítajKonfiguráciu}{@code (súbor)}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 * 
				 * @param súbor inštancia triedy {@link Súbor Súbor}
				 *     reprezentujúca otvorený konfiguračný súbor pripravený
				 *     na čítanie údajov
				 * 
				 * @exception IOException ak vznikla chyba vo
				 *     vstupno-výstupnej operácii
				 */
				public void čítajKonfiguráciu(Súbor súbor) throws IOException {}

				/** <p><a class="alias"></a> Alias pre {@link #čítajKonfiguráciu(Súbor) čítajKonfiguráciu}.</p> */
				public void citajKonfiguraciu(Súbor subor) throws IOException {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je totožný s opisom fungovania
				 * metódy {@link ObsluhaUdalostí ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zapíšKonfiguráciu(Súbor)
				 * zapíšKonfiguráciu}{@code (súbor)}, ktorá je historicky
				 * staršia (preto mohla nájsť širšie použitie).</p>
				 * 
				 * @param súbor inštancia triedy {@link Súbor Súbor}
				 *     reprezentujúca otvorený konfiguračný súbor pripravený
				 *     na zápis údajov
				 * 
				 * @exception IOException ak vznikla chyba vo
				 *     vstupno-výstupnej operácii
				 */
				public void zapíšKonfiguráciu(Súbor súbor) throws IOException {}

				/** <p><a class="alias"></a> Alias pre {@link #zapíšKonfiguráciu(Súbor) zapíšKonfiguráciu}.</p> */
				public void zapisKonfiguraciu(Súbor subor) throws IOException {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.
				 * <!--   -->
				 * V podstate je reakciou na udalosť, ktorá súvisí s časovo
				 * náročným spracovaním údajov počas práce s pevným diskom
				 * (pozri aj {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#sekvencia(int, Object, Object, long, long)
				 * sekvencia}{@code (kódSpracovania, zdroj, cieľ, stav,
				 * celkovo)}), napríklad s {@link Obrázok#čítaj(String)
				 * čítaním} a {@link Obrázok#ulož(String, boolean) zápisom}
				 * sekvencie PNG súborov (pozri triedu {@link Obrázok Obrázok}
				 * a jej metódy {@link Obrázok#čítaj(String) čítaj(súbor)}
				 * a {@link Obrázok#ulož(String, boolean) ulož(súbor,
				 * prepísať)}) alebo {@linkplain Súbor#kopíruj(String, String)
				 * kopírovaním súborov} a podobne. Typ udalosti, ktorá
				 * spôsobila spustenie tejto reakcie je určený prvým
				 * parametrom – {@code kódSpracovania}. Ostatné parametre sú
				 * naplnené podľa ich relevantnosti.</p>
				 * 
				 * @param kódSpracovania obsahuje kód činnosti, ktorá
				 *     spôsobila vznik tejto udalosti; aktuálne platné kódy
				 *     sú: {@link #ČÍTANIE_PNG_SEKVENCIE
				 *     ČÍTANIE_PNG_SEKVENCIE},
				 *     {@link #CHYBA_ČÍTANIA_PNG_SEKVENCIE
				 *     CHYBA_ČÍTANIA_PNG_SEKVENCIE},
				 *     {@link #ZÁPIS_PNG_SEKVENCIE ZÁPIS_PNG_SEKVENCIE},
				 *     {@link #ČÍTANIE_GIF_ANIMÁCIE ČÍTANIE_GIF_ANIMÁCIE},
				 *     {@link #ZÁPIS_GIF_ANIMÁCIE ZÁPIS_GIF_ANIMÁCIE},
				 *     {@link #KOPÍROVANIE_SÚBOROV KOPÍROVANIE_SÚBOROV}
				 *     {@link #PRIPÁJANIE_SÚBOROV PRIPÁJANIE_SÚBOROV},
				 *     {@link #POROVNANIE_SÚBOROV POROVNANIE_SÚBOROV},
				 *     {@link #ODOVZDANIE_ÚDAJOV ODOVZDANIE_ÚDAJOV}
				 *     a {@link #PREVZATIE_ÚDAJOV PREVZATIE_ÚDAJOV}
				 * @param zdroj objekt súvisiaci so zdrojom alebo {@code 
				 *     valnull}; napríklad v prípade kopírovania súborov
				 *     je to {@linkplain String reťazec} s názvom zdrojového
				 *     súboru, v prípade zápisu PNG sekvencie je to
				 *     {@linkplain BufferedImage obrázkový objekt} so
				 *     zdrojovou snímkou animácie a podobne
				 * @param cieľ objekt súvisiaci s cieľom alebo {@code 
				 *     valnull}; napríklad pri kopírovaní súborov je to
				 *     {@linkplain String reťazec} s názvom cieľového súboru;
				 *     v prípade čítania PNG sekvencie je to {@linkplain 
				 *     BufferedImage obrázkový objekt} s cieľovou snímkou
				 *     animácie (čiže tou, do ktorej sú ukladané prečítané
				 *     údaje) a podobne
				 * @param stav hodnota vyjadrujúca aktuálne spracovaný objem
				 *     údajov alebo {@code num-1}, ak táto hodnota nie je
				 *     známa alebo je irelevantná; môže to byť počet
				 *     spracovaných bajtov, poradové číslo snímky a podobne
				 * @param celkovo hodnota vyjadrujúca celkový objem údajov,
				 *     ktorý má byť spracovaný alebo {@code num-1}, ak táto
				 *     hodnota nie je známa alebo je irelevantná; môže to byť
				 *     veľkosť súboru, celkový počet snímok a podobne
				 */
				public void sekvencia(int kódSpracovania, Object zdroj,
					Object cieľ, long stav, long celkovo) {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je úplne totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#zastavenieAnimácie(Obrázok)
				 * zastavenieAnimácie}{@code (súbor)}. V skratke – reakcia
				 * je spustená pri zastavení prehrávania animácie obrázka,
				 * čo môže byť iniciované automaticky (pozri aj metódu
				 * obrázka {@link Obrázok#zastav() zastav}) alebo na podnet
				 * používateľa (programátora).</p>
				 * 
				 * @param obrázok inštancia obrázka, ktorého prehrávanie bolo
				 *     zastavené
				 */
				public void zastavenieAnimácie(Obrázok obrázok) {}

				/** <p><a class="alias"></a> Alias pre {@link #zastavenieAnimácie(Obrázok) zastavenieAnimácie}.</p> */
				public void zastavenieAnimacie(Obrázok obrázok) {}

				/**
				 * <p>Táto metóda je predvolene prázdna a je určená na
				 * prekrytie v niektorej z tried odvodených od robota.</p>
				 * 
				 * <p>Opis fungovania tejto metódy je úplne totožný s opisom
				 * fungovania metódy {@link ObsluhaUdalostí
				 * ObsluhaUdalostí}{@code .}{@link 
				 * ObsluhaUdalostí#ukončenieProcesu(Svet.PríkazovýRiadok,
				 * int) ukončenieProcesu}{@code (príkazovýRiadok,
				 * návratovýKód)}. V skratke – reakcia je spustená pri
				 * ukončenú procesu, ktorý spustila inštancia príkazového
				 * riadka.</p>
				 * 
				 * @param príkazovýRiadok inštancia príkazového riadka,
				 *     ktorá proces spustila
				 * @param návratovýKód kód, ktorý vrátil externý proces
				 *     pri ukončení
				 */
				public void ukončenieProcesu(Svet.PríkazovýRiadok
					príkazovýRiadok, int návratovýKód) {}

				/** <p><a class="alias"></a> Alias pre {@link #ukončenieProcesu(Svet.PríkazovýRiadok, int) ukončenieProcesu}.</p> */
				public void ukoncenieProcesu(Svet.PríkazovýRiadok
					príkazovýRiadok, int návratovýKód) {}

		// Pôsobisko

			/**
			 * <p>Vymaže pôsobisko, čo je oblasť obdĺžnika, v rámci ktorého
			 * robot kreslil od posledného vymazania pôsobiska alebo od
			 * posledného použitia niektorej z metód {@link #domov() domov}.
			 * Pôsobisko sa po vymazaní vždy začína rozširovať od aktuálnych
			 * súradníc robota smerom von.</p>
			 * 
			 * @see #domov()
			 * @see #pôsobisko()
			 * @see #pôsobisko(Shape)
			 * @see #pôsobisko(Poloha)
			 * @see #kresliPôsobisko()
			 * @see #kresliPôsobisko(boolean)
			 * @see #nekresliPôsobisko()
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public void vymažPôsobisko()
			{
				minimálneX = maximálneX = aktuálneX;
				minimálneY = maximálneY = aktuálneY;

				// System.out.println("  × " + minimálneX + ", " +
				// 	minimálneY + " – " + maximálneX + ", " + maximálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vymažPôsobisko() vymažPôsobisko}.</p> */
			public void vymazPosobisko() { vymažPôsobisko(); }

			/**
			 * <p>Umožňuje získať tvar (čo zahŕňa jeho rozmery a polohu)
			 * pôsobiska v objekte typu {@link Rectangle2D Rectangle2D}.
			 * Viac informácií o pôsobisku nájdete napríklad v opise metód
			 * {@link #vymažPôsobisko() vymažPôsobisko},
			 * {@link #pôsobisko(Shape) pôsobisko},
			 * {@link #kresliPôsobisko() kresliPôsobisko} a tak ďalej.</p>
			 * 
			 * @return obdĺžnik typu {@link Rectangle2D Rectangle2D}, ktorý
			 *     reprezentuje aktuálne pôsobisko tohto robota
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #pôsobisko(Shape)
			 * @see #pôsobisko(Poloha)
			 * @see #kresliPôsobisko()
			 * @see #kresliPôsobisko(boolean)
			 * @see #nekresliPôsobisko()
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public Rectangle2D pôsobisko()
			{
				return new Rectangle2D.Double(
					Svet.prepočítajX(minimálneX), Svet.prepočítajY(maximálneY),
					maximálneX - minimálneX, maximálneY - minimálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #pôsobisko() pôsobisko}.</p> */
			public Rectangle2D posobisko() { return pôsobisko(); }

			/**
			 * <p>Táto metóda umožňuje rozšíriť pôsobisko (pozri napríklad metódu
			 * {@link #vymažPôsobisko() vymažPôsobisko}) o rozmery zadaného
			 * tvaru. Pôsobisko je vždy automaticky aktualizované počas
			 * kreslenia a pečiatkovania robota, ale v niektorých prípadoch
			 * môže byť užitočné rozšíriť pôsobisko o tvar, ktorý robot priamo
			 * nenakreslil. Napríklad o tvar, ktorý bol nakreslený na plátno
			 * metódou {@link Plátno#kresli(Shape) podlaha.kresli(…)}, čo je
			 * typ kreslenia, za ktoré nie je zodpovedný priamo robot. Pri
			 * kreslení sú len použité jeho vlastnosti, robot je teda iba
			 * využitý ako referencia, nič iné. Preto sa pri tomto type
			 * kreslenia pôsobisko nerozširuje automaticky. Takých metód je
			 * v rámci všetkých tried programovacieho rámca viac.</p>
			 * 
			 * @param tvar tvar, ktorého rozmery budú započítané do pôsobiska
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #pôsobisko()
			 * @see #pôsobisko(Poloha)
			 * @see #kresliPôsobisko()
			 * @see #kresliPôsobisko(boolean)
			 * @see #nekresliPôsobisko()
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public void pôsobisko(Shape tvar)
			{
				aktualizujPôsobisko(tvar.getBounds2D());
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #pôsobisko(Shape) pôsobisko}.</p> */
			public void posobisko(Shape tvar) { pôsobisko(tvar); }

			/**
			 * <p>Táto metóda umožňuje rozšíriť pôsobisko tak, aby obsahovalo
			 * zadaný bod. Pre viac informácií pozri metódu
			 * {@link #pôsobisko(Shape) pôsobisko}.</p>
			 * 
			 * @param bod bod, ktorého súradnice budú započítané do pôsobiska
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #pôsobisko()
			 * @see #pôsobisko(Shape)
			 * @see #kresliPôsobisko()
			 * @see #kresliPôsobisko(boolean)
			 * @see #nekresliPôsobisko()
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public void pôsobisko(Poloha bod)
			{
				aktualizujPôsobisko(bod.polohaX(), bod.polohaY());
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #pôsobisko(Poloha) pôsobisko}.</p> */
			public void posobisko(Poloha bod) { pôsobisko(bod); }

			/**
			 * <p>Zvýrazní oblasť obdĺžnika – pôsobisko, v rámci ktorého robot
			 * kreslil od posledného {@linkplain #vymažPôsobisko() vymazania
			 * pôsobiska} alebo od posledného použitia niektorej
			 * z metód {@link #domov() domov}. Pôsobisko je použiteľné
			 * napríklad s metódami {@link #myšVPôsobisku() myšVPôsobisku}
			 * alebo {@link #bodVPôsobisku(double, double) bodVPôsobisku}.</p>
			 * 
			 * <p>Pôsobisko je rozširované dynamicky – pri každom kreslení
			 * aktuálnym robotom, sú porovnané hranice pôsobiska so
			 * súradnicami a rozmermi kresleného útvaru a podľa nich je
			 * upravená aktuálna veľkosť pôsobiska. Pôsobisko je možné vymazať
			 * buď volaním metódy {@link #vymažPôsobisko() vymažPôsobisko},
			 * alebo použitím niektorej z metód {@link #domov() domov}.</p>
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #pôsobisko()
			 * @see #pôsobisko(Shape)
			 * @see #pôsobisko(Poloha)
			 * @see #kresliPôsobisko(boolean)
			 * @see #nekresliPôsobisko()
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public void kresliPôsobisko()
			{
				kresliPôsobisko = true;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliPôsobisko() kresliPôsobisko}.</p> */
			public void kresliPosobisko() { kresliPôsobisko(); }

			/**
			 * <p>Zapne alebo vypne kreslenie tzv. pôsobiska – oblasti, v rámci
			 * ktorej robot kreslil od posledného
			 * {@linkplain #vymažPôsobisko() vymazania pôsobiska} alebo od
			 * posledného použitia niektorej z metód {@link #domov() domov}.
			 * Na zíkanie ďalších informácií pozri metódy
			 * {@link #kresliPôsobisko() nekresliPôsobisko},
			 * {@link #nekresliPôsobisko() kresliPôsobisko} atď.</p>
			 * 
			 * @param ánoNie ak je zadaná hodnota {@code valtrue}, kreslenie
			 *     (zvýrazňovanie) pôsobiska bude zapnuté, inak bude vypnuté
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #pôsobisko()
			 * @see #pôsobisko(Shape)
			 * @see #pôsobisko(Poloha)
			 * @see #kresliPôsobisko()
			 * @see #nekresliPôsobisko()
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public void kresliPôsobisko(boolean ánoNie)
			{
				kresliPôsobisko = ánoNie;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliPôsobisko(boolean) kresliPôsobisko}.</p> */
			public void kresliPosobisko(boolean ánoNie)
			{ kresliPôsobisko(ánoNie); }

			/**
			 * <p>Skryje zvýraznenie oblasti pôsobiska, ktoré bolo zapnuté
			 * metódou {@link #kresliPôsobisko() kresliPôsobisko}.</p>
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #pôsobisko()
			 * @see #pôsobisko(Shape)
			 * @see #pôsobisko(Poloha)
			 * @see #kresliPôsobisko()
			 * @see #kresliPôsobisko(boolean)
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #myšVPôsobisku()
			 */
			public void nekresliPôsobisko()
			{
				kresliPôsobisko = false;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #nekresliPôsobisko() nekresliPôsobisko}.</p> */
			public void nekresliPosobisko() { nekresliPôsobisko(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice zadaného bodu nachádzajú
			 * v oblasti obdĺžnika, v rámci ktorého bolo zaznamenané
			 * kreslenie aktuálnym robotom. Tento obdĺžnik nazývame
			 * pôsobisko. Nasledujúca metóda dovoľuje namiesto súradníc bodu
			 * použiť objekt:
			 * {@link #bodVPôsobisku(Poloha) bodVPôsobisku(Poloha
			 * objekt)}.</p>
			 * 
			 * <p>Pôsobisko je rozširované dynamicky – pri každom kreslení
			 * aktuálnym robotom, sú porovnané hranice pôsobiska so
			 * súradnicami a rozmermi kresleného útvaru a podľa nich je
			 * upravená aktuálna veľkosť pôsobiska. Pri použití niektorej
			 * z metód {@link #domov() domov}, je pôsobisko zmenšené na
			 * nulu.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #kresliPôsobisko()
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVPôsobisku(double súradnicaBoduX, double súradnicaBoduY)
			{
				return ((súradnicaBoduX >= minimálneX) && (súradnicaBoduX <= maximálneX) &&
					(súradnicaBoduY >= minimálneY) && (súradnicaBoduY <= maximálneY));
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVPôsobisku(double, double) bodVPôsobisku}.</p> */
			public boolean bodVPosobisku(double súradnicaBoduX, double súradnicaBoduY)
			{ return bodVPôsobisku(súradnicaBoduX, súradnicaBoduY); }

			// /**
				//  * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v oblasti
				//  * obdĺžnika, v rámci ktorého bolo zaznamenané kreslenie
				//  * aktuálnym robotom. Tento obdĺžnik nazývame pôsobisko.</p>
				//  * 
				//  * <p>Pôsobisko je rozširované dynamicky – pri každom kreslení
				//  * aktuálnym robotom, sú porovnané hranice pôsobiska so
				//  * súradnicami a rozmermi kresleného útvaru a podľa nich je
				//  * upravená aktuálna veľkosť pôsobiska. Pri použití niektorej
				//  * z metód {@link #domov() domov}, je pôsobisko zmenšené na
				//  * nulu.</p>
				//  * 
				//  * @param bod súradnice bodu
				//  * @return {@code valtrue} – áno; {@code valfalse} – nie
				//  * 
				//  * @see #bodVKruhu(Point2D, double)
				//  * @see #bodVElipse(Point2D, double, double)
				//  * @see #bodVoŠtvorci(Point2D, double)
				//  * @see #bodVObdĺžniku(Point2D, double, double)
				//  * @see #bodVCeste(Point2D)
				//  * @see #bodVOblasti(Point2D, Area)
				//  * @see #bodVTvare(Point2D, Shape)
				//  */
				// public boolean bodVPôsobisku(Point2D bod)
				// {
				// 	return ((bod.getX() >= minimálneX) && (bod.getX() <= maximálneX) &&
				// 		(bod.getY() >= minimálneY) && (bod.getY() <= maximálneY));
				// }
				// 
				// /** <p><a class="alias"></a> Alias pre {@link #bodVPôsobisku(Point2D) bodVPôsobisku}.</p> */
				// public boolean bodVPosobisku(Point2D bod)
				// { return bodVPôsobisku(bod); }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVPôsobisku(double,
			 * double) bodVPôsobisku(x, y)}, len namiesto súradníc bodu je
			 * použitá poloha zadaného robota…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #kresliPôsobisko()
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVPôsobisku(Poloha objekt)
			{
				return ((objekt.polohaX() >= minimálneX) &&
					(objekt.polohaX() <= maximálneX) &&
					(objekt.polohaY() >= minimálneY) &&
					(objekt.polohaY() <= maximálneY));
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVPôsobisku(Poloha) bodVPôsobisku}.</p> */
			public boolean bodVPosobisku(Poloha objekt) { return bodVPôsobisku(objekt); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v oblasti
			 * obdĺžnika, v rámci ktorého bolo zaznamenané kreslenie
			 * aktuálnym robotom. Tento obdĺžnik nazývame pôsobisko.</p>
			 * 
			 * <p>Pôsobisko je rozširované dynamicky – pri každom kreslení
			 * aktuálnym robotom, sú porovnané hranice pôsobiska so
			 * súradnicami a rozmermi kresleného útvaru a podľa nich je
			 * upravená aktuálna veľkosť pôsobiska. Pri použití niektorej
			 * z metód {@link #domov() domov}, je pôsobisko zmenšené na
			 * nulu.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #domov()
			 * @see #vymažPôsobisko()
			 * @see #kresliPôsobisko()
			 * @see #myšVCeste()
			 * @see #myšVElipse(double, double)
			 * @see #myšVKruhu(double)
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVHviezde(double)
			 * @see #myšVOblasti(Area)
			 * @see #myšVKruhu()
			 */
			public boolean myšVPôsobisku()
			{
				return ((ÚdajeUdalostí.súradnicaMyšiX >= minimálneX) &&
					(ÚdajeUdalostí.súradnicaMyšiX <= maximálneX) &&
					(ÚdajeUdalostí.súradnicaMyšiY >= minimálneY) &&
					(ÚdajeUdalostí.súradnicaMyšiY <= maximálneY));
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVPôsobisku() myšVPôsobisku}.</p> */
			public boolean mysVPosobisku() { return myšVPôsobisku(); }


		// Ohraničenie

			/**
			 * <p>Táto metóda vracia aktuálny spôsob ohraničenia robota pri jeho
			 * pohybe: {@link #ODRAZ ODRAZ}, {@link #PLOT PLOT}, {@link #PRETOČ
			 * PRETOČ} alebo {@link #ŽIADNE ŽIADNE}. Podrobnosti o ohraničení
			 * sú v opise metódy {@link #ohranič(double, double,
			 * double, double, int) ohranič(vľavo, dole, vpravo, hore,
			 * spôsob)}.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 */
			public int spôsobOhraničenia() { return aktuálneOhraničenie; }

			/** <p><a class="alias"></a> Alias pre {@link #spôsobOhraničenia() spôsobOhraničenia}.</p> */
			public int sposobOhranicenia() { return aktuálneOhraničenie; }

			/**
			 * <p>Táto metóda vráti pole hraníc alebo hodnotu {@code valnull}.
			 * Ak je ohraničenie aktívne, tak táto metóda vracia reálnočíselné
			 * pole s aktuálnymi pevnými hranicami ohraničenia, ktoré boli
			 * vypočítané podľa polohy robota a zadaných vzdialeností pri
			 * {@linkplain #ohranič(double, double, double, double,
			 * int) aktivácii ohraničenia}. Hranice nasledujú v poradí: ľavá,
			 * dolná, pravá a horná. Ak nie je ohraničenie aktívne, tak táto
			 * metóda vracia hodnotu {@code valnull}.</p>
			 * 
			 * @return reálnočíselné pole s aktuálnymi pevnými hranicami
			 *     ohraničenia alebo hodnota {@code valnull}
			 */
			public double[] hraniceOhraničenia()
			{
				if (ŽIADNE == aktuálneOhraničenie) return null;
				return new double[] {ľaváHranica, dolnáHranica,
					praváHranica, hornáHranica};
			}

			/** <p><a class="alias"></a> Alias pre {@link #hraniceOhraničenia() hraniceOhraničenia}.</p> */
			public double[] hraniceOhranicenia() { return hraniceOhraničenia(); }


			/**
			 * <p>Dočasne vypne {@linkplain #ohranič(double, double, double,
			 * double, int) ohraničenie robota,} ak je zapnuté. To znamená,
			 * že volanie tejto metódy nemá zmysel, ak je ohraničenie
			 * vypnuté.</p>
			 * 
			 * @see #ohranič(double, double, double, double, int)
			 * @see #zapniOhraničenie()
			 */
			public void vypniOhraničenie()
			{
				if (ŽIADNE != aktuálneOhraničenie)
				{
					zálohovanéOhraničenie = aktuálneOhraničenie;
					aktuálneOhraničenie = ŽIADNE;
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #vypniOhraničenie() vypniOhraničenie}.</p> */
			public void vypniOhranicenie() { vypniOhraničenie(); }

			/**
			 * <p>Opätovne zapne {@linkplain #ohranič(double, double, double,
			 * double, int) ohraničenie robota,} ak bolo predtým aktívne, ale
			 * bolo vypnuté metódou {@link #vypniOhraničenie()
			 * vypniOhraničenie.} To znamená, že volanie tejto metódy nemá
			 * zmysel buď ak je ohraničenie aktívne, alebo ak nebolo predtým
			 * vypnuté metódou {@link #vypniOhraničenie()
			 * vypniOhraničenie.}</p>
			 * 
			 * @see #ohranič(double, double, double, double, int)
			 * @see #vypniOhraničenie()
			 */
			public void zapniOhraničenie()
			{
				if (ŽIADNE == aktuálneOhraničenie &&
					ŽIADNE != zálohovanéOhraničenie)
				{
					aktuálneOhraničenie = zálohovanéOhraničenie;
					zálohovanéOhraničenie = ŽIADNE;
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #zapniOhraničenie() zapniOhraničenie}.</p> */
			public void zapniOhranicenie() { zapniOhraničenie(); }


			/**
			 * <p>Zapne alebo vypne kontrolu polohy robota počas jeho pohybu
			 * prostredníctvom určenia vzdialenosti štyroch hraníc od aktuálnej
			 * polohy robota a spôsobu ohraničenia. Prvé štyri parametre určujú
			 * vzdialenosti ohraničenia od aktuálnej polohy robota a posledný
			 * parameter určuje spôsob kontroly polohy.</p>
			 * 
			 * <p>Rámec podporuje tri spôsoby kontroly. Všetky tri boli
			 * implementované s dôrazom na výpočtovú jednoduchosť. Dôsledkom
			 * tohto prístupu je to, že každý zo spôsobov garantuje iba
			 * správnosť cieľovej polohy, nie fyzikálnu správnosť trasy, po
			 * ktorej sa do nej robot dostane. V nasledujúcich troch krátkych
			 * sekciách opíšeme, ako jednotlivé spôsoby fungujú.</p>
			 * 
			 * <p> </p>
			 * 
			 * <p><b>{@linkplain #PRETOČ Pretočenie}</b> (predvolený spôsob)</p>
			 * 
			 * <p>Pretočenie je najpriamočiarejší (a zároveň pre iné verzie
			 * tejto metódy predvolený) spôsob obmedzenia priestoru pohybu
			 * robota. Robot sa po prekročení niektorého z okrajov presunie
			 * k protiľahlému okraju (jeho poloha sa pretočí) a pokračuje
			 * v pohybe týmto spôsobom až do zastavenia.</p>
			 * 
			 * <table class="centered">
			 * <tr><td><image>ohranicenie-pretoc-1.png<alt/></image></td>
			 * <td><image>ohranicenie-pretoc-2.png<alt/></image></td></tr>
			 * <tr><td><p class="image">Spôsob pohybu robota pri jednom
			 * pretočení sa – cez jeden okraj ohraničenia<br /><small>(texty
			 * na tomto obrázku vysvetľujú spôsob označenia počiatočnej polohy
			 * robota)</small>.</p></td>
			 * <td><p class="image">Dvojnásobné pretočenie
			 * robota<br /><small>(čiara úplne vpravo je stredná časť jeho
			 * cesty)</small>.</p></td></tr>
			 * </table>
			 * 
			 * <p><b>{@linkplain #PLOT Oplotenie}</b></p>
			 * 
			 * <p>Oplotenie obmedzuje pohyb robota tak, aby jeho cieľová poloha
			 * ležala čo najbližšie k miestu, do ktorého by prišiel, keby jeho
			 * pohyb nebol obmedzovaný. Tento pohyb sa podobá situácii, v ktorej
			 * by postavička reprezentovaná robotom kĺzala po hranách
			 * ohraničenia tak, ako keby jej v pohybe bránil nejaký múr, stena
			 * alebo plot – z čoho je odvodený názov tohto spôsobu obmedzenia
			 * pohybu robota.</p>
			 * 
			 * <table class="centered">
			 * <tr><td><image>ohranicenie-plot-1.png<alt/></image></td>
			 * <td><image>ohranicenie-plot-2.png<alt/></image></td></tr>
			 * <tr><td><p class="image">Kontakt s jednou hranou
			 * ohraničenia.</p></td>
			 * <td><p class="image">Kontakt s dvomi hranami
			 * ohraničenia.</p></td></tr>
			 * </table>
			 * 
			 * <p><b>{@linkplain #ODRAZ Odrazenie}</b></p>
			 * 
			 * <p>Tento spôsob spracovania je ekvivalentný situácii, v ktorej
			 * by sa postavička reprezentovaná robotom odrážala od stien
			 * ohraničenia až do zastavenia. Garantovaná je len cieľová poloha,
			 * nie korektnosť dráhy pohybu. Robot tiež pri odrážaní sa nemení
			 * smer (v zmysle svojej orientácie – aktuálneho uhla pootočenia).</p>
			 * 
			 * <table class="centered">
			 * <tr><td><image>ohranicenie-odraz-1.png<alt/></image></td>
			 * <td><image>ohranicenie-odraz-2.png<alt/></image></td></tr>
			 * <tr><td><p class="image">Odrazenie sa od jedného okraja.</p></td>
			 * <td><p class="image">Viacnásobné odrazenie sa.</p></td></tr>
			 * </table>
			 * 
			 * <p>Keďže priorita pri implementácii (všetkých spôsobov
			 * ohraničenia, nielen tohto) bola kladená na výpočtovú jednoduchosť,
			 * nie je ani pri jednom spôsobe garantované, že zaznamenaná dráha
			 * nebude obsahovať body za hranicami ohraničenia priestoru pohybu
			 * robota, garantovaná je len cieľová poloha. Tá pri tomto spôsobe
			 * ohraničenia zodpovedá miestu, ktoré by robot dosiahol pri
			 * odrážaní sa od stien ohraničenia pri zachovaní celkovej dĺžky
			 * dráhy pohybu, ale jeho skutočná (matematicky zjednodušená) dráha
			 * nezodpovedá fyzikálne korektnému záznamu dráhy pri takomto
			 * odrážaní sa.</p>
			 * 
			 * <p>Rozdiely ukazujú nasledujúce obrázky:</p>
			 * 
			 * <table class="centered">
			 * <tr><td><image>ohranicenie-vysvetlenie-odrazu-1.png<alt/></image></td>
			 * <td><image>ohranicenie-vysvetlenie-odrazu-2.png<alt/></image></td></tr>
			 * <tr><td colspan="2"><p class="image">Porovnanie fyzikálne
			 * správnych odrazení (zelené čiary) so skutočnými výpočtovo menej
			 * náročnými dráhami robota (červené čiary)<br /><small>(všimnite
			 * si, že v druhom prípade obsahuje skutočná (matematicky
			 * zjednodušená) dráha len tri čiary, pričom fyzikálne korektná
			 * dráha by ich obsahovala päť)</small>.</p></td></tr></table>
			 * 
			 * <p> </p>
			 * 
			 * <p>Implementácia ohraničenia je príkladom toho, ako sa rôznymi
			 * spôsobmi dá výpočtovo (matematicky) dospieť k rovnakému riešeniu
			 * (v tomto prípade cieľovej polohe), pričom medzivýsledky môžu byť
			 * nielen rôzne, ale dokonca fyzikálne nesprávne. Takéto spôsoby
			 * riešenia sú vhodné v prípade, keď záleží viac na jednoduchosti
			 * výpočtu, než na detailnej fyzikálnej korektnosti.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 * 
			 * @param ľaváHranica vzdialenosť od robota určujúca ľavé
			 *     ohraničenie
			 * @param dolnáHranica vzdialenosť od robota určujúca dolné
			 *     ohraničenie
			 * @param praváHranica vzdialenosť od robota určujúca pravé
			 *     ohraničenie
			 * @param hornáHranica vzdialenosť od robota určujúca horné
			 *     ohraničenie
			 * @param spôsob celočíselná hodnota určujúca spôsob spracovania
			 *     ohraničenia; použite konštanty: {@link #ODRAZ ODRAZ},
			 *     {@link #PLOT PLOT}, {@link #PRETOČ PRETOČ} alebo
			 *     {@link #ŽIADNE ŽIADNE}, pričom pri poslednej hodnote budú
			 *     hodnoty hraníc ignorované (ohraničenie bude vypnuté)
			 * 
			 * @see #vypniOhraničenie()
			 * @see #zapniOhraničenie()
			 */
			public void ohranič(double ľaváHranica, double dolnáHranica,
				double praváHranica, double hornáHranica, int spôsob)
			{
				if (ŽIADNE == spôsob)
				{
					aktuálneOhraničenie = ŽIADNE;
					zálohovanéOhraničenie = ŽIADNE;
				}
				else if (ODRAZ == spôsob || PLOT == spôsob || PRETOČ == spôsob)
				{
					// if (0 == ľaváHranica)  ľaváHranica  = 1;
					// if (0 == dolnáHranica) dolnáHranica = 1;
					// if (0 == praváHranica) praváHranica = 1;
					// if (0 == hornáHranica) hornáHranica = 1;

					this.ľaváHranica  = aktuálneX - abs(ľaváHranica);
					this.dolnáHranica = aktuálneY - abs(dolnáHranica);
					this.praváHranica = aktuálneX + abs(praváHranica);
					this.hornáHranica = aktuálneY + abs(hornáHranica);
					aktuálneOhraničenie = spôsob;
					zálohovanéOhraničenie = ŽIADNE;

					// System.out.println("Aktuálne ohraničenie: " +
					// 	this.ľaváHranica  + ", " + this.dolnáHranica + ", " +
					// 	this.praváHranica + ", " + this.hornáHranica);
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #ohranič(double, double, double, double, int) ohranič}.</p> */
			public void ohranic(double ľaváHranica, double dolnáHranica,
				double praváHranica, double hornáHranica, int spôsob)
			{ ohranič(ľaváHranica, dolnáHranica, praváHranica,
				hornáHranica, spôsob); }

			/**
			 * <p>Nastaví nové ohraničenie polohy robota počas jeho pohybu
			 * s predvoleným spôsobom ohraničenia {@link #PRETOČ PRETOČ}.
			 * <!--   -->
			 * Ďalšie podrobnosti o ohraničení nájdete v opise metódy
			 * {@link #ohranič(double, double, double, double,
			 * int) ohranič(vľavo, dole, vpravo, hore, spôsob)}.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 * 
			 * @param ľaváHranica vzdialenosť od robota určujúca ľavé
			 *     ohraničenie
			 * @param dolnáHranica vzdialenosť od robota určujúca dolné
			 *     ohraničenie
			 * @param praváHranica vzdialenosť od robota určujúca pravé
			 *     ohraničenie
			 * @param hornáHranica vzdialenosť od robota určujúca horné
			 *     ohraničenie
			 */
			public void ohranič(double ľaváHranica, double dolnáHranica,
				double praváHranica, double hornáHranica)
			{
				ohranič(ľaváHranica, dolnáHranica,
					praváHranica, hornáHranica, PRETOČ);
			}

			/** <p><a class="alias"></a> Alias pre {@link #ohranič(double, double, double, double) ohranič}.</p> */
			public void ohranic(double ľaváHranica, double dolnáHranica,
				double praváHranica, double hornáHranica)
			{ ohranič(ľaváHranica, dolnáHranica, praváHranica, hornáHranica); }

			/**
			 * <p>Zapne alebo vypne kontrolu polohy robota počas jeho pohybu
			 * prostredníctvom určenia vzdialenosti dvojice horizontálnych
			 * a vertikálnych hraníc od aktuálnej polohy robota a spôsobu
			 * ohraničenia. Prvé dva parametre určujú vzdialenosti ohraničenia
			 * od aktuálnej polohy robota a tretí spôsob kontroly polohy.
			 * <!--   -->
			 * Ďalšie podrobnosti o ohraničení nájdete v opise metódy
			 * {@link #ohranič(double, double, double, double,
			 * int) ohranič(vľavo, dole, vpravo, hore, spôsob)}.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 * 
			 * @param horizontálneHranice vzdialenosť od robota symetricky
			 *     určujúca ľavé a pravé ohraničenie
			 * @param vertikálneHranice vzdialenosť od robota symetricky
			 *     určujúca dolné a horné ohraničenie
			 * @param spôsob celočíselná hodnota určujúca spôsob spracovania
			 *     ohraničenia; použite konštanty: {@link #ODRAZ ODRAZ},
			 *     {@link #PLOT PLOT}, {@link #PRETOČ PRETOČ} alebo
			 *     {@link #ŽIADNE ŽIADNE}, pričom pri poslednej hodnote budú
			 *     hodnoty hraníc ignorované (ohraničenie bude vypnuté)
			 */
			public void ohranič(double horizontálneHranice,
				double vertikálneHranice, int spôsob)
			{
				ohranič(horizontálneHranice, vertikálneHranice,
					horizontálneHranice, vertikálneHranice, spôsob);
			}

			/** <p><a class="alias"></a> Alias pre {@link #ohranič(double, double, int) ohranič}.</p> */
			public void ohranic(double horizontálneHranice,
				double vertikálneHranice, int spôsob)
			{
				ohranič(horizontálneHranice, vertikálneHranice,
					horizontálneHranice, vertikálneHranice, spôsob);
			}

			/**
			 * <p>Nastaví nové ohraničenie polohy robota počas jeho pohybu
			 * s predvoleným spôsobom ohraničenia {@link #PRETOČ PRETOČ}.
			 * <!--   -->
			 * Ďalšie podrobnosti o ohraničení nájdete v opise metódy
			 * {@link #ohranič(double, double, double, double,
			 * int) ohranič(vľavo, dole, vpravo, hore, spôsob)}.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 * 
			 * @param horizontálneHranice vzdialenosť od robota symetricky
			 *     určujúca ľavé a pravé ohraničenie
			 * @param vertikálneHranice vzdialenosť od robota symetricky
			 *     určujúca dolné a horné ohraničenie
			 */
			public void ohranič(double horizontálneHranice,
				double vertikálneHranice)
			{
				ohranič(horizontálneHranice, vertikálneHranice,
					horizontálneHranice, vertikálneHranice, PRETOČ);
			}

			/** <p><a class="alias"></a> Alias pre {@link #ohranič(double, double) ohranič}.</p> */
			public void ohranic(double horizontálneHranice,
				double vertikálneHranice)
			{
				ohranič(horizontálneHranice, vertikálneHranice,
					horizontálneHranice, vertikálneHranice);
			}

			/**
			 * <p>Nastaví nové ohraničenie polohy robota počas jeho pohybu
			 * so zadaným spôsobom ohraničenia a podľa rozmerov kresliacej
			 * plochy, na ktorú má robot nasmerované kreslenie. To môže
			 * byť niektoré plátno – {@linkplain GRobot#podlaha
			 * podlaha}/{@linkplain GRobot#strop strop} alebo nejaký
			 * cieľový obrázok… Pripomíname, že hranice sú nastavené od
			 * aktuálnej polohy robota, čiže na úplné pokrytie kresliacej
			 * plochy je potrebné, aby sa robot v čase nastavovania
			 * ohraničenia nachádzal v strede kresliacej polochy, inak bude
			 * plocha ohraničeného priestoru nesymetrická – na jednej strane
			 * bude robotu dovolené opustiť plochu kresliaceho plátna
			 * (obrázka) a na protiľahlej strane bude jeho pohyb obmedzený
			 * ešte pred okrajom plátna.
			 * <!--   -->
			 * Ďalšie podrobnosti o ohraničení nájdete v opise metódy
			 * {@link #ohranič(double, double, double, double,
			 * int) ohranič(vľavo, dole, vpravo, hore, spôsob)}.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 * 
			 * @param spôsob celočíselná hodnota určujúca spôsob spracovania
			 *     prevoleného ohraničenia – {@link #ODRAZ ODRAZ},
			 *     {@link #PLOT PLOT}, {@link #PRETOČ PRETOČ} alebo
			 *     {@link #ŽIADNE ŽIADNE}, pričom pri poslednej
			 *     hodnote bude ohraničenie bude vypnuté
			 */
			public void ohranič(int spôsob)
			{
				if (obrázokAktívnehoPlátna == podlaha.obrázokPlátna ||
					obrázokAktívnehoPlátna == strop.obrázokPlátna)
				{
					ohranič(Svet.najmenšieX(), Svet.najmenšieY(),
						Svet.najväčšieX(), Svet.najväčšieY(), spôsob);
				}
				else if (obrázokAktívnehoPlátna instanceof Obrázok)
				{
					Obrázok obrázok = (Obrázok)obrázokAktívnehoPlátna;
					ohranič(obrázok.najmenšieX(), obrázok.najmenšieY(),
						obrázok.najväčšieX(), obrázok.najväčšieY(), spôsob);
				}
				else
				{
					int šírka = obrázokAktívnehoPlátna.getWidth();
					int výška = obrázokAktívnehoPlátna.getHeight();
					double najmenšieX = -šírka / 2;
					double najmenšieY = -(výška - 1) / 2;
					double najväčšieX = (šírka - 1) / 2;
					double najväčšieY = výška / 2;
					ohranič(najmenšieX, najmenšieY,
						najväčšieX, najväčšieY, spôsob);
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #ohranič(int) ohranič}.</p> */
			public void ohranic(int spôsob) { ohranič(spôsob); }

			/**
			 * <p>Nastaví nové ohraničenie polohy robota počas jeho pohybu
			 * s predvoleným spôsobom ohraničenia {@link #PRETOČ PRETOČ}
			 * a podľa rozmerov kresliacej plochy, na ktorú má robot
			 * nasmerované kreslenie. O hraniciach ďalej platia rovnaké
			 * informácie, ktoré sú uvedené v opise metódy {@link 
			 * #ohranič(int) ohranič(spôsob)}.</p>
			 * 
			 * <p>Príklad použitia mechanizmu ohraničenia nájdete
			 * v opise metódy {@link GRobot#mimoHraníc(Bod[], double)
			 * mimoHraníc}.</p>
			 */
			public void ohranič() { ohranič(PRETOČ); }

			/** <p><a class="alias"></a> Alias pre {@link #ohranič() ohranič}.</p> */
			public void ohranic() { ohranič(); }


		// Farba bodu

			/**
			 * <p>Zistí farbu bodu (jedného pixela) aktívneho plátna robota
			 * (podlahy alebo stropu) v mieste, kde robot práve stojí. Ak sa
			 * robot nachádza mimo kresliaceho plátna, je vrátená inštancia
			 * farebnosti {@link Farebnosť#žiadna žiadna}. So získanou farbou
			 * môžeme ďalej pracovať – napríklad ju upravovať alebo zisťovať
			 * jej vlastnosti (farebné zložky, priehľadnosť…). Testovať, či má
			 * bod konkrétnu farbu, môžeme napríklad s pomocou metódy {@link 
			 * #farbaBodu(Color) farbaBodu(farba)}.</p>
			 * 
			 * @return farba bodu (objekt typu {@link Farba Farba}) na
			 *     pozícii robota alebo inštancia {@link Farebnosť#žiadna
			 *     žiadna}, ak sa robot nachádza mimo plátna
			 */
			public Farba farbaBodu()
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)aktuálneX, (int)aktuálneY);

					return žiadna;
				}

				int x = (int)Svet.prepočítajX(aktuálneX);
				int y = (int)Svet.prepočítajY(aktuálneY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return žiadna;

				/*
				int farba = obrázokAktívnehoPlátna.getRGB(x, y);

				int alpha = (farba >> 24) & 0xff;
				int red   = (farba >> 16) & 0xff;
				int green = (farba >>  8) & 0xff;
				int blue  =  farba        & 0xff;

				return new Farba(red, green, blue, alpha);
				*/
				return new Farba(obrázokAktívnehoPlátna.getRGB(x, y), true);
			}

			/**
			 * <p>Zistí, či farba bodu (jedného pixela) aktívneho plátna robota
			 * (podlahy alebo stropu) v mieste, kde robot práve stojí je
			 * zhodná so zadanou farbou. Ak sa robot nachádza mimo
			 * kresliaceho plátna, je vrátená hodnota {@code valfalse}.
			 * Testovať farbu s pomocou tejto metódy môžeme napríklad takto:</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdif} ({@code currfarbaBodu}({@link Farebnosť#modrá modrá})) …
				</pre>
			 * 
			 * @param farba farba, ktorú chceme porovnať s farbou bodu na
			 *     plátne
			 * @return {@code valtrue} ak sa robot nachádza v rámci
			 *     rozmerov plátna a farba bodu na mieste robota sa zhoduje
			 *     so zadanou farbou (musia sa zhodovať všetky tri farebné
			 *     zložky aj úroveň priehľadnosti), inak {@code valfalse}
			 */
			public boolean farbaBodu(Color farba)
			// Poznámka: Typ Farba bol upravedný na Color
			// z dôvodu reimplementácie.
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)aktuálneX, (int)aktuálneY, farba);

					return false;
				}

				int x = (int)Svet.prepočítajX(aktuálneX);
				int y = (int)Svet.prepočítajY(aktuálneY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return false;

				return (farba.getRGB() & 0xffffffff) ==
					(obrázokAktívnehoPlátna.getRGB(x, y) & 0xffffffff);
			}

			/**
			 * <p>Zistí, či farba bodu (jedného pixela) aktívneho plátna robota
			 * (podlahy alebo stropu) v mieste, kde robot práve stojí je
			 * zhodná s farbou zadaného objektu. Ak sa robot nachádza mimo
			 * kresliaceho plátna, je vrátená hodnota {@code valfalse}.
			 * Testovať farbu s pomocou tejto metódy môžeme napríklad takto:</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdif} ({@code currfarbaBodu}({@link Farebnosť#modrá modrá})) …
				</pre>
			 * 
			 * @param objekt objekt, ktorého farbu porovnávame s farbou bodu
			 * @return {@code valtrue} ak sa robot nachádza v rámci
			 *     rozmerov plátna a farba bodu na mieste robota sa zhoduje
			 *     s farbou zadaného objektu (musia sa zhodovať všetky tri
			 *     farebné zložky aj úroveň priehľadnosti), inak
			 *     {@code valfalse}
			 */
			public boolean farbaBodu(Farebnosť objekt)
			{
				return farbaBodu(objekt.farba());
			}

			/**
			 * <p>Zistí, či farba bodu (jedného pixela) aktívneho plátna robota
			 * (podlahy alebo stropu) v mieste, kde robot práve stojí je
			 * zhodná s farbou zadanou prostredníctvom farebných zložiek.
			 * (Úroveň priehľadnosti je nastavená na hodnotu {@code num255},
			 * čiže na úplne nepriehľadnú farbu.)
			 * Ak sa robot nachádza mimo kresliaceho
			 * plátna, je vrátená hodnota {@code valfalse}.</p>
			 * 
			 * @param r červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na plátne
			 * @param g červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na plátne
			 * @param b červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na plátne
			 * @return {@code valtrue} ak sa robot nachádza v rámci
			 *     rozmerov plátna a farba bodu na mieste robota sa zhoduje
			 *     so zadanou farbou (musia sa zhodovať všetky tri farebné
			 *     zložky aj úroveň priehľadnosti), inak {@code valfalse}
			 */
			public boolean farbaBodu(int r, int g, int b)
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)aktuálneX, (int)aktuálneY,
								r, g, b);

					return false;
				}

				int x = (int)Svet.prepočítajX(aktuálneX);
				int y = (int)Svet.prepočítajY(aktuálneY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return false;

				r &= 0xff; g &= 0xff; b &= 0xff;
				return (0xff000000 | (r << 16) | (g << 8) | b) ==
					(obrázokAktívnehoPlátna.getRGB(x, y) & 0xffffffff);
			}

			/**
			 * <p>Zistí, či farba bodu (jedného pixela) aktívneho plátna robota
			 * (podlahy alebo stropu) v mieste, kde robot práve stojí je
			 * zhodná s farbou zadanou prostredníctvom farebných zložiek
			 * a úrovne priehľadnosti. Ak sa robot nachádza mimo kresliaceho
			 * plátna, je vrátená hodnota {@code valfalse}.</p>
			 * 
			 * @param r červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na plátne
			 * @param g červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na plátne
			 * @param b červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na plátne
			 * @param a úroveň priehľadnosti farby, ktorú chceme porovnať
			 *     s farbou bodu na plátne
			 * @return {@code valtrue} ak sa robot nachádza v rámci
			 *     rozmerov plátna a farba bodu na mieste robota sa zhoduje
			 *     so zadanou farbou (musia sa zhodovať všetky tri farebné
			 *     zložky aj úroveň priehľadnosti), inak {@code valfalse}
			 */
			public boolean farbaBodu(int r, int g, int b, int a)
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)aktuálneX, (int)aktuálneY,
								r, g, b, a);

					return false;
				}

				int x = (int)Svet.prepočítajX(aktuálneX);
				int y = (int)Svet.prepočítajY(aktuálneY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return false;

				r &= 0xff; g &= 0xff; b &= 0xff; a &= 0xff;
				return ((a << 24) | (r << 16) | (g << 8) | b) ==
					(obrázokAktívnehoPlátna.getRGB(x, y) & 0xffffffff);
			}

			/**
			 * <p>Zistí farbu bodu (jedného pixela) aktívneho plátna robota
			 * (podlahy alebo stropu) na súradniciach myši. So získanou
			 * farbou môžeme ďalej pracovať – napríklad ju upravovať alebo
			 * zisťovať jej vlastnosti (farebné zložky, priehľadnosť…).
			 * Testovať, či má bod konkrétnu farbu môžeme napríklad
			 * s pomocou metódy {@link #farbaNaMyši(Color)
			 * farbaNaMyši(farba)}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Ak by súradnice myši boli náhodou
			 * mimo aktívneho kresliaceho plátna robota, metóda by vrátila
			 * inštanciu farby {@link Farebnosť#žiadna žiadna}.</p>
			 * 
			 * @return farba bodu (objekt typu {@link Farba Farba}) na
			 *     pozícii myši
			 */
			public Farba farbaNaMyši()
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)ÚdajeUdalostí.súradnicaMyšiX,
								(int)ÚdajeUdalostí.súradnicaMyšiY);

					return žiadna;
				}

				int x = (int)Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX);
				int y = (int)Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return žiadna;

				/*
				int farba = obrázokAktívnehoPlátna.getRGB(x, y);

				int alpha = (farba >> 24) & 0xff;
				int red   = (farba >> 16) & 0xff;
				int green = (farba >>  8) & 0xff;
				int blue  =  farba        & 0xff;

				return new Farba(red, green, blue, alpha);
				*/
				return new Farba(obrázokAktívnehoPlátna.getRGB(x, y), true);
			}

			/** <p><a class="alias"></a> Alias pre {@link #farbaNaMyši() farbaNaMyši}.</p> */
			public Farba farbaNaMysi() { return farbaNaMyši(); }

			/**
			 * <p>Zistí, či je farba bodu (jedného pixela) aktívneho plátna
			 * robota (podlahy alebo stropu) na súradniciach myši zhodná so
			 * zadanou farbou. Testovať farbu s pomocou tejto metódy môžeme
			 * napríklad takto:</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdif} ({@code currfarbaNaMyši}({@link Farebnosť#modrá modrá})) …
				</pre>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Ak by súradnice myši boli náhodou
			 * mimo aktívneho kresliaceho plátna robota, metóda by vrátila
			 * hodnotu {@code valfalse}.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>Príklad nakreslí čierny kruh do stredu plátna (teda
			 * v prípade, že začíname s predvolenými vlastnosťami robota),
			 * vytvorí obsluhu udalostí, v rámci ktorej bude testovať, či
			 * je farba bodu na súradniciach myši čierna a ak je, tak pípne.</p>
			 * 
			 * <pre CLASS="example">
				{@link #kruh(double) kruh}({@code num15});

				{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
				{
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#pohybMyši() pohybMyši}()
					{
						{@code kwdif} ({@code currfarbaNaMyši}({@link Farebnosť#čierna čierna}))
						{
							{@link Svet Svet}.{@link Svet#pípni() pípni}();
						}
					}
				};
				</pre>
			 * 
			 * @param farba farba, ktorú chceme porovnať s farbou bodu na
			 *     plátne
			 * @return {@code valtrue} ak je farba bodu na súradniciach myši
			 *     zhodná so zadanou farbou (musia sa zhodovať všetky tri
			 *     farebné zložky aj úroveň priehľadnosti), inak {@code 
			 *     valfalse}
			 */
			public boolean farbaNaMyši(Color farba)
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)ÚdajeUdalostí.súradnicaMyšiX,
								(int)ÚdajeUdalostí.súradnicaMyšiY,
								farba);

					return false;
				}

				int x = (int)Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX);
				int y = (int)Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return false;

				return (farba.getRGB() & 0xffffffff) ==
					(obrázokAktívnehoPlátna.getRGB(x, y) & 0xffffffff);
			}

			/** <p><a class="alias"></a> Alias pre {@link #farbaNaMyši(Color) farbaNaMyši}.</p> */
			public boolean farbaNaMysi(Color farba) { return farbaNaMyši(farba); }

			/**
			 * <p>Zistí, či je farba bodu (jedného pixela) aktívneho plátna
			 * robota (podlahy alebo stropu) na súradniciach myši zhodná
			 * s farbou zadaného objektu.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Ak by súradnice myši boli náhodou
			 * mimo aktívneho kresliaceho plátna robota, metóda by vrátila
			 * hodnotu {@code valfalse}.</p>
			 * 
			 * @param objekt objekt, ktorého farbu porovnávame s farbou bodu
			 * @return {@code valtrue} ak je farba bodu na súradniciach myši
			 *     zhodná s farbou zadaného objektu (musia sa zhodovať všetky
			 *     tri farebné zložky aj úroveň priehľadnosti), inak {@code 
			 *     valfalse}
			 */
			public boolean farbaNaMyši(Farebnosť objekt)
			{ return farbaNaMyši(objekt.farba()); }

			/** <p><a class="alias"></a> Alias pre {@link #farbaNaMyši(Farebnosť) farbaNaMyši}.</p> */
			public boolean farbaNaMysi(Farebnosť objekt) { return farbaNaMyši(objekt); }

			/**
			 * <p>Zistí, či je farba bodu (jedného pixela) aktívneho plátna
			 * robota (podlahy alebo stropu) na súradniciach myši zhodná
			 * s farbou zadanou prostredníctvom farebných zložiek.
			 * (Úroveň priehľadnosti je nastavená na hodnotu {@code num255},
			 * čiže na úplne nepriehľadnú farbu.)</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Ak by súradnice myši boli náhodou
			 * mimo aktívneho kresliaceho plátna robota, metóda by vrátila
			 * hodnotu {@code valfalse}.</p>
			 * 
			 * @param r červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na súradniciach myši
			 * @param g červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na súradniciach myši
			 * @param b červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na súradniciach myši
			 * @return {@code valtrue} ak je farba bodu na súradniciach myši
			 *     zhodná so zadanou farbou (musia sa zhodovať všetky tri
			 *     farebné zložky aj úroveň priehľadnosti), inak {@code 
			 *     valfalse}
			 */
			public boolean farbaNaMyši(int r, int g, int b)
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)ÚdajeUdalostí.súradnicaMyšiX,
								(int)ÚdajeUdalostí.súradnicaMyšiY, r, g, b);

					return false;
				}

				int x = (int)Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX);
				int y = (int)Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return false;

				r &= 0xff; g &= 0xff; b &= 0xff;
				return (0xff000000 | (r << 16) | (g << 8) | b) ==
					(obrázokAktívnehoPlátna.getRGB(x, y) & 0xffffffff);
			}

			/** <p><a class="alias"></a> Alias pre {@link #farbaNaMyši(int, int, int) farbaNaMyši}.</p> */
			public boolean farbaNaMysi(int r, int g, int b) { return farbaNaMyši(r, g, b); }

			/**
			 * <p>Zistí, či je farba bodu (jedného pixela) aktívneho plátna
			 * robota (podlahy alebo stropu) na súradniciach myši zhodná
			 * s farbou zadanou prostredníctvom farebných zložiek a úrovne
			 * priehľadnosti.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Ak by súradnice myši boli náhodou
			 * mimo aktívneho kresliaceho plátna robota, metóda by vrátila
			 * hodnotu {@code valfalse}.</p>
			 * 
			 * @param r červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na súradniciach myši
			 * @param g červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na súradniciach myši
			 * @param b červená zložka farby, ktorú chceme porovnať s farbou
			 *     bodu na súradniciach myši
			 * @param a úroveň priehľadnosti farby, ktorú chceme porovnať
			 *     s farbou bodu na súradniciach myši
			 * @return {@code valtrue} ak je farba bodu na súradniciach myši
			 *     zhodná so zadanou farbou (musia sa zhodovať všetky tri
			 *     farebné zložky aj úroveň priehľadnosti), inak {@code 
			 *     valfalse}
			 */
			public boolean farbaNaMyši(int r, int g, int b, int a)
			{
				if (null == aktívnePlátno)
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
						return ((Obrázok)obrázokAktívnehoPlátna).
							farbaBodu((int)ÚdajeUdalostí.súradnicaMyšiX,
								(int)ÚdajeUdalostí.súradnicaMyšiY, r, g, b, a);

					return false;
				}

				int x = (int)Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX);
				int y = (int)Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY);
				if (x < 0 || x >= Plátno.šírkaPlátna ||
					y < 0 || y >= Plátno.výškaPlátna) return false;

				r &= 0xff; g &= 0xff; b &= 0xff; a &= 0xff;
				return ((a << 24) | (r << 16) | (g << 8) | b) ==
					(obrázokAktívnehoPlátna.getRGB(x, y) & 0xffffffff);
			}

			/** <p><a class="alias"></a> Alias pre {@link #farbaNaMyši(int, int, int, int) farbaNaMyši}.</p> */
			public boolean farbaNaMysi(int r, int g, int b, int a) { return farbaNaMyši(r, g, b, a); }


		// Vylej farbu

			/**
			 * <p>Robot vyleje na svojej pozícii na aktívne plátno alebo do
			 * obrázka, kam bolo presmerované jeho kreslenie, svoju
			 * {@linkplain #farba() farbu}, ktorá sa odtiaľ rozšíri po okraje
			 * okolitej kresby. Na ďalšie informácie pozri metódu {@link 
			 * Plátno#vylejFarbu(double, double, Color)}. Správanie
			 * tejto metódy sa riadi rovnakými pravidlami.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>V tomto príklade ide o vypĺňanie „čmáranice“ náhodnými
			 * farbami klikaním myšou (<small>pozri zoznam zmien: <a
			 * href="zoznam-zmien.html">poďakovanie</a> uvedené pri
			 * verzii 1.35</small>):</p>
			 * 
			 * <table><tr><td>
			 * 
			 * <pre CLASS="example">
				{@code comm// Najskôr nakreslíme na plátno „čmáranicu“:}

				{@link Svet Svet}.{@link Svet#farbaPozadia(Color) farbaPozadia}({@link Farebnosť#modrá modrá});
				{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num1.5});
				{@link GRobot#farba(Color) farba}({@link Farebnosť#biela biela});
				{@link GRobot#skry() skry}();
				{@link GRobot#náhodnáPoloha() náhodnáPoloha}();

				{@code kwdfor} ({@code typeint} j = {@code num0}; j &lt; {@code num30}; ++j)
				{
					{@link GRobot#choďNa(double, double) choďNa}(
						{@link Svet Svet}.{@link Svet#náhodnéReálneČíslo(double, double) náhodnéReálneČíslo}({@link Svet Svet}.{@link Svet#ľavýOkraj() ľavýOkraj}(),
							{@link Svet Svet}.{@link Svet#pravýOkraj() pravýOkraj}()),
						{@link Svet Svet}.{@link Svet#náhodnéReálneČíslo(double, double) náhodnéReálneČíslo}({@link Svet Svet}.{@link Svet#dolnýOkraj() dolnýOkraj}(),
							{@link Svet Svet}.{@link Svet#hornýOkraj() hornýOkraj}()));
				}

				{@code comm// Potom definujeme obsluhu udalostí, v ktorej sa postaráme}
				{@code comm// o vypĺňanie častí obrazca náhodou farbou…}

				{@code kwdnew} {@link ObsluhaUdalostí#ObsluhaUdalostí() ObsluhaUdalostí}()
				{
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link ObsluhaUdalostí#klik() klik}()
					{
						{@link GRobot#farba(int, int, int) farba}(({@code typeint}){@link Svet Svet}.{@link Svet#náhodnéCeléČíslo(long, long) náhodnéCeléČíslo}({@code num0}, {@code num255}),
							({@code typeint}){@link Svet Svet}.{@link Svet#náhodnéCeléČíslo(long, long) náhodnéCeléČíslo}({@code num0}, {@code num255}),
							({@code typeint}){@link Svet Svet}.{@link Svet#náhodnéCeléČíslo(long, long) náhodnéCeléČíslo}({@code num0}, {@code num255}));

						{@link GRobot#skočNaMyš() skočNaMyš}();
						{@code currvylejFarbu}();
					}
				};
				</pre>
			 * </td><td>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <p><image>cmaranica.png<alt/>Výsledok vypĺňania náhodne
			 * generovanej „čmáranice.“</image>Ukážka čiastočne vyplnenej
			 * náhodne generovanej „čmáranice.“</p></td></tr></table>
			 */
			public void vylejFarbu()
			{
				Obrázok.VykonajVObrázku.vylejFarbu(obrázokAktívnehoPlátna,
					aktuálneX, aktuálneY, farbaRobota);
				if (Svet.právePrekresľujem) return;
				Svet.automatickéPrekreslenie();
			}


		// Podlaha a strop

			/**
			 * <p>Po použití tejto metódy bude tento robot kresliť na plátno
			 * podlahy (predvolený stav). Ak chceme, aby robot kreslil na
			 * strop, použijeme metódu {@link #kresliNaStrop()}.</p>
			 */
			public void kresliNaPodlahu()
			{
				aktívnePlátno = podlaha;
				obrázokAktívnehoPlátna = podlaha.obrázokPlátna;
				grafikaAktívnehoPlátna = podlaha.grafikaPlátna;
			}

			/**
			 * <p>Po použití tejto metódy bude tento robot kresliť na plátno
			 * stropu. Ak chceme, aby robot kreslil na podlahu, použijeme
			 * metódu {@link #kresliNaPodlahu()}.</p>
			 */
			public void kresliNaStrop()
			{
				aktívnePlátno = strop;
				obrázokAktívnehoPlátna = strop.obrázokPlátna;
				grafikaAktívnehoPlátna = strop.grafikaPlátna;
			}

			/**
			 * <p>Overí, či tento robot kreslí na podlahu, teda, či je podlaha
			 * aktívnym plátnom robota. Podobne sa dá overiť {@linkplain 
			 * #kreslímNaStrop() kreslenie na strop}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy je
			 * úmyselne uvedený v prvej osobe jednotného čísla
			 * ({@code kreslímNaPodlahu}), pretože diakritický alias otázky
			 * v tretej osobe ({@code kreslíNaPodlahu}? –
			 * {@code kresliNaPodlahu}?) bol v konflikte s rozkazovacím
			 * spôsobom príbuzných metód ({@code kresliNaPodlahu}!).</p>
			 * 
			 * @return {@code valtrue} ak aktívne plátno robota je podlaha,
			 *     inak {@code valfalse}
			 */
			public boolean kreslímNaPodlahu()
			{ return aktívnePlátno == podlaha; }

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaPodlahu() kreslímNaPodlahu}.</p> */
			public boolean kreslimNaPodlahu()
			{ return aktívnePlátno == podlaha; }

			/**
			 * <p>Overí, či tento robot kreslí na strop, teda, či je strop
			 * aktívnym plátnom robota. Podobne sa dá overiť {@linkplain 
			 * #kreslímNaPodlahu() kreslenie na podlahu}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy je
			 * úmyselne uvedený v prvej osobe jednotného čísla
			 * ({@code kreslímNaStrop}), pretože diakritický alias otázky
			 * v tretej osobe ({@code kreslíNaStrop}? –
			 * {@code kresliNaStrop}?) bol v konflikte s rozkazovacím
			 * spôsobom príbuzných metód ({@code kresliNaStrop}!).</p>
			 * 
			 * @return {@code valtrue} ak aktívne plátno robota je strop,
			 *     inak {@code valfalse}
			 */
			public boolean kreslímNaStrop() { return aktívnePlátno == strop; }

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaStrop() kreslímNaStrop}.</p> */
			public boolean kreslimNaStrop() { return aktívnePlátno == strop; }


			// Výplň aktívneho plátna (alebo obrázka)

				/**
				 * <p>Vyplní aktívne plátno alebo obrázok, do ktorého má robot
				 * presmerované kreslenie, aktuálnou farbou kreslenia alebo
				 * náterom robota.</p>
				 */
				public void vyplň()
				{
					if (obrázokAktívnehoPlátna instanceof Obrázok)
					{
						((Obrázok)obrázokAktívnehoPlátna).vyplň(this);
					}
					else
					{
						// grafikaAktívnehoPlátna.setColor(farbaRobota);
						nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
						nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
						grafikaAktívnehoPlátna.fillRect(0, 0,
							obrázokAktívnehoPlátna.getWidth(),
							obrázokAktívnehoPlátna.getHeight());
						obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					}
					Svet.automatickéPrekreslenie();
				}

				/** <p><a class="alias"></a> Alias pre {@link #vyplň() vyplň}.</p> */
				public void vypln() { vyplň(); }


		// Kreslenie na obrázky

			/**
			 * <p>Presmeruje kreslenie tohto robota do určeného obrázka.</p>
			 * 
			 * @param obrázok cieľový obrázok
			 */
			public void kresliNaObrázok(Obrázok obrázok)
			{
				aktívnePlátno = null;
				obrázokAktívnehoPlátna = obrázok;
				grafikaAktívnehoPlátna = obrázok.grafika;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliNaObrázok(Obrázok) kresliNaObrázok}.</p> */
			public void kresliNaObrazok(Obrázok obrázok)
			{ kresliNaObrázok(obrázok); }

			/** <p><a class="alias"></a> Alias pre {@link #kresliNaObrázok(Obrázok) kresliNaObrázok}.</p> */
			public void kresliDoObrázka(Obrázok obrázok)
			{ kresliNaObrázok(obrázok); }

			/** <p><a class="alias"></a> Alias pre {@link #kresliNaObrázok(Obrázok) kresliNaObrázok}.</p> */
			public void kresliDoObrazka(Obrázok obrázok)
			{ kresliNaObrázok(obrázok); }

			/**
			 * <p>Zistí, či je kreslenie tohto robota presmerované do určeného
			 * obrázka.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy je
			 * úmyselne uvedený v prvej osobe jednotného čísla, aby bol
			 * v súlade s názvami metód {@link #kreslímNaPodlahu()
			 * kreslímNaPodlahu} a {@link #kreslímNaStrop() kreslímNaStrop},
			 * pri ktorých nebola iná možnosť na pomenovanie (podrobnosti
			 * sú uvedené v poznámkach v ich opisoch).</p>
			 * 
			 * @param obrázok obrázok
			 */
			public boolean kreslímNaObrázok(Obrázok obrázok)
			{
				return (obrázokAktívnehoPlátna instanceof Obrázok) &&
					(obrázokAktívnehoPlátna == obrázok);
			}

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaObrázok(Obrázok) kreslímNaObrázok}.</p> */
			public boolean kreslimNaObrazok(Obrázok obrázok)
			{ return kreslímNaObrázok(obrázok); }

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaObrázok(Obrázok) kreslímNaObrázok}.</p> */
			public boolean kreslímDoObrázka(Obrázok obrázok)
			{ return kreslímNaObrázok(obrázok); }

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaObrázok(Obrázok) kreslímNaObrázok}.</p> */
			public boolean kreslimDoObrazka(Obrázok obrázok)
			{ return kreslímNaObrázok(obrázok); }

			/**
			 * <p>Ak je kreslenie tohto robota presmerované do obrázka
			 * (inštancie triedy {@link Obrázok Obrázok}), tak táto metóda
			 * túto inštanciu vráti. V opačnom prípade (čiže ak je kreslenie
			 * nasmerované na {@linkplain #kreslímNaPodlahu() podlahu}
			 * alebo {@linkplain #kreslímNaStrop() strop}) vráti metóda
			 * hodnotu {@code valnull}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy je úmyselne
			 * uvedený v prvej osobe jednotného čísla, aby bol v súlade
			 * s názvami metód {@link #kreslímNaPodlahu() kreslímNaPodlahu}
			 * a {@link #kreslímNaStrop() kreslímNaStrop}, pri ktorých
			 * nebola iná možnosť na pomenovanie. Podrobnosti sú uvedené
			 * v poznámkach v ich opisoch.</p>
			 * 
			 * @return inštancia typu {@link Obrázok Obrázok} alebo
			 *     {@code valnull}
			 */
			public Obrázok kreslímNaObrázok()
			{
				if (obrázokAktívnehoPlátna instanceof Obrázok)
					return (Obrázok)obrázokAktívnehoPlátna;
				return null;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaObrázok(Obrázok) kreslímNaObrázok}.</p> */
			public Obrázok kreslimNaObrazok()
			{ return kreslímNaObrázok(); }

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaObrázok(Obrázok) kreslímNaObrázok}.</p> */
			public Obrázok kreslímDoObrázka()
			{ return kreslímNaObrázok(); }

			/** <p><a class="alias"></a> Alias pre {@link #kreslímNaObrázok(Obrázok) kreslímNaObrázok}.</p> */
			public Obrázok kreslimDoObrazka()
			{ return kreslímNaObrázok(); }


			/**
			 * <p>Vráti (na technické účely) aktuálny grafický objekt
			 * používaný týmto robotom. (Definícia tejto metódy sa stala
			 * nevyhnutnou so vznikom triedy {@link Tlač Tlač}.)</p>
			 * 
			 * @return aktuálny grafický objekt používaný na kreslenie
			 *     týmto robotom
			 * 
			 * @see #obrázok()
			 * @see Tlač
			 */
			public Graphics2D grafika() { return grafikaAktívnehoPlátna; }

			/**
			 * <p>Vráti (na technické účely) aktuálny obrázok, na ktorý
			 * tento robot kreslí. (Definícia tejto metódy dopĺňa
			 * definíciu metódy {@link #grafika() grafika}.)</p>
			 * 
			 * @return aktuálny obrázok, na ktorý tento robot kreslí
			 * 
			 * @see #grafika()
			 * @see Tlač
			 */
			public BufferedImage obrázok() { return obrázokAktívnehoPlátna; }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok() obrázok}.</p> */
			public BufferedImage obrazok() { return obrázok(); }


			/**
			 * <p>Táto metóda je určená na implementáciu vlastného kreslenia
			 * robotom s použitím externého grafického objektu {@link 
			 * Graphics2D Graphics2D}. Má byť spustená pred začatím práce
			 * s týmto objektom a po skončení práce musí byť volaná párujúca
			 * metóda {@link #skončiKreslenie(Graphics2D) skončiKreslenie}
			 * (s tým istým objektom grafiky v parametri).</p>
			 * 
			 * @param g2d objekt, ktorého vlastnosti majú byť nastavené
			 *     podľa vlastností tohto robota
			 */
			public void začniKreslenie(Graphics2D g2d)
			{
				nastavVlastnostiGrafiky(g2d);
				nastavFarbuAleboVýplňPodľaRobota(g2d);
				g2d.setStroke(čiara);
				g2d.setFont(aktuálnePísmo);
			}

			/**
			 * <p>Táto metóda je určená na implementáciu vlastného kreslenia
			 * robotom s použitím externého grafického objektu {@link 
			 * Graphics2D Graphics2D}. Má byť spustená po ukončení práce
			 * s týmto objektom, pričom pred začatím práce musí byť volaná
			 * párujúca metóda {@link #začniKreslenie(Graphics2D)
			 * začniKreslenie} (s tým istým objektom grafiky v parametri).</p>
			 * 
			 * @param g2d objekt, ktorého vlastnosti majú byť obnovené
			 */
			public void skončiKreslenie(Graphics2D g2d)
			{
				obnovVlastnostiGrafiky(g2d);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #začniKreslenie(Graphics2D) začniKreslenie}.</p> */
			public void zacniKreslenie(Graphics2D g2d)
			{ začniKreslenie(g2d); }

			/** <p><a class="alias"></a> Alias pre {@link #skončiKreslenie(Graphics2D) skončiKreslenie}.</p> */
			public void skonciKreslenie(Graphics2D g2d)
			{ skončiKreslenie(g2d); }


			/**
			 * <p>Táto metóda je určená na implementáciu vlastného kreslenia
			 * robotom s použitím interného (aktívneho) grafického objektu
			 * robota dostupného aj prostredníctvom metódy {@link 
			 * #grafika() grafika}. Má byť spustená pred začatím grafických
			 * prác za hranicami programovacieho rámca a po skončení prác
			 * musí byť volaná párujúca metóda {@link #skončiKreslenie()
			 * skončiKreslenie} (bez parametra).</p>
			 */
			public void začniKreslenie()
			{
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
				grafikaAktívnehoPlátna.setStroke(čiara);
				grafikaAktívnehoPlátna.setFont(aktuálnePísmo);
			}

			/**
			 * <p>Táto metóda je určená na implementáciu vlastného kreslenia
			 * robotom s použitím interného (aktívneho) grafického objektu
			 * robota dostupného aj prostredníctvom metódy {@link 
			 * #grafika() grafika}. Má byť spustená po ukončení grafických
			 * prác za hranicami programovacieho rámca, pričom pred začatím
			 * prác musí byť volaná párujúca metóda {@link #začniKreslenie()
			 * začniKreslenie} (bez parametra).</p>
			 */
			public void skončiKreslenie()
			{
				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #začniKreslenie() začniKreslenie}.</p> */
			public void zacniKreslenie() { začniKreslenie(); }

			/** <p><a class="alias"></a> Alias pre {@link #skončiKreslenie() skončiKreslenie}.</p> */
			public void skonciKreslenie() { skončiKreslenie(); }


		// Tvary

			/**
			 * <p>Upraví spôsob kreslenia tvarov generovaných robotom. Ide
			 * o úpravu správania metód {@link #krúžok(double) krúžok},
			 * {@link #elipsa(double, double) elipsa}, {@link 
			 * #štvorec(double) štvorec}, {@link #obdĺžnik(double, double)
			 * obdĺžnik} a {@link #hviezda(double) hviezda} (a všetkých ich
			 * verzií). Ak má parameter zadanú hodnotu {@code valtrue}, tak
			 * v prípade, že je {@linkplain #kresliTvary() povolené kreslenie
			 * tvarov} budú uvedené tvary kreslené ako vyplnené plochy, inak
			 * budú nakreslené ako obrysy. Spustenie tejto metódy zároveň
			 * upraví spôsob kreslenia {@linkplain #predvolenýTvar(boolean)
			 * predvoleného tvaru robota} tak, aby bolo v súlade so zadanou
			 * hodnotou parametra ({@code valtrue} znamená vyplnený trojzubec
			 * a {@code valfalse} dutý).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Spôsob kreslenia
			 * predvoleného tvaru trojzubca môže byť dodatočne zmenený
			 * a preto sa môže odlišovať od aktuálneho stavu vypĺňania
			 * tvarov robotom. Na overenie aktuálneho spôsobu kreslenia
			 * predvoleného tvaru trojzubca slúži metóda {@link 
			 * #jePredvolenýTvarVyplnený() jePredvolenýTvarVyplnený}.</p>
			 * 
			 * @param vypĺňaj {@code valtrue} alebo {@code valfalse} podľa
			 *     toho, či majú byť tvary vymenované v opise vypĺňané alebo
			 *     nie
			 * 
			 * @see #vypĺňaTvary()
			 * @see #kresliTvary()
			 * @see #nekresliTvary()
			 * @see #kreslenieTvarovPovolené()
			 * @see #krúžok(double)
			 * @see #krúžok()
			 * @see #elipsa(double, double)
			 * @see #elipsa(double)
			 * @see #štvorec(double)
			 * @see #štvorec()
			 * @see #obdĺžnik(double, double)
			 * @see #obdĺžnik(double)
			 * @see #hviezda(double)
			 * @see #hviezda()
			 * @see #predvolenýTvar(boolean)
			 */
			public void vypĺňajTvary(boolean vypĺňaj)
			{
				vyplnený = vypĺňajTvary = vypĺňaj;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňajTvary(boolean) vypĺňajTvary}.</p> */
			public void vyplnajTvary(boolean vypĺňaj) { vypĺňajTvary(vypĺňaj); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňajTvary(boolean) vypĺňajTvary}.</p> */
			public void vypĺňajÚtvary(boolean vypĺňaj) { vypĺňajTvary(vypĺňaj); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňajTvary(boolean) vypĺňajTvary}.</p> */
			public void vyplnajUtvary(boolean vypĺňaj) { vypĺňajTvary(vypĺňaj); }


			/**
			 * <p>Upraví spôsob kreslenia tvarov generovaných robotom. Ide
			 * o úpravu správania metód {@link #krúžok(double) krúžok},
			 * {@link #elipsa(double, double) elipsa}, {@link 
			 * #štvorec(double) štvorec}, {@link #obdĺžnik(double, double)
			 * obdĺžnik} a {@link #hviezda(double) hviezda} (a všetkých ich
			 * verzií). Po spustení tejto metódy budú uvedené tvary kreslené
			 * ako vyplnené plochy. Spustenie tejto metódy zároveň upraví
			 * spôsob kreslenia {@linkplain #predvolenýTvar(boolean)
			 * predvoleného tvaru robota}, ktorý bude teraz vyplneným
			 * trojzubcom.</p>
			 * 
			 * @see #vypĺňajTvary(boolean)
			 */
			public void vypĺňajTvary() { vypĺňajTvary(true); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňajTvary() vypĺňajTvary}.</p> */
			public void vyplnajTvary() { vypĺňajTvary(true); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňajTvary() vypĺňajTvary}.</p> */
			public void vypĺňajÚtvary() { vypĺňajTvary(true); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňajTvary() vypĺňajTvary}.</p> */
			public void vyplnajUtvary() { vypĺňajTvary(true); }


			/**
			 * <p>Upraví spôsob kreslenia tvarov generovaných robotom. Ide
			 * o úpravu správania metód {@link #krúžok(double) krúžok},
			 * {@link #elipsa(double, double) elipsa}, {@link 
			 * #štvorec(double) štvorec}, {@link #obdĺžnik(double, double)
			 * obdĺžnik} a {@link #hviezda(double) hviezda} (a všetkých ich
			 * verzií). Po spustení tejto metódy budú uvedené tvary kreslené
			 * ako obrysy. Spustenie tejto metódy zároveň upraví spôsob
			 * kreslenia {@linkplain #predvolenýTvar(boolean) predvoleného
			 * tvaru robota}, ktorý bude teraz dutým trojzubcom.</p>
			 * 
			 * @see #vypĺňajTvary(boolean)
			 */
			public void nevypĺňajTvary() { vypĺňajTvary(false); }

			/** <p><a class="alias"></a> Alias pre {@link #nevypĺňajTvary() nevypĺňajTvary}.</p> */
			public void nevyplnajTvary() { vypĺňajTvary(false); }

			/** <p><a class="alias"></a> Alias pre {@link #nevypĺňajTvary() nevypĺňajTvary}.</p> */
			public void nevypĺňajÚtvary() { vypĺňajTvary(false); }

			/** <p><a class="alias"></a> Alias pre {@link #nevypĺňajTvary() nevypĺňajTvary}.</p> */
			public void nevyplnajUtvary() { vypĺňajTvary(false); }


			/**
			 * <p>Zistí, či je aktivované vypĺňanie tvarov generovaných robotom
			 * alebo nie. Stav vypĺňania tvarov súvisí s metódami {@link 
			 * #krúžok(double) krúžok}, {@link #elipsa(double, double)
			 * elipsa}, {@link #štvorec(double) štvorec}, {@link 
			 * #obdĺžnik(double, double) obdĺžnik} a {@link #hviezda(double)
			 * hviezda} (a všetkými ich verziami). Ak má vrátený stav hodnotu
			 * {@code valtrue}, znamená to, že tvary budú kreslené ako
			 * vyplnené plochy, inak budú kreslené ako obrysy (za predpokladu,
			 * že je {@linkplain #kresliTvary() povolené kreslenie tvarov}).
			 * (Predvolená hodnota tejto vlastnosti je {@code valfalse}.)</p>
			 * 
			 * @return {@code valtrue} alebo {@code valfalse} podľa toho, či
			 *     sú tvary vymenované v opise vypĺňané alebo nie
			 * 
			 * @see #vypĺňajTvary(boolean)
			 * @see #kresliTvary()
			 * @see #nekresliTvary()
			 * @see #kreslenieTvarovPovolené()
			 * @see #krúžok(double)
			 * @see #krúžok()
			 * @see #elipsa(double, double)
			 * @see #elipsa(double)
			 * @see #štvorec(double)
			 * @see #štvorec()
			 * @see #obdĺžnik(double, double)
			 * @see #obdĺžnik(double)
			 * @see #hviezda(double)
			 * @see #hviezda()
			 * @see #predvolenýTvar(boolean)
			 */
			public boolean vypĺňaTvary() { return vypĺňajTvary; }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňaTvary() vypĺňajTvary}.</p> */
			public boolean vyplnaTvary() { return vypĺňaTvary(); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňaTvary() vypĺňajTvary}.</p> */
			public boolean vypĺňaÚtvary() { return vypĺňaTvary(); }

			/** <p><a class="alias"></a> Alias pre {@link #vypĺňaTvary() vypĺňajTvary}.</p> */
			public boolean vyplnaUtvary() { return vypĺňaTvary(); }


			/**
			 * <p>Nakreslí na aktuálnej pozícii robota bod alebo skupinu bodov
			 * (kruhovú oblasť) podľa aktuálnej hrúbky pera, najmenej však
			 * oblasť s veľkosťou jedného pixela. (To znamená, že hrúbky pera
			 * menšie než jeden pixel sú zaokrúhlené na veľkosť jedného
			 * pixela.) Na kreslenie je použitá aktuálna farba alebo náter
			 * robota.</p>
			 */
			public void bod()
			{
				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

				// Nemôžem použiť metódu BufferedImage.setRGB(x, y, rgb), ani
				// žiadnu podobnú techniku, pretože by som prišiel o miešanie
				// polopriehľadných farieb… (Vyrábať vlastný spôsob považujem
				// za neefektívne.)
				aktualizujPôsobisko();
				if (polomerPera < 2)
					grafikaAktívnehoPlátna.fillRect(
						(int)Svet.prepočítajX(aktuálneX),
						(int)Svet.prepočítajY(aktuálneY), 1, 1);
				else
					grafikaAktívnehoPlátna.fill(
						new Ellipse2D.Double(
							Svet.prepočítajX(aktuálneX) - (polomerPera / 2),
							Svet.prepočítajY(aktuálneY) - (polomerPera / 2),
							polomerPera, polomerPera));

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/**
			 * <p>Prepíše farebné zložky a zložku priehľadnosti bodu na
			 * aktuálnej pozícii robota aktuálnou farbou robota. Metóda
			 * prepíše vždy iba jediný bod na aktuálnej pozícii. Neriadi sa
			 * veľkosťou pera ani robota.</p>
			 */
			public void prepíšBod()
			{
				// int xx = (int)Svet.prepočítajX(aktuálneX);
				// int yy = (int)Svet.prepočítajY(aktuálneY);
				// 
				// if (xx >= 0 && xx < obrázokAktívnehoPlátna.getWidth() &&
				// 	yy >= 0 && yy < obrázokAktívnehoPlátna.getHeight())
				// {
				// 	obrázokAktívnehoPlátna.setRGB(
				// 		xx, yy, farbaRobota.getRGB());
				// 	Svet.automatickéPrekreslenie();
				// }

				try
				{
					obrázokAktívnehoPlátna.setRGB((int)Svet.prepočítajX(aktuálneX),
						(int)Svet.prepočítajY(aktuálneY), farbaRobota.getRGB());
					Svet.automatickéPrekreslenie();
				}
				catch (ArrayIndexOutOfBoundsException e)
				{
					// Túto chybu zamlčíme – prejdeme to potichu…
					// (Jednoducho bod nebude nastavený a hotovo.)
					// e.printStackTrace()
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #prepíšBod() prepíšBod}.</p> */
			public void prepisBod() { prepíšBod(); }

			/**
			 * <p>Vytlačí na aktuálnom plátne robota pečiatku v jeho aktuálnom
			 * tvare.</p>
			 */
			public void pečiatka()
			{
				kresliRobot(obrázokAktívnehoPlátna,
					grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #pečiatka() pečiatka}.</p> */
			public void peciatka() { pečiatka(); }


			/**
			 * <p>Nakreslí na mieste robota kružnicu alebo kruh so zadaným
			 * polomerom. Vyplnenie tvaru (kreslenie kruhu namiesto kružnice)
			 * závisí od nastavenia vlastnosti {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Pri hľadaní pomenovania tejto
			 * metódy vznikol terminologický problém. Slovo „krúžok“ bolo
			 * použité ako núdzové riešenie situácie, pretože slovenský
			 * jazyk striktne rozlišuje kruh ako vyplnený tvar a kružnicu
			 * ako nakreslenú čiaru ohraničujúcu tento vyplnený tvar.</p>
			 * 
			 * @param polomer polomer kruhového útvaru (kruhu alebo kružnice)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je polomer kruhu/kružnice záporný
			 * 
			 * @see #krúžok()
			 * @see #elipsa(double, double)
			 * @see #štvorec(double)
			 * @see #obdĺžnik(double, double)
			 * @see #hviezda(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape krúžok(double polomer)
			{
				if (vypĺňajTvary) return kruh(polomer);
				return kružnica(polomer);
			}

			/** <p><a class="alias"></a> Alias pre {@link #krúžok(double) krúžok}.</p> */
			public Shape kruzok(double polomer) { return krúžok(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #krúžok(double) krúžok}.</p> */
			public Shape krúžka(double polomer) { return krúžok(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #krúžok(double) krúžok}.</p> */
			public Shape kruzka(double polomer) { return krúžok(polomer); }

			/**
			 * <p>Nakreslí na mieste robota kružnicu so zadaným polomerom.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je polomer kružnice záporný
			 * 
			 * @see #kružnica()
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kružnica(double polomer)
			{
				if (polomer < 0) throw new GRobotException(
					"Polomer kružnice nesmie byť záporný!",
					"negativeRadius", "circle",
					new IllegalArgumentException());

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape kružnica = new Ellipse2D.Double(
					Svet.prepočítajX(aktuálneX) - polomer,
					Svet.prepočítajY(aktuálneY) - polomer,
					2 * polomer, 2 * polomer);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(kružnica);
					aktualizujPôsobisko(polomer/* + (polomerPera / 2)*/);
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return kružnica;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kružnica(double) kružnica}.</p> */
			public Shape kruznica(double polomer) { return kružnica(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica(double) kružnica}.</p> */
			public Shape kružnicu(double polomer) { return kružnica(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica(double) kružnica}.</p> */
			public Shape kruznicu(double polomer) { return kružnica(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica(double) kružnica}.</p> */
			public Shape kružnice(double polomer) { return kružnica(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica(double) kružnica}.</p> */
			public Shape kruznice(double polomer) { return kružnica(polomer); }

			/**
			 * <p>Nakreslí na mieste robota kruh so zadaným polomerom.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer kruhu
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @throws GRobotException ak je polomer kruhu záporný
			 * 
			 * @see #kruh()
			 * @see #kružnica(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kruh(double polomer)
			{
				if (polomer < 0) throw new GRobotException(
					"Polomer kruhu nesmie byť záporný!",
					"negativeRadius", "filledCircle",
					new IllegalArgumentException());

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape kruh = new Ellipse2D.Double(
					Svet.prepočítajX(aktuálneX) - polomer,
					Svet.prepočítajY(aktuálneY) - polomer,
					2 * polomer, 2 * polomer);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(kruh);
					aktualizujPôsobisko(polomer);
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return kruh;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kruh(double) kruh}.</p> */
			public Shape kruhu(double polomer) { return kruh(polomer); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota elipsu so zadanými
			 * rozmermi pootočenú v smere robota (predvolený smer robota je
			 * 90°). Spôsob nakreslenia tvaru (vyplnenie alebo obkreslenie)
			 * závisí od nastavenia vlastnosti {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi (na šírku elipsy)
			 * @param b veľkosť vedľajšej poloosi (na výšku elipsy)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je niektorý rozmer elipsy
			 *     záporný
			 * 
			 * @see #elipsa(double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #štvorec(double)
			 * @see #obdĺžnik(double, double)
			 * @see #hviezda(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape elipsa(double a, double b)
			{
				if (vypĺňajTvary) return vyplňElipsu(a, b);
				return kresliElipsu(a, b);
			}

			/** <p><a class="alias"></a> Alias pre {@link #elipsa(double, double) elipsa}.</p> */
			public Shape elipsu(double a, double b) { return elipsa(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #elipsa(double, double) elipsa}.</p> */
			public Shape elipsy(double a, double b) { return elipsa(a, b); }

			/**
			 * <p>Nakreslí na mieste robota elipsu so zadanými rozmermi
			 * pootočenú v smere robota (predvolený smer robota je 90°).
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi (na šírku elipsy)
			 * @param b veľkosť vedľajšej poloosi (na výšku elipsy)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je niektorý rozmer elipsy
			 *     záporný
			 * 
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliElipsu(double a, double b)
			{
				if (a < 0 || b < 0) throw new GRobotException(
					"Dĺžka poloosy elipsy nesmie byť záporná!",
					"negativeSemiaxe", "ellipse",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape elipsa;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - a,
						prepočítanéY - b, 2 * a, 2 * b);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - b,
						prepočítanéY - a, 2 * b, 2 * a);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					elipsa = AffineTransform.getRotateInstance(-α,
						prepočítanéX, prepočítanéY).
						createTransformedShape(
						new Ellipse2D.Double(prepočítanéX - a,
							prepočítanéY - b, 2 * a, 2 * b));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(elipsa);
					aktualizujPôsobisko(elipsa.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				return elipsa;
			}

			/**
			 * <p>Vyplní elipsu so zadanými rozmermi, so stredom na mieste
			 * robota a pootočenú v smere robota (predvolený smer robota je
			 * 90°).
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi (na šírku elipsy)
			 * @param b veľkosť vedľajšej poloosi (na výšku elipsy)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @throws GRobotException ak je niektorý rozmer elipsy
			 *     záporný
			 * 
			 * @see #elipsa(double)
			 * @see #vyplňElipsu(double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňElipsu(double a, double b)
			{
				if (a < 0 || b < 0) throw new GRobotException(
					"Dĺžka poloosy vyplnenej elipsy nesmie byť záporná!",
					"negativeSemiaxe", "filledEllipse",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape elipsa;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - a,
						prepočítanéY - b, 2 * a, 2 * b);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - b,
						prepočítanéY - a, 2 * b, 2 * a);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					elipsa = AffineTransform.getRotateInstance(-α,
						prepočítanéX, prepočítanéY).
						createTransformedShape(
						new Ellipse2D.Double(prepočítanéX - a,
							prepočítanéY - b, 2 * a, 2 * b));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(elipsa);
					aktualizujPôsobisko(elipsa.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return elipsa;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double, double) vyplňElipsu}.</p> */
			public Shape vyplnElipsu(double a, double b) { return vyplňElipsu(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double, double) vyplňElipsu}.</p> */
			public Shape vyplnenáElipsa(double a, double b) { return vyplňElipsu(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double, double) vyplňElipsu}.</p> */
			public Shape vyplnenaElipsa(double a, double b) { return vyplňElipsu(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double, double) vyplňElipsu}.</p> */
			public Shape vyplnenúElipsu(double a, double b) { return vyplňElipsu(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double, double) vyplňElipsu}.</p> */
			public Shape vyplnenuElipsu(double a, double b) { return vyplňElipsu(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double, double) vyplňElipsu}.</p> */
			public Shape vyplnenejElipsy(double a, double b) { return vyplňElipsu(a, b); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota štvorec určený rozmerom
			 * vpísanej kružnice a obrátený v smere robota. Spôsob nakreslenia
			 * tvaru (vyplnenie alebo obkreslenie) závisí od nastavenia
			 * vlastnosti {@link #vypĺňajTvary(boolean) vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer vpísanej kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je zadaný polomer záporný
			 * 
			 * @see #štvorec()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #obdĺžnik(double, double)
			 * @see #hviezda(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape štvorec(double polomer)
			{
				if (vypĺňajTvary) return vyplňŠtvorec(polomer);
				return kresliŠtvorec(polomer);
			}

			/** <p><a class="alias"></a> Alias pre {@link #štvorec(double) štvorec}.</p> */
			public Shape stvorec(double polomer) { return štvorec(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #štvorec(double) štvorec}.</p> */
			public Shape štvorca(double polomer) { return štvorec(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #štvorec(double) štvorec}.</p> */
			public Shape stvorca(double polomer) { return štvorec(polomer); }

			/**
			 * <p>Nakreslí na mieste robota štvorec určený rozmerom vpísanej
			 * kružnice a obrátený v smere robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer vpísanej kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je zadaný polomer záporný
			 * 
			 * @see #kresliŠtvorec()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliŠtvorec(double polomer)
			{
				if (polomer < 0) throw new GRobotException(
					"Polomer vpísanej kružnice nesmie byť záporný!",
					"negativeRadius", "incircle",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape štvorec;

				if (aktuálnyUhol % 90.0 == 0)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = new RoundRectangle2D.Double(
							prepočítanéX - polomer, prepočítanéY - polomer,
							2 * polomer, 2 * polomer, zaoblenieX, zaoblenieY);
					else
						štvorec = new Rectangle2D.Double(prepočítanéX - polomer,
							prepočítanéY - polomer, 2 * polomer, 2 * polomer);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - polomer,
								prepočítanéY - polomer, 2 * polomer, 2 * polomer,
								zaoblenieX, zaoblenieY));
					else
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - polomer,
								prepočítanéY - polomer, 2 * polomer, 2 * polomer));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(štvorec);
					aktualizujPôsobisko(štvorec.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return štvorec;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliŠtvorec(double) kresliŠtvorec}.</p> */
			public Shape kresliStvorec(double polomer) { return kresliŠtvorec(polomer); }

			/**
			 * <p>Vyplní štvorec so stredom na mieste robota, obrátený v smere
			 * robota a určený polomerom vpísanej kružnice.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer vpísanej kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @throws GRobotException ak je zadaný polomer záporný
			 * 
			 * @see #vyplňŠtvorec()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňŠtvorec(double polomer)
			{
				if (polomer < 0) throw new GRobotException(
					"Polomer vpísanej kružnice nesmie byť záporný!",
					"negativeRadius", "incircle",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape štvorec;

				if (aktuálnyUhol % 90.0 == 0)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = new RoundRectangle2D.Double(
							prepočítanéX - polomer, prepočítanéY - polomer,
							2 * polomer, 2 * polomer, zaoblenieX, zaoblenieY);
					else
						štvorec = new Rectangle2D.Double(prepočítanéX - polomer,
							prepočítanéY - polomer, 2 * polomer, 2 * polomer);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - polomer,
								prepočítanéY - polomer, 2 * polomer, 2 * polomer,
								zaoblenieX, zaoblenieY));
					else
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - polomer,
								prepočítanéY - polomer, 2 * polomer, 2 * polomer));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(štvorec);
					aktualizujPôsobisko(štvorec.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return štvorec;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec(double) vyplňŠtvorec}.</p> */
			public Shape vyplnStvorec(double polomer) { return vyplňŠtvorec(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec(double) vyplňŠtvorec}.</p> */
			public Shape vyplnenýŠtvorec(double polomer) { return vyplňŠtvorec(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec(double) vyplňŠtvorec}.</p> */
			public Shape vyplnenyStvorec(double polomer) { return vyplňŠtvorec(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec(double) vyplňŠtvorec}.</p> */
			public Shape vyplnenéhoŠtvorca(double polomer) { return vyplňŠtvorec(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec(double) vyplňŠtvorec}.</p> */
			public Shape vyplnenehoStvorca(double polomer) { return vyplňŠtvorec(polomer); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota obdĺžnik určený rozmerom
			 * vpísanej elipsy a obrátený v smere robota (predvolený smer
			 * robota je 90°). Spôsob nakreslenia tvaru (vyplnenie alebo
			 * obkreslenie) závisí od nastavenia vlastnosti {@link 
			 * #vypĺňajTvary(boolean) vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi vpísanej elipsy (na šírku)
			 * @param b veľkosť vedľajšej poloosi vpísanej elipsy (na
			 *     výšku)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je niektorý rozmer vpísanej
			 *     elipsy záporný
			 * 
			 * @see #obdĺžnik(double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #štvorec(double)
			 * @see #hviezda(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape obdĺžnik(double a, double b)
			{
				if (vypĺňajTvary) return vyplňObdĺžnik(a, b);
				return kresliObdĺžnik(a, b);
			}

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik(double, double) obdĺžnik}.</p> */
			public Shape obdlznik(double a, double b) { return obdĺžnik(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik(double, double) obdĺžnik}.</p> */
			public Shape obdĺžnika(double a, double b) { return obdĺžnik(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik(double, double) obdĺžnik}.</p> */
			public Shape obdlznika(double a, double b) { return obdĺžnik(a, b); }

			/**
			 * <p>Nakreslí na mieste robota obdĺžnik určený rozmerom vpísanej
			 * elipsy a obrátený v smere robota (predvolený smer robota je 90°).
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi vpísanej elipsy (na šírku)
			 * @param b veľkosť vedľajšej poloosi vpísanej elipsy (na
			 *     výšku)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je niektorý rozmer vpísanej
			 *     elipsy záporný
			 * 
			 * @see #kresliObdĺžnik(double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliObdĺžnik(double a, double b)
			{
				if (a < 0 || b < 0) throw new GRobotException(
					"Dĺžka poloosy vpísanej elipsy nesmie byť záporná!",
					"negativeSemiaxe", "inellipse",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape obdĺžnik;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - a, prepočítanéY - b,
							2 * a, 2 * b, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - a,
							prepočítanéY - b, 2 * a, 2 * b);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - b, prepočítanéY - a,
							2 * b, 2 * a, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - b,
							prepočítanéY - a, 2 * b, 2 * a);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - a,
								prepočítanéY - b, 2 * a, 2 * b,
								zaoblenieX, zaoblenieY));
					else
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - a,
								prepočítanéY - b, 2 * a, 2 * b));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(obdĺžnik);
					aktualizujPôsobisko(obdĺžnik.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return obdĺžnik;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliObdĺžnik(double, double) kresliObdĺžnik}.</p> */
			public Shape kresliObdlznik(double a, double b) { return kresliObdĺžnik(a, b); }

			/**
			 * <p>Vyplní obdĺžnik so stredom na mieste robota, obrátený v smere
			 * robota a určený rozmermi vpísanej elipsy (predvolený smer robota
			 * je 90°).
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi vpísanej elipsy (na šírku)
			 * @param b veľkosť vedľajšej poloosi vpísanej elipsy (na
			 *     výšku)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @throws GRobotException ak je niektorý rozmer vpísanej
			 *     elipsy záporný
			 * 
			 * @see #vyplňObdĺžnik(double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňObdĺžnik(double a, double b)
			{
				if (a < 0 || b < 0) throw new GRobotException(
					"Dĺžka poloosy vpísanej elipsy nesmie byť záporná!",
					"negativeSemiaxe", "inellipse",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape obdĺžnik;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - a, prepočítanéY - b,
							2 * a, 2 * b, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - a,
							prepočítanéY - b, 2 * a, 2 * b);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - b, prepočítanéY - a,
							2 * b, 2 * a, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - b,
							prepočítanéY - a, 2 * b, 2 * a);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - a,
								prepočítanéY - b, 2 * a, 2 * b,
								zaoblenieX, zaoblenieY));
					else
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - a,
								prepočítanéY - b, 2 * a, 2 * b));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(obdĺžnik);
					aktualizujPôsobisko(obdĺžnik.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return obdĺžnik;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double, double) vyplňObdĺžnik}.</p> */
			public Shape vyplnObdlznik(double a, double b) { return vyplňObdĺžnik(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double, double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenýObdĺžnik(double a, double b) { return vyplňObdĺžnik(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double, double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenyObdlznik(double a, double b) { return vyplňObdĺžnik(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double, double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenéhoObdĺžnika(double a, double b) { return vyplňObdĺžnik(a, b); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double, double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenehoObdlznika(double a, double b) { return vyplňObdĺžnik(a, b); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota päťcípu hviezdu určenú
			 * rozmerom opísanej kružnice a orientovanú v smere robota. Spôsob
			 * nakreslenia tvaru (vyplnenie alebo obkreslenie) závisí od
			 * nastavenia vlastnosti {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer opísanej kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je zadaný polomer záporný
			 * 
			 * @see #hviezda()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #štvorec(double)
			 * @see #obdĺžnik(double, double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape hviezda(double polomer)
			{
				if (vypĺňajTvary) return vyplňHviezdu(polomer);
				return kresliHviezdu(polomer);
			}

			/** <p><a class="alias"></a> Alias pre {@link #hviezda(double) hviezda}.</p> */
			public Shape hviezdy(double polomer) { return hviezda(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #hviezda(double) hviezda}.</p> */
			public Shape hviezdu(double polomer) { return hviezda(polomer); }

			/**
			 * <p>Nakreslí na mieste robota päťcípu hviezdu určenú rozmerom
			 * opísanej kružnice a orientovanú v smere robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer opísanej kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @throws GRobotException ak je zadaný polomer záporný
			 * 
			 * @see #kresliHviezdu()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #vyplňHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliHviezdu(double polomer)
			{
				if (polomer < 0) throw new GRobotException(
					"Polomer opísanej kružnice nesmie byť záporný!",
					"negativeRadius", "circumcircle",
					new IllegalArgumentException());

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape hviezda = this.hviezda.daj(polomer);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(hviezda);
					aktualizujPôsobisko(hviezda.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return hviezda;
			}

			/**
			 * <p>Vyplní päťcípu hviezdu so stredom na mieste robota, orientovanú
			 * v smere robota a určenú polomerom opísanej kružnice.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @param polomer polomer opísanej kružnice
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @throws GRobotException ak je zadaný polomer záporný
			 * 
			 * @see #vyplňHviezdu()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňHviezdu(double polomer)
			{
				if (polomer < 0) throw new GRobotException(
					"Polomer opísanej kružnice nesmie byť záporný!",
					"negativeRadius", "circumcircle",
					new IllegalArgumentException());

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape hviezda = this.hviezda.daj(polomer);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(hviezda);
					aktualizujPôsobisko(hviezda.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return hviezda;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu(double) vyplňHviezdu}.</p> */
			public Shape vyplnHviezdu(double polomer) { return vyplňHviezdu(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu(double) vyplňHviezdu}.</p> */
			public Shape vyplnenáHviezda(double polomer) { return vyplňHviezdu(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu(double) vyplňHviezdu}.</p> */
			public Shape vyplnenaHviezda(double polomer) { return vyplňHviezdu(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu(double) vyplňHviezdu}.</p> */
			public Shape vyplnenúHviezdu(double polomer) { return vyplňHviezdu(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu(double) vyplňHviezdu}.</p> */
			public Shape vyplnenuHviezdu(double polomer) { return vyplňHviezdu(polomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu(double) vyplňHviezdu}.</p> */
			public Shape vyplnenejHviezdy(double polomer) { return vyplňHviezdu(polomer); }


			// Útvary generované podľa veľkosti

			/**
			 * <p>Nakreslí na mieste robota kruh alebo kružnicu s polomerom
			 * {@linkplain #veľkosť() veľkosti} robota. Vyplnenie tvaru
			 * (kreslenie kruhu namiesto kružnice) závisí od nastavenia
			 * vlastnosti {@link #vypĺňajTvary(boolean) vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Pri hľadaní pomenovania tejto
			 * metódy vznikol terminologický problém. Slovo „krúžok“ bolo
			 * použité ako núdzové riešenie situácie, pretože slovenský
			 * jazyk striktne rozlišuje kruh ako vyplnený tvar a kružnicu
			 * ako nakreslenú čiaru ohraničujúcu tento vyplnený tvar.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #krúžok(double)
			 * @see #elipsa(double)
			 * @see #štvorec()
			 * @see #obdĺžnik(double)
			 * @see #hviezda()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape krúžok()
			{
				if (vypĺňajTvary) return kruh();
				return kružnica();
			}

			/** <p><a class="alias"></a> Alias pre {@link #krúžok() krúžok}.</p> */
			public Shape kruzok() { return krúžok(); }

			/** <p><a class="alias"></a> Alias pre {@link #krúžok() krúžok}.</p> */
			public Shape krúžka() { return krúžok(); }

			/** <p><a class="alias"></a> Alias pre {@link #krúžok() krúžok}.</p> */
			public Shape kruzka() { return krúžok(); }

			/**
			 * <p>Nakreslí na mieste robota kružnicu s polomerom {@linkplain 
			 * #veľkosť() veľkosti} robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kružnica(double)
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kružnica()
			{
				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape kružnica = new Ellipse2D.Double(
					Svet.prepočítajX(aktuálneX) - veľkosť,
					Svet.prepočítajY(aktuálneY) - veľkosť,
					2 * veľkosť, 2 * veľkosť);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(kružnica);
					aktualizujPôsobisko(veľkosť/* + (polomerPera / 2)*/);
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return kružnica;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kružnica() kružnica}.</p> */
			public Shape kruznica() { return kružnica(); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica() kružnica}.</p> */
			public Shape kružnicu() { return kružnica(); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica() kružnica}.</p> */
			public Shape kruznicu() { return kružnica(); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica() kružnica}.</p> */
			public Shape kružnice() { return kružnica(); }

			/** <p><a class="alias"></a> Alias pre {@link #kružnica() kružnica}.</p> */
			public Shape kruznice() { return kružnica(); }

			/**
			 * <p>Nakreslí na mieste robota kruh s polomerom {@linkplain 
			 * #veľkosť() veľkosti} robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #kruh(double)
			 * @see #kružnica()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kruh()
			{
				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape kruh = new Ellipse2D.Double(
					Svet.prepočítajX(aktuálneX) - veľkosť,
					Svet.prepočítajY(aktuálneY) - veľkosť,
					2 * veľkosť, 2 * veľkosť);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(kruh);
					aktualizujPôsobisko(veľkosť);
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return kruh;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kruh() kruh}.</p> */
			public Shape kruhu() { return kruh(); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota elipsu pootočenú
			 * v smere robota s veľkosťou odvodenou od {@linkplain #veľkosť()
			 * veľkosti} robota podľa zadaného stranového pomeru. Spôsob
			 * nakreslenia tvaru (vyplnenie alebo obkreslenie) závisí od
			 * nastavenia vlastnosti {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}.
			 * <!--   -->
			 * Argument {@code pomer} udáva pomer šírky k výške útvaru.
			 * Hodnota {@code num1.0} znamená rovnakú šírku ako výšku (čiže
			 * hodnotu rovnú aktuálnej {@linkplain #veľkosť() veľkosti}
			 * robota). Čím väčšia hodnota od čísla {@code num1.0}, tým
			 * širší útvar, čím nižšia hodnota (v rozsahu od {@code num1.0}
			 * do {@code num0.0}), tým užší útvar.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer hlavnej a vedľajšej poloosi
			 *     (šírky a výšky elipsy – {@code num2.0} znamená
			 *     dvojnásobnú šírku, {@code num0.5} polovičnú a podobne)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #elipsa(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #štvorec()
			 * @see #obdĺžnik(double)
			 * @see #hviezda()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape elipsa(double pomer)
			{
				if (vypĺňajTvary) return vyplňElipsu(pomer);
				return kresliElipsu(pomer);
			}

			/** <p><a class="alias"></a> Alias pre {@link #elipsa(double) elipsa}.</p> */
			public Shape elipsu(double pomer) { return elipsa(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #elipsa(double) elipsa}.</p> */
			public Shape elipsy(double pomer) { return elipsa(pomer); }

			/**
			 * <p>Nakreslí na mieste robota elipsu pootočenú v smere robota
			 * s veľkosťou odvodenou od {@linkplain #veľkosť() veľkosti}
			 * robota podľa zadaného stranového pomeru.
			 * <!--   -->
			 * Argument {@code pomer} udáva pomer šírky k výške útvaru.
			 * Hodnota {@code num1.0} znamená rovnakú šírku ako výšku (čiže
			 * hodnotu rovnú aktuálnej {@linkplain #veľkosť() veľkosti}
			 * robota). Čím väčšia hodnota od čísla {@code num1.0}, tým
			 * širší útvar, čím nižšia hodnota (v rozsahu od {@code num1.0}
			 * do {@code num0.0}), tým užší útvar.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer hlavnej a vedľajšej poloosi
			 *     (šírky a výšky elipsy – {@code num2.0} znamená
			 *     dvojnásobnú šírku, {@code num0.5} polovičnú a podobne)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kresliElipsu(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliElipsu(double pomer)
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape elipsa;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť *
						pomer, prepočítanéY - veľkosť, 2 * veľkosť * pomer,
						2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť,
						prepočítanéY - veľkosť * pomer, 2 * veľkosť,
						2 * veľkosť * pomer);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					elipsa = AffineTransform.getRotateInstance(-α,
						prepočítanéX, prepočítanéY).
						createTransformedShape(
						new Ellipse2D.Double(prepočítanéX - veľkosť * pomer,
							prepočítanéY - veľkosť, 2 * veľkosť * pomer,
							2 * veľkosť));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(elipsa);
					aktualizujPôsobisko(elipsa.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				return elipsa;
			}

			/**
			 * <p>Vyplní elipsu so stredom na mieste robota, pootočenú v smere
			 * robota, s veľkosťou odvodenou od {@linkplain #veľkosť()
			 * veľkosti} robota podľa zadaného stranového pomeru.
			 * <!--   -->
			 * Argument {@code pomer} udáva pomer šírky k výške útvaru.
			 * Hodnota {@code num1.0} znamená rovnakú šírku ako výšku (čiže
			 * hodnotu rovnú aktuálnej {@linkplain #veľkosť() veľkosti}
			 * robota). Čím väčšia hodnota od čísla {@code num1.0}, tým
			 * širší útvar, čím nižšia hodnota (v rozsahu od {@code num1.0}
			 * do {@code num0.0}), tým užší útvar.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer hlavnej a vedľajšej poloosi
			 *     (šírky a výšky elipsy – {@code num2.0} znamená
			 *     dvojnásobnú šírku, {@code num0.5} polovičnú a podobne)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #vyplňElipsu(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňElipsu(double pomer)
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape elipsa;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť *
						pomer, prepočítanéY - veľkosť, 2 * veľkosť * pomer,
						2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť,
						prepočítanéY - veľkosť * pomer, 2 * veľkosť,
						2 * veľkosť * pomer);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					elipsa = AffineTransform.getRotateInstance(-α,
						prepočítanéX, prepočítanéY).
						createTransformedShape(
						new Ellipse2D.Double(prepočítanéX - veľkosť * pomer,
							prepočítanéY - veľkosť, 2 * veľkosť * pomer,
							2 * veľkosť));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(elipsa);
					aktualizujPôsobisko(elipsa.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return elipsa;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double) vyplňElipsu}.</p> */
			public Shape vyplnElipsu(double pomer) { return vyplňElipsu(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double) vyplňElipsu}.</p> */
			public Shape vyplnenáElipsa(double pomer) { return vyplňElipsu(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double) vyplňElipsu}.</p> */
			public Shape vyplnenaElipsa(double pomer) { return vyplňElipsu(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double) vyplňElipsu}.</p> */
			public Shape vyplnenúElipsu(double pomer) { return vyplňElipsu(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double) vyplňElipsu}.</p> */
			public Shape vyplnenuElipsu(double pomer) { return vyplňElipsu(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu(double) vyplňElipsu}.</p> */
			public Shape vyplnenejElipsy(double pomer) { return vyplňElipsu(pomer); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota elipsu pootočenú
			 * v smere robota s veľkosťou odvodenou od {@linkplain #veľkosť()
			 * veľkosti} robota podľa zadaného stranového pomeru. Spôsob
			 * nakreslenia tvaru (vyplnenie alebo obkreslenie) závisí od
			 * nastavenia vlastnosti {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}.
			 * <!--   -->
			 * Pomer šírky k výške útvaru je určený vlastnosťou robota
			 * {@link #pomer() pomer}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #elipsa(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #hviezda()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape elipsa()
			{
				if (vypĺňajTvary) return vyplňElipsu();
				return kresliElipsu();
			}

			/** <p><a class="alias"></a> Alias pre {@link #elipsa() elipsa}.</p> */
			public Shape elipsu() { return elipsa(); }

			/** <p><a class="alias"></a> Alias pre {@link #elipsa() elipsa}.</p> */
			public Shape elipsy() { return elipsa(); }

			/**
			 * <p>Nakreslí na mieste robota elipsu pootočenú v smere robota
			 * s veľkosťou odvodenou od {@linkplain #veľkosť() veľkosti}
			 * robota podľa zadaného stranového pomeru.
			 * <!--   -->
			 * Pomer šírky k výške útvaru je určený vlastnosťou robota
			 * {@link #pomer() pomer}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kresliElipsu(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #vyplňElipsu()
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik()
			 * @see #vyplňObdĺžnik()
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliElipsu()
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape elipsa;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť *
						pomerVeľkosti, prepočítanéY - veľkosť, 2 * veľkosť *
						pomerVeľkosti, 2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť,
						prepočítanéY - veľkosť * pomerVeľkosti, 2 * veľkosť,
						2 * veľkosť * pomerVeľkosti);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					elipsa = AffineTransform.getRotateInstance(-α,
						prepočítanéX, prepočítanéY).
						createTransformedShape(
						new Ellipse2D.Double(prepočítanéX - veľkosť *
							pomerVeľkosti, prepočítanéY - veľkosť,
							2 * veľkosť * pomerVeľkosti, 2 * veľkosť));
				}

				if (kresliTvary)
				{
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(elipsa);
					aktualizujPôsobisko(elipsa.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				return elipsa;
			}

			/**
			 * <p>Vyplní elipsu so stredom na mieste robota, pootočenú v smere
			 * robota, s veľkosťou odvodenou od {@linkplain #veľkosť()
			 * veľkosti} robota podľa zadaného stranového pomeru.
			 * <!--   -->
			 * Pomer šírky k výške útvaru je určený vlastnosťou robota
			 * {@link #pomer() pomer}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #vyplňElipsu(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa()
			 * @see #kresliElipsu()
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik()
			 * @see #vyplňObdĺžnik()
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňElipsu()
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape elipsa;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť *
						pomerVeľkosti, prepočítanéY - veľkosť, 2 * veľkosť *
						pomerVeľkosti, 2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					elipsa = new Ellipse2D.Double(prepočítanéX - veľkosť,
						prepočítanéY - veľkosť * pomerVeľkosti, 2 * veľkosť,
						2 * veľkosť * pomerVeľkosti);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					elipsa = AffineTransform.getRotateInstance(-α,
						prepočítanéX, prepočítanéY).
						createTransformedShape(
						new Ellipse2D.Double(prepočítanéX - veľkosť *
							pomerVeľkosti, prepočítanéY - veľkosť,
							2 * veľkosť * pomerVeľkosti, 2 * veľkosť));
				}

				if (kresliTvary)
				{
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(elipsa);
					aktualizujPôsobisko(elipsa.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return elipsa;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu() vyplňElipsu}.</p> */
			public Shape vyplnElipsu() { return vyplňElipsu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu() vyplňElipsu}.</p> */
			public Shape vyplnenáElipsa() { return vyplňElipsu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu() vyplňElipsu}.</p> */
			public Shape vyplnenaElipsa() { return vyplňElipsu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu() vyplňElipsu}.</p> */
			public Shape vyplnenúElipsu() { return vyplňElipsu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu() vyplňElipsu}.</p> */
			public Shape vyplnenuElipsu() { return vyplňElipsu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňElipsu() vyplňElipsu}.</p> */
			public Shape vyplnenejElipsy() { return vyplňElipsu(); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota štvorec určený rozmerom
			 * vpísanej kružnice s polomerom {@linkplain #veľkosť() veľkosti}
			 * robota a obrátený v smere robota. Spôsob nakreslenia tvaru
			 * (vyplnenie alebo obkreslenie) závisí od nastavenia vlastnosti
			 * {@link #vypĺňajTvary(boolean) vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #štvorec(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #obdĺžnik(double)
			 * @see #hviezda()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape štvorec()
			{
				if (vypĺňajTvary) return vyplňŠtvorec();
				return kresliŠtvorec();
			}

			/** <p><a class="alias"></a> Alias pre {@link #štvorec() štvorec}.</p> */
			public Shape stvorec() { return štvorec(); }

			/** <p><a class="alias"></a> Alias pre {@link #štvorec() štvorec}.</p> */
			public Shape štvorca() { return štvorec(); }

			/** <p><a class="alias"></a> Alias pre {@link #štvorec() štvorec}.</p> */
			public Shape stvorca() { return štvorec(); }

			/**
			 * <p>Nakreslí na mieste robota štvorec určený rozmerom vpísanej
			 * kružnice s polomerom {@linkplain #veľkosť() veľkosti} robota
			 * a obrátený v smere robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kresliŠtvorec(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliŠtvorec()
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape štvorec;

				if (aktuálnyUhol % 90.0 == 0)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť, prepočítanéY - veľkosť,
							2 * veľkosť, 2 * veľkosť, zaoblenieX, zaoblenieY);
					else
						štvorec = new Rectangle2D.Double(prepočítanéX - veľkosť,
							prepočítanéY - veľkosť, 2 * veľkosť, 2 * veľkosť);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - veľkosť,
								prepočítanéY - veľkosť, 2 * veľkosť, 2 * veľkosť,
								zaoblenieX, zaoblenieY));
					else
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - veľkosť,
								prepočítanéY - veľkosť, 2 * veľkosť, 2 * veľkosť));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(štvorec);
					aktualizujPôsobisko(štvorec.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return štvorec;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliŠtvorec() kresliŠtvorec}.</p> */
			public Shape kresliStvorec() { return kresliŠtvorec(); }

			/**
			 * <p>Vyplní štvorec so stredom na mieste robota, obrátený v smere
			 * robota a určený polomerom vpísanej kružnice s polomerom
			 * {@linkplain #veľkosť() veľkosti} robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #vyplňŠtvorec(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňŠtvorec()
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape štvorec;

				if (aktuálnyUhol % 90.0 == 0)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť, prepočítanéY - veľkosť,
							2 * veľkosť, 2 * veľkosť, zaoblenieX, zaoblenieY);
					else
						štvorec = new Rectangle2D.Double(prepočítanéX - veľkosť,
							prepočítanéY - veľkosť, 2 * veľkosť, 2 * veľkosť);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - veľkosť,
								prepočítanéY - veľkosť, 2 * veľkosť, 2 * veľkosť,
								zaoblenieX, zaoblenieY));
					else
						štvorec = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - veľkosť,
								prepočítanéY - veľkosť, 2 * veľkosť, 2 * veľkosť));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(štvorec);
					aktualizujPôsobisko(štvorec.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return štvorec;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec() vyplňŠtvorec}.</p> */
			public Shape vyplnStvorec() { return vyplňŠtvorec(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec() vyplňŠtvorec}.</p> */
			public Shape vyplnenýŠtvorec() { return vyplňŠtvorec(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec() vyplňŠtvorec}.</p> */
			public Shape vyplnenyStvorec() { return vyplňŠtvorec(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec() vyplňŠtvorec}.</p> */
			public Shape vyplnenéhoŠtvorca() { return vyplňŠtvorec(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňŠtvorec() vyplňŠtvorec}.</p> */
			public Shape vyplnenehoStvorca() { return vyplňŠtvorec(); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota obdĺžnik určený rozmerom
			 * vpísanej elipsy a obrátený v smere robota. Spôsob nakreslenia
			 * tvaru (vyplnenie alebo obkreslenie) závisí od nastavenia
			 * vlastnosti {@link #vypĺňajTvary(boolean) vypĺňajTvary}.
			 * <!--   -->
			 * Argument {@code pomer} udáva pomer šírky k výške útvaru.
			 * Hodnota {@code num1.0} znamená rovnakú šírku ako výšku (čiže
			 * hodnotu rovnú aktuálnej {@linkplain #veľkosť() veľkosti}
			 * robota). Čím väčšia hodnota od čísla {@code num1.0}, tým
			 * širší útvar, čím nižšia hodnota (v rozsahu od {@code num1.0}
			 * do {@code num0.0}), tým užší útvar.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer hlavnej a vedľajšej poloosi vpísanej
			 *     elipsy (šírky a výšky obdĺžnika – {@code num2.0} znamená
			 *     dvojnásobnú šírku, {@code num0.5} polovičnú a podobne)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #obdĺžnik(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #štvorec()
			 * @see #hviezda()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape obdĺžnik(double pomer)
			{
				if (vypĺňajTvary) return vyplňObdĺžnik(pomer);
				return kresliObdĺžnik(pomer);
			}

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik(double) obdĺžnik}.</p> */
			public Shape obdlznik(double pomer) { return obdĺžnik(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik(double) obdĺžnik}.</p> */
			public Shape obdĺžnika(double pomer) { return obdĺžnik(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik(double) obdĺžnik}.</p> */
			public Shape obdlznika(double pomer) { return obdĺžnik(pomer); }

			/**
			 * <p>Nakreslí na mieste robota obdĺžnik určený rozmerom vpísanej
			 * elipsy a obrátený v smere robota.
			 * <!--   -->
			 * Argument {@code pomer} udáva pomer šírky k výške útvaru.
			 * Hodnota {@code num1.0} znamená rovnakú šírku ako výšku (čiže
			 * hodnotu rovnú aktuálnej {@linkplain #veľkosť() veľkosti}
			 * robota). Čím väčšia hodnota od čísla {@code num1.0}, tým
			 * širší útvar, čím nižšia hodnota (v rozsahu od {@code num1.0}
			 * do {@code num0.0}), tým užší útvar.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer hlavnej a vedľajšej poloosi vpísanej
			 *     elipsy (šírky a výšky obdĺžnika – {@code num2.0} znamená
			 *     dvojnásobnú šírku, {@code num0.5} polovičnú a podobne)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kresliObdĺžnik(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliObdĺžnik(double pomer)
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape obdĺžnik;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť * pomer,
							prepočítanéY - veľkosť, 2 * veľkosť * pomer,
							2 * veľkosť, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(
							prepočítanéX - veľkosť * pomer,
							prepočítanéY - veľkosť, 2 * veľkosť * pomer,
							2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť, prepočítanéY - veľkosť *
							pomer, 2 * veľkosť, 2 * veľkosť * pomer,
							zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - veľkosť,
							prepočítanéY - veľkosť * pomer, 2 * veľkosť,
							2 * veľkosť * pomer);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(
								prepočítanéX - veľkosť * pomer,
								prepočítanéY - veľkosť, 2 * veľkosť * pomer,
								2 * veľkosť, zaoblenieX, zaoblenieY));
					else
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - veľkosť * pomer,
								prepočítanéY - veľkosť, 2 * veľkosť * pomer,
								2 * veľkosť));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(obdĺžnik);
					aktualizujPôsobisko(obdĺžnik.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return obdĺžnik;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliObdĺžnik(double) kresliObdĺžnik}.</p> */
			public Shape kresliObdlznik(double pomer) { return kresliObdĺžnik(pomer); }

			/**
			 * <p>Vyplní obdĺžnik so stredom na mieste robota, obrátený
			 * v smere robota a určený rozmermi vpísanej elipsy.
			 * <!--   -->
			 * Argument {@code pomer} udáva pomer šírky k výške útvaru.
			 * Hodnota {@code num1.0} znamená rovnakú šírku ako výšku (čiže
			 * hodnotu rovnú aktuálnej {@linkplain #veľkosť() veľkosti}
			 * robota). Čím väčšia hodnota od čísla {@code num1.0}, tým
			 * širší útvar, čím nižšia hodnota (v rozsahu od {@code num1.0}
			 * do {@code num0.0}), tým užší útvar.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer hlavnej a vedľajšej poloosi vpísanej
			 *     elipsy (šírky a výšky obdĺžnika – {@code num2.0} znamená
			 *     dvojnásobnú šírku, {@code num0.5} polovičnú a podobne)
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňObdĺžnik(double pomer)
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape obdĺžnik;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť * pomer,
							prepočítanéY - veľkosť, 2 * veľkosť * pomer,
							2 * veľkosť, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(
							prepočítanéX - veľkosť * pomer,
							prepočítanéY - veľkosť, 2 * veľkosť * pomer,
							2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť, prepočítanéY - veľkosť *
							pomer, 2 * veľkosť, 2 * veľkosť * pomer,
							zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - veľkosť,
							prepočítanéY - veľkosť * pomer, 2 * veľkosť,
							2 * veľkosť * pomer);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(
								prepočítanéX - veľkosť * pomer,
								prepočítanéY - veľkosť, 2 * veľkosť * pomer,
								2 * veľkosť, zaoblenieX, zaoblenieY));
					else
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - veľkosť * pomer,
								prepočítanéY - veľkosť, 2 * veľkosť * pomer,
								2 * veľkosť));
				}

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(obdĺžnik);
					aktualizujPôsobisko(obdĺžnik.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return obdĺžnik;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double) vyplňObdĺžnik}.</p> */
			public Shape vyplnObdlznik(double pomer) { return vyplňObdĺžnik(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenýObdĺžnik(double pomer) { return vyplňObdĺžnik(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenyObdlznik(double pomer) { return vyplňObdĺžnik(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenéhoObdĺžnika(double pomer) { return vyplňObdĺžnik(pomer); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik(double) vyplňObdĺžnik}.</p> */
			public Shape vyplnenehoObdlznika(double pomer) { return vyplňObdĺžnik(pomer); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota obdĺžnik určený
			 * rozmerom vpísanej elipsy a obrátený v smere robota. Spôsob
			 * nakreslenia tvaru (vyplnenie alebo obkreslenie) závisí od
			 * nastavenia vlastnosti {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}.
			 * <!--   -->
			 * Pomer šírky k výške útvaru je určený vlastnosťou robota
			 * {@link #pomer() pomer}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #obdĺžnik(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa()
			 * @see #štvorec()
			 * @see #hviezda()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape obdĺžnik()
			{
				if (vypĺňajTvary) return vyplňObdĺžnik();
				return kresliObdĺžnik();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik() obdĺžnik}.</p> */
			public Shape obdlznik() { return obdĺžnik(); }

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik() obdĺžnik}.</p> */
			public Shape obdĺžnika() { return obdĺžnik(); }

			/** <p><a class="alias"></a> Alias pre {@link #obdĺžnik() obdĺžnik}.</p> */
			public Shape obdlznika() { return obdĺžnik(); }

			/**
			 * <p>Nakreslí na mieste robota obdĺžnik určený rozmerom vpísanej
			 * elipsy a obrátený v smere robota.
			 * <!--   -->
			 * Pomer šírky k výške útvaru je určený vlastnosťou robota
			 * {@link #pomer() pomer}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kresliObdĺžnik(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa()
			 * @see #kresliElipsu()
			 * @see #vyplňElipsu()
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #vyplňObdĺžnik()
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliObdĺžnik()
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape obdĺžnik;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť * pomerVeľkosti,
							prepočítanéY - veľkosť, 2 * veľkosť * pomerVeľkosti,
							2 * veľkosť, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(
							prepočítanéX - veľkosť * pomerVeľkosti,
							prepočítanéY - veľkosť, 2 * veľkosť * pomerVeľkosti,
							2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť, prepočítanéY - veľkosť *
							pomerVeľkosti, 2 * veľkosť, 2 * veľkosť *
							pomerVeľkosti, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - veľkosť,
							prepočítanéY - veľkosť * pomerVeľkosti, 2 * veľkosť,
							2 * veľkosť * pomerVeľkosti);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(
								prepočítanéX - veľkosť *
								pomerVeľkosti, prepočítanéY - veľkosť,
								2 * veľkosť * pomerVeľkosti, 2 * veľkosť,
								zaoblenieX, zaoblenieY));
					else
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - veľkosť *
								pomerVeľkosti, prepočítanéY - veľkosť,
								2 * veľkosť * pomerVeľkosti, 2 * veľkosť));
				}

				if (kresliTvary)
				{
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(obdĺžnik);
					aktualizujPôsobisko(obdĺžnik.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return obdĺžnik;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliObdĺžnik() kresliObdĺžnik}.</p> */
			public Shape kresliObdlznik() { return kresliObdĺžnik(); }

			/**
			 * <p>Vyplní obdĺžnik so stredom na mieste robota, obrátený
			 * v smere robota a určený rozmermi vpísanej elipsy.
			 * <!--   -->
			 * Pomer šírky k výške útvaru je určený vlastnosťou robota
			 * {@link #pomer() pomer}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa()
			 * @see #kresliElipsu()
			 * @see #vyplňElipsu()
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik()
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňObdĺžnik()
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape obdĺžnik;

				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť * pomerVeľkosti,
							prepočítanéY - veľkosť, 2 * veľkosť * pomerVeľkosti,
							2 * veľkosť, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(
							prepočítanéX - veľkosť * pomerVeľkosti,
							prepočítanéY - veľkosť, 2 * veľkosť * pomerVeľkosti,
							2 * veľkosť);
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = new RoundRectangle2D.Double(
							prepočítanéX - veľkosť, prepočítanéY - veľkosť *
							pomerVeľkosti, 2 * veľkosť, 2 * veľkosť *
							pomerVeľkosti, zaoblenieX, zaoblenieY);
					else
						obdĺžnik = new Rectangle2D.Double(prepočítanéX - veľkosť,
							prepočítanéY - veľkosť * pomerVeľkosti, 2 * veľkosť,
							2 * veľkosť * pomerVeľkosti);
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (0 != zaoblenieX || 0 != zaoblenieY)
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new RoundRectangle2D.Double(prepočítanéX - veľkosť
								* pomerVeľkosti, prepočítanéY - veľkosť,
								2 * veľkosť * pomerVeľkosti, 2 * veľkosť,
								zaoblenieX, zaoblenieY));
					else
						obdĺžnik = AffineTransform.getRotateInstance(-α,
							prepočítanéX, prepočítanéY).createTransformedShape(
							new Rectangle2D.Double(prepočítanéX - veľkosť *
								pomerVeľkosti, prepočítanéY - veľkosť, 2 * veľkosť
								* pomerVeľkosti, 2 * veľkosť));
				}

				if (kresliTvary)
				{
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(obdĺžnik);
					aktualizujPôsobisko(obdĺžnik.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return obdĺžnik;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik() vyplňObdĺžnik}.</p> */
			public Shape vyplnObdlznik() { return vyplňObdĺžnik(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik() vyplňObdĺžnik}.</p> */
			public Shape vyplnenýObdĺžnik() { return vyplňObdĺžnik(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik() vyplňObdĺžnik}.</p> */
			public Shape vyplnenyObdlznik() { return vyplňObdĺžnik(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik() vyplňObdĺžnik}.</p> */
			public Shape vyplnenéhoObdĺžnika() { return vyplňObdĺžnik(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňObdĺžnik() vyplňObdĺžnik}.</p> */
			public Shape vyplnenehoObdlznika() { return vyplňObdĺžnik(); }


			/**
			 * <p>Nakreslí alebo vyplní na mieste robota hviezdu určenú rozmerom
			 * opísanej kružnice s polomerom {@linkplain #veľkosť() veľkosti}
			 * robota a obrátenú v smere robota. Spôsob nakreslenia tvaru
			 * (vyplnenie alebo obkreslenie) závisí od nastavenia vlastnosti
			 * {@link #vypĺňajTvary(boolean) vypĺňajTvary}.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #hviezda(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #štvorec()
			 * @see #obdĺžnik(double)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape hviezda()
			{
				if (vypĺňajTvary) return vyplňHviezdu();
				return kresliHviezdu();
			}

			/** <p><a class="alias"></a> Alias pre {@link #hviezda() hviezda}.</p> */
			public Shape hviezdu() { return hviezda(); }

			/** <p><a class="alias"></a> Alias pre {@link #hviezda() hviezda}.</p> */
			public Shape hviezdy() { return hviezda(); }

			/**
			 * <p>Nakreslí na mieste robota hviezdu určenú rozmerom opísanej
			 * kružnice s polomerom {@linkplain #veľkosť() veľkosti} robota
			 * a obrátenú v smere robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     kreslený útvar
			 * 
			 * @see #kresliHviezdu(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape kresliHviezdu()
			{
				poslednýTypTvaru = TypTvaru.OBRYS;

				Shape hviezda = this.hviezda.daj(veľkosť);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(hviezda);
					aktualizujPôsobisko(hviezda.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return hviezda;
			}

			/**
			 * <p>Vyplní hviezdu so stredom na mieste robota, obrátenú
			 * v smere robota a určenú rozmerom opísanej kružnice
			 * s polomerom {@linkplain #veľkosť() veľkosti} robota.
			 * <!--   -->
			 * {@linkplain #polohaPera(boolean) Poloha pera} nemá na
			 * kreslenie tohto útvaru vplyv. Metóda funguje ako pečiatka.
			 * Útvar nie je nakreslený v prípade, že bol tento robot
			 * {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný} na účely
			 * tvorby {@linkplain Oblasť oblasti} alebo je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return objekt typu {@link Shape Shape} reprezentujúci
			 *     vypĺňaný útvar
			 * 
			 * @see #vyplňHviezdu(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #kresliHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape vyplňHviezdu()
			{
				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				Shape hviezda = this.hviezda.daj(veľkosť);

				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(hviezda);
					aktualizujPôsobisko(hviezda.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}

				return hviezda;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu() vyplňHviezdu}.</p> */
			public Shape vyplnHviezdu() { return vyplňHviezdu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu() vyplňHviezdu}.</p> */
			public Shape vyplnenáHviezda() { return vyplňHviezdu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu() vyplňHviezdu}.</p> */
			public Shape vyplnenaHviezda() { return vyplňHviezdu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu() vyplňHviezdu}.</p> */
			public Shape vyplnenúHviezdu() { return vyplňHviezdu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu() vyplňHviezdu}.</p> */
			public Shape vyplnenuHviezdu() { return vyplňHviezdu(); }

			/** <p><a class="alias"></a> Alias pre {@link #vyplňHviezdu() vyplňHviezdu}.</p> */
			public Shape vyplnenejHviezdy() { return vyplňHviezdu(); }


			/**
			 * <p>Táto metóda buď nakreslí, alebo vráti tvar trojzubca, ktorý
			 * je {@linkplain #predvolenýTvar(boolean) predvoleným tvarom
			 * grafického robota}. Metóda má zvláštne postavenie. Má jednu
			 * ďalšiu verziu prijímajúcu jeden logický parameter –
			 * {@link #trojzubec(boolean) trojzubec(starý)}. Obidve verzie
			 * metódy vždy nanovo prepočítajú súradnice polygónu trojzubca
			 * podľa aktuálnej {@linkplain #poloha() polohy},
			 * {@linkplain #smer() orientácie} a {@linkplain #veľkosť()
			 * veľkosti} robota. Verzia prijímajúca logický parameter dovoľuje
			 * prepočítať tvar aj podľa starej koncepcie (pozri obrázok
			 * v jej {@linkplain #trojzubec(boolean) opise}), naproti tomu
			 * táto verzia metódy prepočíta vždy len novú verziu tvaru
			 * trojzubca. Inak fungujú rovnako.</p>
			 * 
			 * <p>Ak je {@linkplain #kresliTvary() zapnuté kreslenie tvarov}
			 * robotom, tak sa polygón priamo nakreslí alebo vyplní podľa
			 * aktuálneho nastavenia {@linkplain #predvolenýTvar(boolean)
			 * vypĺňania predvoleného tvaru}, ktoré je ovplyvňované aj
			 * nastavením vykonávaným metódou {@link #vypĺňajTvary(boolean)
			 * vypĺňajTvary}. Tvar je kreslený alebo vyplnený s použitím
			 * aktuálnej {@linkplain #farba() farby}
			 * a {@linkplain #hrúbkaČiary() hrúbky} (prípadne aj
			 * {@linkplain #čiara() typu}) čiary robota. V tomto prípade
			 * má metóda návratovú hodnotu {@code valnull}.</p>
			 * 
			 * <p>Ak je {@linkplain #nekresliTvary() kreslenie tvarov
			 * vypnuté}, tak metóda z polygónu vyrobí {@linkplain Shape
			 * tvar Javy} a vráti ho v návratovej hodnote.</p>
			 * 
			 * <p>Táto metóda neaktualizuje {@linkplain #pôsobisko()
			 * pôsobisko}. Slúži len na nakreslenie, vyplnenie alebo
			 * vrátenie tvaru trojzubca, ktorý slúži ako predvolený tvar
			 * robota.</p>
			 * 
			 * <p>(Pozri aj zmeny tvaru robota zachytené na obrázku v opise
			 * metódy {@link #trojzubec(boolean) trojzubec(starý)}.)</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return aktuálny {@linkplain Shape tvar} robota (v zmysle
			 *     aktuálnych parametrov robota – polohy, smeru, veľkosti…;
			 *     iba novú verziu – pozri aj obrázok v opise metódy
			 *     {@link #trojzubec(boolean) trojzubec(starý)}) alebo
			 *     {@code valnull} (podrobnosti sú v opise vyššie)
			 */
			public Shape trojzubec()
			{
				prepočítajPolygón();
				poslednýTypTvaru = TypTvaru.NIČ;

				if (!kresliTvary) return new Polygon(fx, fy, 7);

				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

				if (vyplnený)
				{
					grafikaAktívnehoPlátna.fillPolygon(fx, fy, 7);
				}
				else
				{
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.drawPolygon(fx, fy, 7);
				}

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
				return null;
			}

			/**
			 * <p>Táto metóda buď nakreslí, alebo vráti starý alebo nový tvar
			 * trojzubca, ktorý tvorí {@linkplain #predvolenýTvar(boolean)
			 * predvolený tvar grafického robota}. Spôsob činnosti je
			 * rovnaký ako pri metóde {@link #trojzubec() trojzubec()},
			 * detaily nájdete tam. Jediný rozdiel je, že táto verzia metódy
			 * dovoľuje nakresliť alebo vrátiť aj starú verziu tvaru –
			 * umožňuje to hodnota logického parametra {@code starý}.</p>
			 * 
			 * <p>Rozdiel medzi starým a novým tvarom je zobrazený na
			 * obrázku nižšie. Na ilustráciu sú na obrázku zároveň
			 * nakreslené kružnice odrážajúce skutočnú veľkosť robota.
			 * Plocha kruhu ohraničeného kružnicou bola a je zároveň
			 * predvolenou {@linkplain #koliduje(GRobot) kolíznou „oblasťou“
			 * (resp. plochou)} robota.</p>
			 * 
			 * <p><image>tvaryRobota.png<alt/>Starý a nový predvolený tvar
			 * robota.</image>Starý predvolený tvar robota (pred verziou
			 * 1.75 – vľavo) a nový predvolený tvar robota
			 * (vpravo)<br /><small>(šedé kružnice sú len
			 * ilustračné)</small>.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param starý ak je hodnota parametera rovná {@code valtrue},
			 *     tak táto metóda pracuje so starým tvarom robota (pozri
			 *     obrázok vyššie), inak pracuje rovnako ako metóda
			 *     {@link #trojzubec() trojzubec()}
			 * @return aktuálny (v zmysle aktuálnych parametrov robota –
			 *     polohy, smeru, veľkosti…) starý alebo nový
			 *     {@linkplain Shape tvar} robota (pozri obrázok vyššie)
			 *     alebo {@code valnull} (podrobnosti sú v opise metódy
			 *     {@link #trojzubec() trojzubec()})
			 */
			public Shape trojzubec(boolean starý)
			{
				if (starý) starýPolygón();
				else prepočítajPolygón();
				poslednýTypTvaru = TypTvaru.NIČ;

				if (!kresliTvary) return new Polygon(fx, fy, 7);

				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

				if (vyplnený)
				{
					grafikaAktívnehoPlátna.fillPolygon(fx, fy, 7);
				}
				else
				{
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.drawPolygon(fx, fy, 7);
				}

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
				return null;
			}


			/**
			 * <p>Nakreslí čiaru podľa zadaného tvaru (hrúbkou a farbou čiary
			 * nastavenou pre tento robot).</p>
			 * 
			 * <p>Táto metóda berie do úvahy príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}. Treba podotknúť,
			 * že ak je kreslenie tvarov robotom {@linkplain #nekresliTvary()
			 * vypnuté}, tak volanie tejto metódy nemá žiadny praktický
			 * význam, pretože len vráti rovnaký tvar, ktorý jej bol zadaný
			 * ako parameter ({@code tvar}).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie nakresliteľné.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy koliduje
			 * s názvom metódy {@link #kresliTvar() kresliTvar()} určenej na
			 * prekrytie a kreslenie vlastného tvaru robota. Okrem toho je
			 * definovaná metóda {@link #kresliTvary() kresliTvary()}, ktorá
			 * slúži na opätovné povolenie kreslenia tvarov a písania textov
			 * robotom po ich vypnutí metódou {@link #nekresliTvary()
			 * nekresliTvary()}.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @return vráti rovnaký tvar ako bol zadaný v parametri
			 *     {@code tvar} (na ďalšie použitie)
			 */
			public Shape kresliTvar(Shape tvar)
			{
				if (kresliTvary)
				{
					poslednýTypTvaru = TypTvaru.OBRYS;
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);
					grafikaAktívnehoPlátna.draw(tvar);
					aktualizujPôsobisko(tvar.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				return tvar;
			}

			/**
			 * <p>Vyplní plochu zadaného tvaru farbou nastavenou pre tento
			 * robot.</p>
			 * 
			 * <p>Metóda berie do úvahy príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}. Treba podotknúť,
			 * že ak je kreslenie tvarov robotom {@linkplain #nekresliTvary()
			 * vypnuté}, tak volanie tejto metódy nemá žiadny praktický
			 * význam, pretože len vráti rovnaký tvar, ktorý jej bol zadaný
			 * ako parameter ({@code tvar}).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie vyplniteľné.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @return vráti rovnaký tvar ako bol zadaný v parametri
			 *     {@code tvar} (na ďalšie použitie)
			 */
			public Shape vyplňTvar(Shape tvar)
			{
				if (kresliTvary)
				{
					poslednýTypTvaru = TypTvaru.VÝPLŇ;
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.fill(tvar);
					aktualizujPôsobisko(tvar.getBounds2D());
					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				return tvar;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňTvar(Shape) vyplňTvar}.</p> */
			public Shape vyplnTvar(Shape tvar) { return vyplňTvar(tvar); }

			/**
			 * <p>Vyplní plochu zadaného tvaru zadanou textúrou.
			 * Textúra je zadaná ako názov súboru s obrázkom, ktorý bude
			 * použitý na dlaždicové vyplnenie plochy tvaru.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * <p>Metóda berie do úvahy príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}. Treba podotknúť,
			 * že ak je kreslenie tvarov robotom {@linkplain #nekresliTvary()
			 * vypnuté}, tak volanie tejto metódy nemá žiadny praktický
			 * význam, pretože len vráti rovnaký tvar, ktorý jej bol zadaný
			 * ako parameter ({@code tvar}).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie vyplniteľné.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Parametre textúry sa dajú
			 * ovplyvňovať špeciálnymi príkazmi. Súvisí s nimi i predvolené
			 * správanie príkazov vypĺňania. Predvolený bod začiatku vypĺňania
			 * dlaždicami sa nachádza v strede plátna alebo vypĺňaného
			 * obrázka. Pozrite si aj opis metódy
			 * {@link Svet#posunutieVýplne(double, double) posunutieVýplne},
			 * kde nájdete príklad použitia a odkazy na metódy
			 * upravujúce ďalšie parametre obrázkových výplní.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @param súbor názov súboru s obrázkom textúry
			 * @return vráti rovnaký tvar ako bol zadaný v parametri
			 *     {@code tvar} (na ďalšie použitie)
			 * 
			 * @throws GRobotException ak súbor s obrázkom nebol nájdený
			 * 
			 * @see Svet#priečinokObrázkov()
			 * @see Svet#priečinokObrázkov(String)
			 */
			public Shape vyplňTvar(Shape tvar, String súbor)
			{
				if (kresliTvary)
				{
					BufferedImage obrázok = Obrázok.súborNaObrázok(súbor);

					grafikaAktívnehoPlátna.setPaint(
						new TexturePaint(obrázok, new Rectangle2D.Double(
							Svet.posuňVýplňX, Svet.posuňVýplňY,
							obrázok.getWidth()  * Svet.mierkaVýplneX,
							obrázok.getHeight() * Svet.mierkaVýplneY)));

					poslednýTypTvaru = TypTvaru.VÝPLŇ;

					if (0 == Svet.otočVýplňΑ)
						grafikaAktívnehoPlátna.fill(tvar);
					else
					{
						double β = toRadians(Svet.otočVýplňΑ);
						grafikaAktívnehoPlátna.rotate(-β,
							Svet.otočVýplňX, Svet.otočVýplňY);
						Shape s = AffineTransform.getRotateInstance(β,
							Svet.otočVýplňX, Svet.otočVýplňY).
							createTransformedShape(tvar);

						grafikaAktívnehoPlátna.fill(s);

						grafikaAktívnehoPlátna.rotate(β,
							Svet.otočVýplňX, Svet.otočVýplňY);
					}

					aktualizujPôsobisko(tvar.getBounds2D());
					Svet.automatickéPrekreslenie();
				}
				return tvar;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňTvar(Shape, String) vyplňTvar}.</p> */
			public Shape vyplnTvar(Shape tvar, String súbor)
			{ return vyplňTvar(tvar, súbor); }

			/**
			 * <p>Vyplní plochu zadaného tvaru zadanou textúrou.
			 * Textúra bude použitá na dlaždicové vyplnenie plochy tvaru. Je
			 * zadaná ako objekt typu {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.</p>
			 * 
			 * <p>Metóda berie do úvahy príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}. Treba podotknúť,
			 * že ak je kreslenie tvarov robotom {@linkplain #nekresliTvary()
			 * vypnuté}, tak volanie tejto metódy nemá žiadny praktický
			 * význam, pretože len vráti rovnaký tvar, ktorý jej bol zadaný
			 * ako parameter ({@code tvar}).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie vyplniteľné.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Parametre textúry sa dajú
			 * ovplyvňovať špeciálnymi príkazmi. Súvisí s nimi i predvolené
			 * správanie príkazov vypĺňania. Predvolený bod začiatku vypĺňania
			 * dlaždicami sa nachádza v strede plátna alebo vypĺňaného
			 * obrázka. Pozrite si aj opis metódy
			 * {@link Svet#posunutieVýplne(double, double) posunutieVýplne},
			 * kde nájdete príklad použitia a odkazy na metódy
			 * upravujúce ďalšie parametre obrázkových výplní.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @param výplň obrázok textúry
			 * @return vráti rovnaký tvar ako bol zadaný v parametri
			 *     {@code tvar} (na ďalšie použitie)
			 */
			public Shape vyplňTvar(Shape tvar, Image výplň)
			{
				if (kresliTvary)
				{
					BufferedImage obrázok =
						Obrázok.preveďNaBufferedImage(výplň);
					BufferedImage relevantný =
						Obrázok.dajRelevantnýRaster(obrázok);

					float priehľadnosť = (obrázok instanceof Obrázok) ?
						((Obrázok)obrázok).priehľadnosť : 1.0f;

					poslednýTypTvaru = TypTvaru.VÝPLŇ;

					if (priehľadnosť > 0)
					{
						grafikaAktívnehoPlátna.setPaint(
							new TexturePaint(relevantný, new Rectangle2D.Double(
								Svet.posuňVýplňX, Svet.posuňVýplňY,
								relevantný.getWidth(null)  * Svet.mierkaVýplneX,
								relevantný.getHeight(null) * Svet.mierkaVýplneY)));

						Shape s = tvar; double β = 0.0;

						if (0 != Svet.otočVýplňΑ)
						{
							β = toRadians(Svet.otočVýplňΑ);
							grafikaAktívnehoPlátna.rotate(-β,
								Svet.otočVýplňX, Svet.otočVýplňY);
							s = AffineTransform.getRotateInstance(β,
								Svet.otočVýplňX, Svet.otočVýplňY).
								createTransformedShape(tvar);
						}

						if (priehľadnosť < 1)
						{
							Composite záloha =
								grafikaAktívnehoPlátna.getComposite();
							grafikaAktívnehoPlátna.setComposite(
								AlphaComposite.getInstance(
									AlphaComposite.SRC_OVER,
									priehľadnosť));

							grafikaAktívnehoPlátna.fill(s);
							aktualizujPôsobisko(tvar.getBounds2D());

							grafikaAktívnehoPlátna.setComposite(záloha);
						}
						else
						{
							grafikaAktívnehoPlátna.fill(s);
							aktualizujPôsobisko(tvar.getBounds2D());
						}

						if (0 != Svet.otočVýplňΑ)
						{
							grafikaAktívnehoPlátna.rotate(β,
								Svet.otočVýplňX, Svet.otočVýplňY);
						}

						Svet.automatickéPrekreslenie();
					}
				}
				return tvar;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňTvar(Shape, Image) vyplňTvar}.</p> */
			public Shape vyplnTvar(Shape tvar, Image výplň)
			{ return vyplňTvar(tvar, výplň); }


			/**
			 * <p>Nakreslí čiaru podľa zadaného tvaru (hrúbkou a farbou čiary
			 * nastavenou pre tento robot). Ak je hodnota parametra
			 * {@code upravRobotom} rovná {@code valtrue}, tak bude tvar
			 * pootočený podľa smeru robota (za východisko je považovaných
			 * 90°; odchýlka v kladom alebo zápornom smere náležite pootočí
			 * tvar) a posunutý o súradnice robota na plátne (východisko
			 * posunu je umiestnené do bodu [0, 0] – do stredu plátna; ak
			 * sa robot nachádza v strede plátna, tak sa poloha tvaru
			 * nezmení).</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota a tiež príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie nakresliteľné.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy koliduje
			 * s názvom metódy {@link #kresliTvar() kresliTvar()} určenej na
			 * prekrytie a kreslenie vlastného tvaru robota. Okrem toho je
			 * definovaná metóda {@link #kresliTvary() kresliTvary()}, ktorá
			 * slúži na opätovné povolenie kreslenia tvarov a písania textov
			 * robotom po ich vypnutí metódou {@link #nekresliTvary()
			 * nekresliTvary()}.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @param upravRobotom ak je hodnota tohto parametra rovná
			 *     {@code valtrue}, tak zadaný tvar bude upravený podľa polohy
			 *     a orientácie robota, inak tvar nebude ovplyvňovaný
			 * @return vráti buď rovnaký tvar ako bol zadaný v parametri,
			 *     {@code tvar}, alebo tvar transformovaný podľa polohy
			 *     a orientácie robota (na ďalšie použitie)
			 */
			public Shape kresliTvar(Shape tvar, boolean upravRobotom)
			{
				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
					grafikaAktívnehoPlátna.setStroke(čiara);

					poslednýTypTvaru = TypTvaru.OBRYS;

					if (!upravRobotom || (aktuálnyUhol == 90 &&
						aktuálneX == 0 && aktuálneY == 0 &&
						pôvodnáVeľkosť == veľkosť &&
						pôvodnýPomer == pomerVeľkosti))
					{
						grafikaAktívnehoPlátna.draw(tvar);
						aktualizujPôsobisko(tvar.getBounds2D());
					}
					else
					{
						AffineTransform at = new AffineTransform();

						double prepočítanéX = Svet.prepočítajX(aktuálneX);
						double prepočítanéY = Svet.prepočítajY(aktuálneY);

						/*
						if (pôvodnáVeľkosť != veľkosť ||
							pôvodnýPomer != pomerVeľkosti)
						{
							double mierka = veľkosť / pôvodnáVeľkosť;
							double mierkaX = mierka * (pomerVeľkosti /
								pôvodnýPomer);
							at.translate(prepočítanéX, prepočítanéY);
							at.scale(mierkaX, mierka);
							at.translate(-prepočítanéX, -prepočítanéY);
						}

						at.rotate(toRadians(90 - aktuálnyUhol),
							prepočítanéX, prepočítanéY);

						at.translate(aktuálneX, -aktuálneY);
						tvar = at.createTransformedShape(tvar);
						*/

						// TODO: (Asi vymazať spôsob v komentári vyššie?) Pri
						// používaní tejto metódy som zistil, že transformácie
						// rotácie a zmeny mierky musia byť vymenené, inak
						// vznikalo skosenie tvaru pri nerovnomernej mierke
						// (rozdielnej v dvoch osiach; pretože mierka sa
						// postupne „otáčala,“ až sa pri 90° „vymenila“ –>
						// x za y a tak to šlo dookola).

						at.rotate(toRadians(90 - aktuálnyUhol),
							prepočítanéX, prepočítanéY);

						if (pôvodnáVeľkosť != veľkosť ||
							pôvodnýPomer != pomerVeľkosti)
						{
							double mierka = veľkosť / pôvodnáVeľkosť;
							double mierkaX = mierka * (pomerVeľkosti /
								pôvodnýPomer);
							at.translate(prepočítanéX, prepočítanéY);
							at.scale(mierkaX, mierka);
							at.translate(-prepočítanéX, -prepočítanéY);
						}

						at.translate(aktuálneX, -aktuálneY);
						tvar = at.createTransformedShape(tvar);

						grafikaAktívnehoPlátna.draw(tvar);
						aktualizujPôsobisko(tvar.getBounds2D());
					}

					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				else if (upravRobotom && (aktuálnyUhol != 90 ||
					aktuálneX != 0 || aktuálneY != 0 ||
					pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti))
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					tvar = at.createTransformedShape(tvar);
				}
				return tvar;
			}

			/**
			 * <p>Vyplní plochu zadaného tvaru farbou nastavenou pre tento
			 * robot. Ak je hodnota parametra {@code upravRobotom} rovná
			 * {@code valtrue}, tak bude vypĺňaný tvar pootočený podľa
			 * smeru robota (za východisko je považovaných 90°; odchýlka
			 * v kladom alebo zápornom smere náležite pootočí tvar)
			 * a posunutý o súradnice robota na plátne (východisko posunu
			 * je umiestnené do bodu [0, 0] – do stredu plátna; ak sa robot
			 * nachádza v strede plátna, tak sa poloha tvaru nezmení).</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota a tiež príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie vyplniteľné.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @param upravRobotom ak je hodnota tohto parametra rovná
			 *     {@code valtrue}, tak zadaný tvar bude upravený podľa polohy
			 *     a orientácie robota, inak tvar nebude ovplyvňovaný
			 * @return vráti buď rovnaký tvar ako bol zadaný v parametri,
			 *     {@code tvar}, alebo tvar transformovaný podľa polohy
			 *     a orientácie robota (na ďalšie použitie)
			 */
			public Shape vyplňTvar(Shape tvar, boolean upravRobotom)
			{
				if (kresliTvary)
				{
					// grafikaAktívnehoPlátna.setColor(farbaRobota);
					nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
					nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

					poslednýTypTvaru = TypTvaru.VÝPLŇ;

					if (!upravRobotom || (aktuálnyUhol == 90 &&
						aktuálneX == 0 && aktuálneY == 0 &&
						pôvodnáVeľkosť == veľkosť &&
						pôvodnýPomer == pomerVeľkosti))
					{
						grafikaAktívnehoPlátna.fill(tvar);
						aktualizujPôsobisko(tvar.getBounds2D());
					}
					else
					{
						AffineTransform at = new AffineTransform();

						double prepočítanéX = Svet.prepočítajX(aktuálneX);
						double prepočítanéY = Svet.prepočítajY(aktuálneY);

						at.rotate(toRadians(90 - aktuálnyUhol),
							prepočítanéX, prepočítanéY);

						if (pôvodnáVeľkosť != veľkosť ||
							pôvodnýPomer != pomerVeľkosti)
						{
							double mierka = veľkosť / pôvodnáVeľkosť;
							double mierkaX = mierka * (pomerVeľkosti /
								pôvodnýPomer);
							at.translate(prepočítanéX, prepočítanéY);
							at.scale(mierkaX, mierka);
							at.translate(-prepočítanéX, -prepočítanéY);
						}

						at.translate(aktuálneX, -aktuálneY);
						tvar = at.createTransformedShape(tvar);

						grafikaAktívnehoPlátna.fill(tvar);
						aktualizujPôsobisko(tvar.getBounds2D());
					}

					obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
					Svet.automatickéPrekreslenie();
				}
				else if (upravRobotom && (aktuálnyUhol != 90 ||
					aktuálneX != 0 || aktuálneY != 0 ||
					pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti))
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					tvar = at.createTransformedShape(tvar);
				}
				return tvar;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňTvar(Shape, boolean) vyplňTvar}.</p> */
			public Shape vyplnTvar(Shape tvar, boolean upravRobotom) { return vyplňTvar(tvar, upravRobotom); }

			/**
			 * <p>Vyplní plochu zadaného tvaru zadanou textúrou. Ak je hodnota
			 * parametra {@code upravRobotom} rovná {@code valtrue}, tak
			 * zadaný tvar bude pootočený podľa smeru<sup>[1]</sup> robota
			 * a posunutý o súradnice<sup>[2]</sup> robota na plátne.
			 * Pootočenie a poloha textúry nie sú nijako ovplyvňované
			 * polohou a smerom robota. Textúra je zadaná ako názov súboru
			 * s obrázkom, ktorý bude použitý na dlaždicové vyplnenie
			 * plochy tvaru.</p>
			 * 
			 * <p><small>[1] – za východisko je považovaných 90°; odchýlka
			 * v kladom alebo zápornom smere náležite pootočí
			 * tvar.</small><br />
			 * <small>[2] – východisko posunu je umiestnené do bodu [0, 0] –
			 * do stredu plátna; ak sa robot nachádza v strede plátna,
			 * tak sa poloha tvaru nezmení.</small></p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota a tiež príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie vyplniteľné.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Parametre textúry sa dajú
			 * ovplyvňovať špeciálnymi príkazmi. Súvisí s nimi i predvolené
			 * správanie príkazov vypĺňania. Predvolený bod začiatku vypĺňania
			 * dlaždicami sa nachádza v strede plátna alebo vypĺňaného
			 * obrázka. Pozrite si aj opis metódy
			 * {@link Svet#posunutieVýplne(double, double) posunutieVýplne},
			 * kde nájdete príklad použitia a odkazy na metódy
			 * upravujúce ďalšie parametre obrázkových výplní.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @param súbor názov súboru s obrázkom textúry
			 * @param upravRobotom ak je hodnota tohto parametra rovná
			 *     {@code valtrue}, tak zadaný tvar bude upravený podľa polohy
			 *     a orientácie robota, inak tvar nebude ovplyvňovaný
			 * @return vráti buď rovnaký tvar ako bol zadaný v parametri,
			 *     {@code tvar}, alebo tvar transformovaný podľa polohy
			 *     a orientácie robota (na ďalšie použitie)
			 * 
			 * @throws GRobotException ak súbor s obrázkom nebol nájdený
			 * 
			 * @see Svet#priečinokObrázkov()
			 * @see Svet#priečinokObrázkov(String)
			 */
			public Shape vyplňTvar(Shape tvar, String súbor,
				boolean upravRobotom)
			{
				if (kresliTvary)
				{
					BufferedImage obrázok = Obrázok.súborNaObrázok(súbor);

					grafikaAktívnehoPlátna.setPaint(
						new TexturePaint(obrázok, new Rectangle2D.Double(
							Svet.posuňVýplňX, Svet.posuňVýplňY,
							obrázok.getWidth()  * Svet.mierkaVýplneX,
							obrázok.getHeight() * Svet.mierkaVýplneY)));

					poslednýTypTvaru = TypTvaru.VÝPLŇ;

					Shape s = tvar; double β = 0.0;

					if (0 != Svet.otočVýplňΑ)
					{
						β = toRadians(Svet.otočVýplňΑ);
						grafikaAktívnehoPlátna.rotate(-β,
							Svet.otočVýplňX, Svet.otočVýplňY);
						s = AffineTransform.getRotateInstance(β,
							Svet.otočVýplňX, Svet.otočVýplňY).
							createTransformedShape(tvar);
					}

					if (!upravRobotom || (aktuálnyUhol == 90 &&
						aktuálneX == 0 && aktuálneY == 0 &&
						pôvodnáVeľkosť == veľkosť &&
						pôvodnýPomer == pomerVeľkosti))
					{
						grafikaAktívnehoPlátna.fill(s);
						aktualizujPôsobisko(tvar.getBounds2D());
					}
					else
					{
						AffineTransform at = new AffineTransform();

						double prepočítanéX = Svet.prepočítajX(aktuálneX);
						double prepočítanéY = Svet.prepočítajY(aktuálneY);

						at.rotate(toRadians(90 - aktuálnyUhol),
							prepočítanéX, prepočítanéY);

						if (pôvodnáVeľkosť != veľkosť ||
							pôvodnýPomer != pomerVeľkosti)
						{
							double mierka = veľkosť / pôvodnáVeľkosť;
							double mierkaX = mierka * (pomerVeľkosti /
								pôvodnýPomer);
							at.translate(prepočítanéX, prepočítanéY);
							at.scale(mierkaX, mierka);
							at.translate(-prepočítanéX, -prepočítanéY);
						}

						at.translate(aktuálneX, -aktuálneY);
						tvar = at.createTransformedShape(tvar);

						if (0 != Svet.otočVýplňΑ)
							s = AffineTransform.getRotateInstance(β,
								Svet.otočVýplňX, Svet.otočVýplňY).
								createTransformedShape(tvar);
						else s = tvar;

						grafikaAktívnehoPlátna.fill(s);
						aktualizujPôsobisko(tvar.getBounds2D());
					}

					if (0 != Svet.otočVýplňΑ)
					{
						grafikaAktívnehoPlátna.rotate(β,
							Svet.otočVýplňX, Svet.otočVýplňY);
					}

					Svet.automatickéPrekreslenie();
				}
				else if (upravRobotom && (aktuálnyUhol != 90 ||
					aktuálneX != 0 || aktuálneY != 0 ||
					pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti))
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					poslednýTypTvaru = TypTvaru.NIČ;

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					tvar = at.createTransformedShape(tvar);
				}
				return tvar;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňTvar(Shape, String, boolean) vyplňTvar}.</p> */
			public Shape vyplnTvar(Shape tvar, String súbor, boolean upravRobotom)
			{ return vyplňTvar(tvar, súbor, upravRobotom); }

			/**
			 * <p>Vyplní plochu zadaného tvaru zadanou textúrou. Ak je hodnota
			 * parametra {@code upravRobotom} rovná {@code valtrue}, tak
			 * zadaný tvar bude pootočený podľa smeru<sup>[1]</sup> robota
			 * a posunutý o súradnice<sup>[2]</sup> robota na plátne.
			 * Pootočenie a poloha textúry nie sú nijako ovplyvňované
			 * polohou a smerom robota. Textúra bude použitá na dlaždicové
			 * vyplnenie plochy tvaru. Je zadaná ako objekt typu
			 * {@link Image Image}, za ktorý môže byť dosadený aj objekt
			 * typu {@link Obrázok Obrázok}.</p>
			 * 
			 * <p><small>[1] – za východisko je považovaných 90°; odchýlka
			 * v kladom alebo zápornom smere náležite pootočí
			 * tvar.</small><br />
			 * <small>[2] – východisko posunu je umiestnené do bodu [0, 0] –
			 * do stredu plátna; ak sa robot nachádza v strede plátna,
			 * tak sa poloha tvaru nezmení.</small></p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota a tiež príznak
			 * {@linkplain #kresliTvary() kreslenia tvarov}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda bola pridaná
			 * spolu s triedou {@link SVGPodpora SVGPodpora}, aby boli ňou
			 * rozpoznané tvary jednoduchšie vyplniteľné.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Parametre textúry sa dajú
			 * ovplyvňovať špeciálnymi príkazmi. Súvisí s nimi i predvolené
			 * správanie príkazov vypĺňania. Predvolený bod začiatku vypĺňania
			 * dlaždicami sa nachádza v strede plátna alebo vypĺňaného
			 * obrázka. Pozrite si aj opis metódy
			 * {@link Svet#posunutieVýplne(double, double) posunutieVýplne},
			 * kde nájdete príklad použitia a odkazy na metódy
			 * upravujúce ďalšie parametre obrázkových výplní.</p>
			 * 
			 * @param tvar objekt typu {@link Shape}
			 * @param výplň obrázok textúry
			 * @param upravRobotom ak je hodnota tohto parametra rovná
			 *     {@code valtrue}, tak zadaný tvar bude upravený podľa polohy
			 *     a orientácie robota, inak tvar nebude ovplyvňovaný
			 * @return vráti buď rovnaký tvar ako bol zadaný v parametri,
			 *     {@code tvar}, alebo tvar transformovaný podľa polohy
			 *     a orientácie robota (na ďalšie použitie)
			 */
			public Shape vyplňTvar(Shape tvar, Image výplň,
				boolean upravRobotom)
			{
				if (kresliTvary)
				{
					BufferedImage obrázok =
						Obrázok.preveďNaBufferedImage(výplň);
					BufferedImage relevantný =
						Obrázok.dajRelevantnýRaster(obrázok);

					float priehľadnosť = (obrázok instanceof Obrázok) ?
						((Obrázok)obrázok).priehľadnosť : 1.0f;

					poslednýTypTvaru = TypTvaru.VÝPLŇ;

					if (priehľadnosť > 0)
					{
						grafikaAktívnehoPlátna.setPaint(
							new TexturePaint(relevantný, new Rectangle2D.Double(
								Svet.posuňVýplňX, Svet.posuňVýplňY,
								relevantný.getWidth(null)  * Svet.mierkaVýplneX,
								relevantný.getHeight(null) * Svet.mierkaVýplneY)));

						Shape s = tvar; double β = 0.0;

						if (0 != Svet.otočVýplňΑ)
						{
							β = toRadians(Svet.otočVýplňΑ);
							grafikaAktívnehoPlátna.rotate(-β,
								Svet.otočVýplňX, Svet.otočVýplňY);
							s = AffineTransform.getRotateInstance(β,
								Svet.otočVýplňX, Svet.otočVýplňY).
								createTransformedShape(tvar);
						}

						if (priehľadnosť < 1)
						{
							Composite záloha =
								grafikaAktívnehoPlátna.getComposite();
							grafikaAktívnehoPlátna.setComposite(
								AlphaComposite.getInstance(
									AlphaComposite.SRC_OVER,
									priehľadnosť));

							if (!upravRobotom || (aktuálnyUhol == 90 &&
								aktuálneX == 0 && aktuálneY == 0 &&
								pôvodnáVeľkosť == veľkosť &&
								pôvodnýPomer == pomerVeľkosti))
							{
								grafikaAktívnehoPlátna.fill(s);
								aktualizujPôsobisko(tvar.getBounds2D());
							}
							else
							{
								AffineTransform at = new AffineTransform();

								double prepočítanéX = Svet.prepočítajX(aktuálneX);
								double prepočítanéY = Svet.prepočítajY(aktuálneY);

								at.rotate(toRadians(90 - aktuálnyUhol),
									prepočítanéX, prepočítanéY);

								if (pôvodnáVeľkosť != veľkosť ||
									pôvodnýPomer != pomerVeľkosti)
								{
									double mierka = veľkosť / pôvodnáVeľkosť;
									double mierkaX = mierka * (pomerVeľkosti /
										pôvodnýPomer);
									at.translate(prepočítanéX, prepočítanéY);
									at.scale(mierkaX, mierka);
									at.translate(-prepočítanéX, -prepočítanéY);
								}

								at.translate(aktuálneX, -aktuálneY);
								tvar = at.createTransformedShape(tvar);

								if (0 != Svet.otočVýplňΑ)
									s = AffineTransform.getRotateInstance(β,
										Svet.otočVýplňX, Svet.otočVýplňY).
										createTransformedShape(tvar);
								else s = tvar;

								grafikaAktívnehoPlátna.fill(s);
								aktualizujPôsobisko(tvar.getBounds2D());
							}

							grafikaAktívnehoPlátna.setComposite(záloha);
						}
						else
						{
							if (!upravRobotom || (aktuálnyUhol == 90 &&
								aktuálneX == 0 && aktuálneY == 0 &&
								pôvodnáVeľkosť == veľkosť &&
								pôvodnýPomer == pomerVeľkosti))
							{
								grafikaAktívnehoPlátna.fill(s);
								aktualizujPôsobisko(tvar.getBounds2D());
							}
							else
							{
								AffineTransform at = new AffineTransform();

								double prepočítanéX = Svet.prepočítajX(aktuálneX);
								double prepočítanéY = Svet.prepočítajY(aktuálneY);

								at.rotate(toRadians(90 - aktuálnyUhol),
									prepočítanéX, prepočítanéY);

								if (pôvodnáVeľkosť != veľkosť ||
									pôvodnýPomer != pomerVeľkosti)
								{
									double mierka = veľkosť / pôvodnáVeľkosť;
									double mierkaX = mierka * (pomerVeľkosti /
										pôvodnýPomer);
									at.translate(prepočítanéX, prepočítanéY);
									at.scale(mierkaX, mierka);
									at.translate(-prepočítanéX, -prepočítanéY);
								}

								at.translate(aktuálneX, -aktuálneY);
								tvar = at.createTransformedShape(tvar);

								if (0 != Svet.otočVýplňΑ)
									s = AffineTransform.getRotateInstance(β,
										Svet.otočVýplňX, Svet.otočVýplňY).
										createTransformedShape(tvar);
								else s = tvar;

								grafikaAktívnehoPlátna.fill(s);
								aktualizujPôsobisko(tvar.getBounds2D());
							}
						}

						if (0 != Svet.otočVýplňΑ)
						{
							grafikaAktívnehoPlátna.rotate(β,
								Svet.otočVýplňX, Svet.otočVýplňY);
						}

						Svet.automatickéPrekreslenie();
					}
					else if (upravRobotom && (aktuálnyUhol != 90 ||
						aktuálneX != 0 || aktuálneY != 0 ||
						pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti))
					{
						AffineTransform at = new AffineTransform();

						double prepočítanéX = Svet.prepočítajX(aktuálneX);
						double prepočítanéY = Svet.prepočítajY(aktuálneY);

						at.rotate(toRadians(90 - aktuálnyUhol),
							prepočítanéX, prepočítanéY);

						if (pôvodnáVeľkosť != veľkosť ||
							pôvodnýPomer != pomerVeľkosti)
						{
							double mierka = veľkosť / pôvodnáVeľkosť;
							double mierkaX = mierka * (pomerVeľkosti /
								pôvodnýPomer);
							at.translate(prepočítanéX, prepočítanéY);
							at.scale(mierkaX, mierka);
							at.translate(-prepočítanéX, -prepočítanéY);
						}

						at.translate(aktuálneX, -aktuálneY);
						tvar = at.createTransformedShape(tvar);
					}
				}
				else if (upravRobotom && (aktuálnyUhol != 90 ||
					aktuálneX != 0 || aktuálneY != 0 ||
					pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti))
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					poslednýTypTvaru = TypTvaru.NIČ;
						// TODO toto napojiť na SVGPodporu‼‼
						// (over, či to je všade, kde má byť)

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					tvar = at.createTransformedShape(tvar);
				}
				return tvar;
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňTvar(Shape, Image, boolean) vyplňTvar}.</p> */
			public Shape vyplnTvar(Shape tvar, Image výplň, boolean upravRobotom)
			{ return vyplňTvar(tvar, výplň, upravRobotom); }


			// Detekcia myši v tvaroch

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v kruhu so
			 * stredom na aktuálnej pozícii robota a zadaným polomerom.</p>
			 * 
			 * @param polomer polomer vyšetrovaného kruhu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVCeste()
			 * @see #myšVElipse(double, double)
			 * @see #myšVPôsobisku()
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVHviezde(double)
			 * @see #myšVOblasti(Area)
			 * @see #myšVKruhu()
			 */
			public boolean myšVKruhu(double polomer)
			{
				/*
				return (pow(ÚdajeUdalostí.súradnicaMyšiX - aktuálneX, 2) +
					pow(ÚdajeUdalostí.súradnicaMyšiY - aktuálneY, 2)) <=
					// pow(polomer /*+ (polomerPera / 2)* /, 2);
					(polomer * polomer);
				*/
				double Δx = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
				double Δy = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
				return (Δx * Δx + Δy * Δy) <= polomer * polomer;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVKruhu(double) myšVKruhu}.</p> */
			public boolean mysVKruhu(double polomer) { return myšVKruhu(polomer); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v elipse
			 * pootočenej v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi zadaných poloosí.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi (na šírku elipsy)
			 * @param b veľkosť vedľajšej poloosi (na výšku elipsy)
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVCeste()
			 * @see #myšVKruhu(double)
			 * @see #myšVPôsobisku()
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVHviezde(double)
			 * @see #myšVOblasti(Area)
			 * @see #myšVKruhu()
			 */
			public boolean myšVElipse(double a, double b)
			{
				double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
				double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				/*!-!
				return (pow(x1 / (a /*+ polovicaHrúbkyPera* /), 2) +
					pow(y1 / (b /*+ polovicaHrúbkyPera* /), 2)) <= 1;
				*/

				x1 /= a; y1 /= b; return (x1 * x1 + y1 * y1) <= 1;
			}

			/** <p><a class="alias"></a> Alias pre {@link #mysVElipse(double, double) mysVElipse}.</p> */
			public boolean mysVElipse(double a, double b) { return myšVElipse(a, b); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú vo štvorci so
			 * stredom na aktuálnej pozícii robota, rotovanom v smere robota
			 * a rozmerom udaným polomerom vpísanej kružnice.</p>
			 * 
			 * @param polomer polomer kružnice vpísanej do štvorca so
			 *     stredom na aktuálnej pozícii robota
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVCeste()
			 * @see #myšVElipse(double, double)
			 * @see #myšVKruhu(double)
			 * @see #myšVPôsobisku()
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVHviezde(double)
			 * @see #myšVOblasti(Area)
			 * @see #myšVKruhu()
			 */
			public boolean myšVoŠtvorci(double polomer)
			{
				boolean jeV; double x1, y1;
				if (aktuálnyUhol % 90.0 == 0)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV = x1 >= -polomer && x1 <= polomer &&
						y1 >= -polomer && y1 <= polomer;
				}
				else
				{
					// x₀ = xm − x
					// y₀ = ym − y
					double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					// x₁ = x₀ . cos(α) − y₀ . sin(α)
					// y₁ = x₀ . sin(α) + y₀ . cos(α)
					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					// x₁ > -polomer && y₁ > -polomer && x₁ < polomer && y₁ < polomer
					jeV = x1 >= -polomer && x1 <= polomer &&
						y1 >= -polomer && y1 <= polomer;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * polomer) / 2;
					double zy = min(abs(zaoblenieY), 2 * polomer) / 2;
					double Δzx = polomer - zx, Δzy = polomer - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVoŠtvorci(double) myšVoŠtvorci}.</p> */
			public boolean mysVoStvorci(double polomer) { return myšVoŠtvorci(polomer); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v obdĺžniku
			 * pootočenom v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi udanými ako poloosi vpísanej elipsy.</p>
			 * 
			 * @param a veľkosť hlavnej poloosi (šírka vpísanej elipsy)
			 * @param b veľkosť vedľajšej poloosi (výška vpísanej elipsy)
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVCeste()
			 * @see #myšVKruhu(double)
			 * @see #myšVElipse(double, double)
			 * @see #myšVPôsobisku()
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVHviezde(double)
			 * @see #myšVOblasti(Area)
			 * @see #myšVKruhu()
			 */
			public boolean myšVObdĺžniku(double a, double b)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV = x1 >= -a && x1 <= a && y1 >= -b && y1 <= b;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV = x1 >= -b && x1 <= b && y1 >= -a && y1 <= a;
				}
				else
				{
					double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV = x1 >= -a && x1 <= a && y1 >= -b && y1 <= b;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * a) / 2;
					double zy = min(abs(zaoblenieY), 2 * b) / 2;
					double Δzx = a - zx, Δzy = b - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVObdĺžniku(double, double) myšVObdĺžniku}.</p> */
			public boolean mysVObdlzniku(double a, double b)
			{ return myšVObdĺžniku(a, b); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v päťcípej
			 * hviezde so stredom na aktuálnej pozícii robota, rotovanej
			 * v smere robota a rozmerom udaným prostredníctvom polomeru
			 * opísanej kružnice.</p>
			 * 
			 * @param polomer polomer kružnice opísanej okolo hviezdy so
			 *     stredom na aktuálnej pozícii robota
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVCeste()
			 * @see #myšVElipse(double, double)
			 * @see #myšVKruhu(double)
			 * @see #myšVPôsobisku()
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVOblasti(Area)
			 * @see #myšVKruhu()
			 */
			public boolean myšVHviezde(double polomer)
			{
				return this.hviezda.bodV(ÚdajeUdalostí.súradnicaMyšiX,
					ÚdajeUdalostí.súradnicaMyšiY, polomer);
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVHviezde(double) myšVHviezde}.</p> */
			public boolean mysVHviezde(double polomer)
			{ return myšVHviezde(polomer); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v zadanej
			 * oblasti, ktorá je na účely porovnania rotovaná podľa smeru
			 * robota (za východisko je považovaných 90°; odchýlka v kladom
			 * alebo zápornom smere náležite rotuje oblasť) a posunutá
			 * o súradnice robota na plátne (stred sa nachádza v bode [0, 0] –
			 * v strede plátna).</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * @param oblasť oblasť, ktorá má byť použitá na overenie
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVCeste()
			 * @see #myšVElipse(double, double)
			 * @see #myšVKruhu(double)
			 * @see #myšVPôsobisku()
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVHviezde(double)
			 * @see #myšVKruhu()
			 */
			public boolean myšVOblasti(Area oblasť)
			{
				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
					return oblasť.contains(
						Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
						Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));

				AffineTransform at = new AffineTransform();

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				at.rotate(toRadians(90 - aktuálnyUhol),
					prepočítanéX, prepočítanéY);

				if (pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti)
				{
					double mierka = veľkosť / pôvodnáVeľkosť;
					double mierkaX = mierka * (pomerVeľkosti /
						pôvodnýPomer);
					at.translate(prepočítanéX, prepočítanéY);
					at.scale(mierkaX, mierka);
					at.translate(-prepočítanéX, -prepočítanéY);
				}

				at.translate(aktuálneX, -aktuálneY);
				Area a = oblasť.createTransformedArea(at);

				return a.contains(
					Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
					Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVOblasti(Area) myšVOblasti}.</p> */
			public boolean mysVOblasti(Area oblasť) { return myšVOblasti(oblasť); }

			// Detekcia myši v tvaroch generovaných podľa veľkosti robota

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v kruhu so
			 * stredom na aktuálnej pozícii robota a polomerom s {@linkplain 
			 * #veľkosť(double) veľkosťou} robota.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVElipse(double)
			 * @see #myšVoŠtvorci()
			 * @see #myšVObdĺžniku(double)
			 * @see #myšVHviezde()
			 */
			public boolean myšVKruhu()
			{
				double Δx = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
				double Δy = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
				return (Δx * Δx + Δy * Δy) <= veľkosť * veľkosť;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVKruhu() myšVKruhu}.</p> */
			public boolean mysVKruhu() { return myšVKruhu(); }

			/** <p><a class="alias"></a> Alias pre {@link #myšVKruhu() myšVKruhu}.</p> */
			public boolean myšV() { return myšVKruhu(); }

			/** <p><a class="alias"></a> Alias pre {@link #myšVKruhu() myšVKruhu}.</p> */
			public boolean mysV() { return myšVKruhu(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v elipse
			 * pootočenej v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi podľa {@linkplain #veľkosť(double)
			 * veľkosti} robota a zadaného pomeru poloosí.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer veľkosť hlavnej a vedľajšej poloosi
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVKruhu()
			 * @see #myšVoŠtvorci()
			 * @see #myšVObdĺžniku(double)
			 * @see #myšVHviezde()
			 */
			public boolean myšVElipse(double pomer)
			{
				if (0 == pomer || 0 == veľkosť) return false;

				double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
				double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				x1 /= (veľkosť * pomer);
				y1 /= veľkosť;
				return (x1 * x1 + y1 * y1) <= 1;
			}

			/** <p><a class="alias"></a> Alias pre {@link #mysVElipse(double) mysVElipse}.</p> */
			public boolean mysVElipse(double pomer) { return myšVElipse(pomer); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v elipse
			 * pootočenej v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi podľa {@linkplain #veľkosť(double)
			 * veľkosti} robota a vlastnosti robota {@link #pomer()
			 * pomer}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVKruhu()
			 * @see #myšVoŠtvorci()
			 * @see #myšVObdĺžniku()
			 * @see #myšVHviezde()
			 */
			public boolean myšVElipse()
			{
				if (0 == pomerVeľkosti || 0 == veľkosť) return false;

				double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
				double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				x1 /= (veľkosť * pomerVeľkosti);
				y1 /= veľkosť;
				return (x1 * x1 + y1 * y1) <= 1;
			}

			/** <p><a class="alias"></a> Alias pre {@link #mysVElipse() mysVElipse}.</p> */
			public boolean mysVElipse() { return myšVElipse(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú vo štvorci so
			 * stredom na aktuálnej pozícii robota, rotovanom v smere robota
			 * a rozmerom podľa {@linkplain #veľkosť(double) veľkosti}
			 * robota.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVElipse(double)
			 * @see #myšVKruhu()
			 * @see #myšVObdĺžniku(double)
			 * @see #myšVHviezde()
			 */
			public boolean myšVoŠtvorci()
			{
				boolean jeV; double x1, y1;
				if (aktuálnyUhol % 90.0 == 0)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV = x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else
				{
					// x₀ = xm − x
					// y₀ = ym − y
					double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					// x₁ = x₀ . cos(α) − y₀ . sin(α)
					// y₁ = x₀ . sin(α) + y₀ . cos(α)
					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					// x₁ > -veľkosť && y₁ > -veľkosť && x₁ < veľkosť && y₁ < veľkosť
					jeV = x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = veľkosť - zx, Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVoŠtvorci() myšVoŠtvorci}.</p> */
			public boolean mysVoStvorci() { return myšVoŠtvorci(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v obdĺžniku
			 * pootočenom v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi podľa {@linkplain #veľkosť(double)
			 * veľkosti} robota a zadaného pomeru strán.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param pomer pomer veľkosť hlavnej a vedľajšej poloosi
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVKruhu()
			 * @see #myšVElipse(double)
			 * @see #myšVoŠtvorci()
			 * @see #myšVHviezde()
			 */
			public boolean myšVObdĺžniku(double pomer)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV =
						x1 >= -(veľkosť * pomer) && x1 <= (veľkosť * pomer) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV =
						x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -(veľkosť * pomer) && y1 <= (veľkosť * pomer);
				}
				else
				{
					double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV =
						x1 >= -(veľkosť * pomer) && x1 <= (veľkosť * pomer) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť * pomer) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = (veľkosť * pomer) - zx, Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVObdĺžniku(double) myšVObdĺžniku}.</p> */
			public boolean mysVObdlzniku(double pomer)
			{ return myšVObdĺžniku(pomer); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v obdĺžniku
			 * pootočenom v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi podľa {@linkplain #veľkosť(double)
			 * veľkosti} robota a vlastnosti robota {@link #pomer()
			 * pomer}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVKruhu()
			 * @see #myšVElipse()
			 * @see #myšVoŠtvorci()
			 * @see #myšVHviezde()
			 */
			public boolean myšVObdĺžniku()
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV =
						x1 >= -(veľkosť * pomerVeľkosti) &&
						x1 <= (veľkosť * pomerVeľkosti) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					y1 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;
					jeV =
						x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -(veľkosť * pomerVeľkosti) &&
						y1 <= (veľkosť * pomerVeľkosti);
				}
				else
				{
					double x0 = ÚdajeUdalostí.súradnicaMyšiX - aktuálneX;
					double y0 = ÚdajeUdalostí.súradnicaMyšiY - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV =
						x1 >= -(veľkosť * pomerVeľkosti) &&
						x1 <= (veľkosť * pomerVeľkosti) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť * pomerVeľkosti) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = (veľkosť * pomerVeľkosti) - zx,
						Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVObdĺžniku() myšVObdĺžniku}.</p> */
			public boolean mysVObdlzniku() { return myšVObdĺžniku(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v hviezde so
			 * stredom na aktuálnej pozícii robota, rotovanej v smere robota
			 * a rozmerom podľa {@linkplain #veľkosť(double) veľkosti}
			 * robota.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVElipse(double)
			 * @see #myšVKruhu()
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVObdĺžniku(double)
			 */
			public boolean myšVHviezde()
			{
				return this.hviezda.bodV(ÚdajeUdalostí.súradnicaMyšiX,
					ÚdajeUdalostí.súradnicaMyšiY, veľkosť);
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVHviezde() myšVHviezde}.</p> */
			public boolean mysVHviezde() { return myšVHviezde(); }

			// Detekcia bodov v tvaroch

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v kruhu so
			 * zadaným polomerom stredom na aktuálnej pozícii robota.
			 * Nasledujúca metóda dovoľuje namiesto súradníc bodu použiť
			 * objekt: {@link #bodVKruhu(Poloha, double) bodVKruhu(Poloha
			 * objekt, double polomer)}</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param polomer polomer vyšetrovaného kruhu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVKruhu(double súradnicaBoduX, double súradnicaBoduY, double polomer)
			{
				/*
				return (pow(súradnicaBoduX - aktuálneX, 2) +
					pow(súradnicaBoduY - aktuálneY, 2)) <=
					// pow(polomer /*+ (polomerPera / 2)* /, 2);
					(polomer * polomer);
				*/
				double Δx = súradnicaBoduX - aktuálneX;
				double Δy = súradnicaBoduY - aktuálneY;
				return (Δx * Δx + Δy * Δy) <= polomer * polomer;
			}

			// /**
				//  * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v kruhu so
				//  * zadaným polomerom stredom na aktuálnej pozícii robota.</p>
				//  * 
				//  * @param bod súradnice bodu
				//  * @param polomer polomer vyšetrovaného kruhu
				//  * @return {@code valtrue} – áno; {@code valfalse} – nie
				//  * 
				//  * @see #bodVPôsobisku(Point2D)
				//  * @see #bodVElipse(Point2D, double, double)
				//  * @see #bodVoŠtvorci(Point2D, double)
				//  * @see #bodVObdĺžniku(Point2D, double, double)
				//  * @see #bodVCeste(Point2D)
				//  * @see #bodVOblasti(Point2D, Area)
				//  * @see #bodVTvare(Point2D, Shape)
				//  */
				// public boolean bodVKruhu(Point2D bod, double polomer)
				// {
				// 	/*
				// 	return (pow(bod.getX() - aktuálneX, 2) +
				// 		pow(bod.getY() - aktuálneY, 2)) <=
				// 		// pow(polomer /*+ (polomerPera / 2)* /, 2);
				// 		(polomer * polomer);
				// 	*/
				// 	double Δx = bod.getX() - aktuálneX;
				// 	double Δy = bod.getY() - aktuálneY;
				// 	return (Δx * Δx + Δy * Δy) <= polomer * polomer;
				// }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVKruhu(double, double,
			 * double) bodVKruhu(x, y, polomer)}, len namiesto súradníc bodu
			 * je použitá poloha zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param polomer polomer vyšetrovaného kruhu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVKruhu(Poloha objekt, double polomer)
			{
				/*
				return (pow(iný.aktuálneX - aktuálneX, 2) +
					pow(iný.aktuálneY - aktuálneY, 2)) <=
					// pow(polomer /*+ (polomerPera / 2)* /, 2);
					(polomer * polomer);
				*/
				double Δx = objekt.polohaX() - aktuálneX;
				double Δy = objekt.polohaY() - aktuálneY;
				return (Δx * Δx + Δy * Δy) <= polomer * polomer;
			}

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v elipse
			 * pootočenej v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi zadaných poloosí. Nasledujúca metóda
			 * dovoľuje namiesto súradníc bodu použiť objekt:
			 * {@link #bodVElipse(Poloha, double, double) bodVElipse(Poloha
			 * objekt, double a, double b)}</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param a veľkosť hlavnej poloosi (na šírku elipsy)
			 * @param b veľkosť vedľajšej poloosi (na výšku elipsy)
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVElipse(double súradnicaBoduX, double súradnicaBoduY, double a, double b)
			{
				double x0 = súradnicaBoduX - aktuálneX;
				double y0 = súradnicaBoduY - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				/*!-!
				return (pow(x1 / (a /*+ polovicaHrúbkyPera* /), 2) +
					pow(y1 / (b /*+ polovicaHrúbkyPera* /), 2)) <= 1;
				*/

				x1 /= a; y1 /= b; return (x1 * x1 + y1 * y1) <= 1;
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVElipse(double, double,
			 * double, double) bodVElipse(x, y, a, b)}, len namiesto
			 * súradníc bodu je použitá poloha zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param a veľkosť hlavnej poloosi (na šírku elipsy)
			 * @param b veľkosť vedľajšej poloosi (na výšku elipsy)
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVElipse(Poloha objekt, double a, double b)
			{
				double x0 = objekt.polohaX() - aktuálneX;
				double y0 = objekt.polohaY() - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				/*!-!
				return (pow(x1 / (a /*+ polovicaHrúbkyPera* /), 2) +
					pow(y1 / (b /*+ polovicaHrúbkyPera* /), 2)) <= 1;
				*/

				x1 /= a; y1 /= b; return (x1 * x1 + y1 * y1) <= 1;
			}

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú vo štvorci so
			 * stredom na aktuálnej pozícii robota, rotovanom v smere robota
			 * a rozmerom udaným polomerom vpísanej kružnice. Nasledujúca
			 * metóda dovoľuje namiesto súradníc bodu použiť objekt: {@link 
			 * #bodVoŠtvorci(Poloha, double) bodVoŠtvorci(Poloha objekt, double
			 * polomer)}</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param polomer polomer kružnice vpísanej do štvorca so
			 *     stredom na aktuálnej pozícii robota
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVoŠtvorci(double súradnicaBoduX, double súradnicaBoduY, double polomer)
			{
				boolean jeV; double x1, y1;
				if (aktuálnyUhol % 90.0 == 0)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV = x1 >= -polomer && x1 <= polomer &&
						y1 >= -polomer && y1 <= polomer;
				}
				else
				{
					// x₀ = xm − x
					// y₀ = ym − y
					double x0 = súradnicaBoduX - aktuálneX;
					double y0 = súradnicaBoduY - aktuálneY;

					// x₁ = x₀ . cos(α) − y₀ . sin(α)
					// y₁ = x₀ . sin(α) + y₀ . cos(α)
					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					// x₁ > -polomer && y₁ > -polomer && x₁ < polomer && y₁ < polomer
					jeV = x1 >= -polomer && x1 <= polomer &&
						y1 >= -polomer && y1 <= polomer;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * polomer) / 2;
					double zy = min(abs(zaoblenieY), 2 * polomer) / 2;
					double Δzx = polomer - zx, Δzy = polomer - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVoŠtvorci(double, double, double) bodVoŠtvorci}.</p> */
			public boolean bodVoStvorci(double súradnicaBoduX, double súradnicaBoduY, double polomer) { return bodVoŠtvorci(súradnicaBoduX, súradnicaBoduY, polomer); }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVoŠtvorci(double,
			 * double, double) bodVoŠtvorci(x, y, polomer)}, len namiesto
			 * súradníc bodu je použitá poloha zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param polomer polomer kružnice vpísanej do štvorca so
			 *     stredom na aktuálnej pozícii robota
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVoŠtvorci(Poloha objekt, double polomer)
			{
				boolean jeV; double x1, y1;
				if (aktuálnyUhol % 90.0 == 0)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV = x1 >= -polomer && x1 <= polomer &&
						y1 >= -polomer && y1 <= polomer;
				}
				else
				{
					// x₀ = xm − x
					// y₀ = ym − y
					double x0 = objekt.polohaX() - aktuálneX;
					double y0 = objekt.polohaY() - aktuálneY;

					// x₁ = x₀ . cos(α) − y₀ . sin(α)
					// y₁ = x₀ . sin(α) + y₀ . cos(α)
					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					// x₁ > -polomer && y₁ > -polomer && x₁ < polomer && y₁ < polomer
					jeV = x1 >= -polomer && x1 <= polomer &&
						y1 >= -polomer && y1 <= polomer;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * polomer) / 2;
					double zy = min(abs(zaoblenieY), 2 * polomer) / 2;
					double Δzx = polomer - zx, Δzy = polomer - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVoŠtvorci(Poloha, double) bodVoŠtvorci}.</p> */
			public boolean bodVoStvorci(Poloha objekt, double polomer) { return bodVoŠtvorci(objekt, polomer); }

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v obdĺžniku
			 * so stredom na aktuálnej pozícii robota, rotovanom v smere
			 * robota a s rozmermi udanými ako poloosi vpísanej elipsy.
			 * Nasledujúca metóda dovoľuje namiesto súradníc bodu použiť
			 * objekt: {@link #bodVObdĺžniku(Poloha, double, double)
			 * bodVObdĺžniku(Poloha objekt, double a, double b)}</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param a veľkosť hlavnej poloosi (šírka vpísanej elipsy)
			 * @param b veľkosť vedľajšej poloosi (výška vpísanej elipsy)
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVObdĺžniku(double súradnicaBoduX,
				double súradnicaBoduY, double a, double b)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV = x1 >= -a && x1 <= a && y1 >= -b && y1 <= b;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV = x1 >= -b && x1 <= b && y1 >= -a && y1 <= a;
				}
				else
				{
					double x0 = súradnicaBoduX - aktuálneX;
					double y0 = súradnicaBoduY - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV = x1 >= -a && x1 <= a && y1 >= -b && y1 <= b;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * a) / 2;
					double zy = min(abs(zaoblenieY), 2 * b) / 2;
					double Δzx = a - zx, Δzy = b - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVObdĺžniku(double, double, double, double) bodVObdĺžniku}.</p> */
			public boolean bodVObdlzniku(double súradnicaBoduX, double súradnicaBoduY, double a, double b) { return bodVObdĺžniku(súradnicaBoduX, súradnicaBoduY, a, b); }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVObdĺžniku(double,
			 * double, double, double) bodVObdĺžniku(x, y, a, b)}, len
			 * namiesto súradníc bodu je použitá poloha zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param a veľkosť hlavnej poloosi (šírka vpísanej elipsy)
			 * @param b veľkosť vedľajšej poloosi (výška vpísanej elipsy)
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVObdĺžniku(Poloha objekt, double a, double b)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV = x1 >= -a && x1 <= a && y1 >= -b && y1 <= b;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV = x1 >= -b && x1 <= b && y1 >= -a && y1 <= a;
				}
				else
				{
					double x0 = objekt.polohaX() - aktuálneX;
					double y0 = objekt.polohaY() - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV = x1 >= -a && x1 <= a && y1 >= -b && y1 <= b;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * a) / 2;
					double zy = min(abs(zaoblenieY), 2 * b) / 2;
					double Δzx = a - zx, Δzy = b - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVObdĺžniku(Poloha, double, double) bodVObdĺžniku}.</p> */
			public boolean bodVObdlzniku(Poloha objekt, double a, double b) { return bodVObdĺžniku(objekt, a, b); }

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v hviezde so
			 * stredom na aktuálnej pozícii robota, rotovanej v smere robota
			 * a rozmerom udaným polomerom opísanej kružnice. Nasledujúca
			 * metóda dovoľuje namiesto súradníc bodu použiť objekt: {@link 
			 * #bodVHviezde(Poloha, double) bodVHviezde(Poloha objekt, double
			 * polomer)}</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param polomer polomer kružnice opísanej okolo hviezdy so
			 *     stredom na aktuálnej pozícii robota
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVHviezde(double súradnicaBoduX, double súradnicaBoduY, double polomer)
			{
				// return dajHviezdu(polomer).contains(
				// 	Svet.prepočítajX(súradnicaBoduX), Svet.prepočítajY(súradnicaBoduY));
				return this.hviezda.bodV(súradnicaBoduX,
					súradnicaBoduY, polomer);
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVHviezde(double,
			 * double, double) bodVHviezde(x, y, polomer)}, len namiesto
			 * súradníc bodu je použitá poloha zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param polomer polomer kružnice opísanej okolo hviezdy so
			 *     stredom na aktuálnej pozícii robota
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVHviezde(Poloha objekt, double polomer)
			{
				// return dajHviezdu(polomer).contains(
				// 	Svet.prepočítajX(objekt.polohaX()),
				// 	Svet.prepočítajY(objekt.polohaY()));
				return this.hviezda.bodV(objekt.polohaX(),
					objekt.polohaY(), polomer);
			}

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v zadanom
			 * tvare<sup>[1]</sup>. Nasledujúca metóda dovoľuje namiesto
			 * súradníc bodu použiť objekt: {@link #bodVTvare(Poloha,
			 * Shape) bodVTvare(Poloha objekt, Shape tvar)}.</p>
			 * 
			 * <p><small>[1] – podľa <a target="_blank"
			 * href="https://docs.oracle.com/javase/8/docs/api/java/awt/Shape.html#def_insideness"
			 * >definície prítomnosti bodu v tvare</a>
			 * (originál je v anglickom jazyku, preklad nasleduje).</small></p>
			 * 
			 * <p>Podľa definície je bod považovaný za ležiaci vo vnútri
			 * tvaru vtedy a len vtedy, ak:</p>
			 * 
			 * <ul>
			 * <li>leží úplne vo vnútri hraníc tvaru,</li>
			 * <li>alebo leží presne na hranici tvaru a priestor
			 * priliehajúci k bodu v stúpajúcom smere osi x je úplne
			 * umiestnený vo vnútri hraníc tvaru,</li>
			 * <li>alebo leží presne na horizontálnom segmente tvaru
			 * a priestor priliehajúci k bodu v stúpajúcom smere osi y je
			 * úplne umiestnený vo vnútri hraníc tvaru.</li>
			 * </ul>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param tvar tvar použitý na overenie
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see Oblasť#bodV(double, double)
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 */
			public boolean bodVTvare(double súradnicaBoduX, double súradnicaBoduY, Shape tvar)
			{
				return tvar.contains(Svet.prepočítajX(súradnicaBoduX),
					Svet.prepočítajY(súradnicaBoduY));
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVTvare(double, double,
			 * Shape) bodVTvare(x, y, tvar)}, len namiesto súradníc bodu
			 * je použitá poloha zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param tvar tvar použitý na overenie
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see Oblasť#bodV(Poloha)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 */
			public boolean bodVTvare(Poloha objekt, Shape tvar)
			{
				return tvar.contains(Svet.prepočítajX(objekt.polohaX()),
					Svet.prepočítajY(objekt.polohaY()));
			}

			// Detekcia bodov v tvaroch generovaných podľa veľkosti robota

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v kruhu
			 * s polomerom {@linkplain #veľkosť(double) veľkosti} robota
			 * a stredom na aktuálnej pozícii robota. Nasledujúca metóda
			 * dovoľuje namiesto súradníc bodu použiť objekt:
			 * {@link #bodVKruhu(Poloha) bodVKruhu(Poloha objekt)}</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVElipse(double, double, double)
			 * @see #bodVoŠtvorci(double, double)
			 * @see #bodVObdĺžniku(double, double, double)
			 * @see #bodVHviezde(double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVKruhu(double súradnicaBoduX, double súradnicaBoduY)
			{
				/*
				return (pow(súradnicaBoduX - aktuálneX, 2) +
					pow(súradnicaBoduY - aktuálneY, 2)) <=
						// pow(veľkosť, 2);
						(veľkosť * veľkosť);
				*/
				double Δx = súradnicaBoduX - aktuálneX;
				double Δy = súradnicaBoduY - aktuálneY;
				return (Δx * Δx + Δy * Δy) <= veľkosť * veľkosť;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVKruhu(double, double) bodVKruhu}.</p> */
			public boolean bodV(double súradnicaBoduX, double súradnicaBoduY) { return bodVKruhu(súradnicaBoduX, súradnicaBoduY); }

			// /**
				//  * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v kruhu
				//  * s polomerom {@linkplain #veľkosť(double) veľkosti} robota
				//  * a stredom na aktuálnej pozícii robota.</p>
				//  * 
				//  * @param bod súradnice bodu
				//  * @return {@code valtrue} – áno; {@code valfalse} – nie
				//  * 
				//  * @see #bodVElipse(Point2D, double)
				//  * @see #bodVoŠtvorci(Point2D)
				//  * @see #bodVObdĺžniku(Point2D, double)
				//  * @see #bodVCeste(Point2D)
				//  * @see #bodVOblasti(Point2D, Area)
				//  * @see #bodVTvare(Point2D, Shape)
				//  */
				// public boolean bodVKruhu(Point2D bod)
				// {
				// 	/*
				// 	return (pow(bod.getX() - aktuálneX, 2) +
				// 		pow(bod.getY() - aktuálneY, 2)) <=
				// 			// pow(veľkosť, 2);
				// 			(veľkosť * veľkosť);
				// 	*/
				// 	double Δx = bod.getX() - aktuálneX;
				// 	double Δy = bod.getY() - aktuálneY;
				// 	return (Δx * Δx + Δy * Δy) <= veľkosť * veľkosť;
				// }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVKruhu(double, double)
			 * bodVKruhu(x, y)}, len namiesto súradníc bodu je použitá
			 * poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVElipse(Poloha, double)
			 * @see #bodVoŠtvorci(Poloha)
			 * @see #bodVObdĺžniku(Poloha, double)
			 * @see #bodVHviezde(Poloha)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVKruhu(Poloha objekt)
			{
				/*
				return (pow(iný.aktuálneX - aktuálneX, 2) +
					pow(iný.aktuálneY - aktuálneY, 2)) <=
						// pow(veľkosť, 2);
						(veľkosť * veľkosť);
				*/
				double Δx = objekt.polohaX() - aktuálneX;
				double Δy = objekt.polohaY() - aktuálneY;
				return (Δx * Δx + Δy * Δy) <= veľkosť * veľkosť;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVKruhu(Poloha) bodVKruhu}.</p> */
			public boolean bodV(Poloha objekt) { return bodVKruhu(objekt); }

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v elipse
			 * pootočenej v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi odvodenými z {@linkplain #veľkosť(double)
			 * veľkosti} robota a zadaného pomeru strán. Nasledujúca metóda
			 * dovoľuje namiesto súradníc bodu použiť objekt:
			 * {@link #bodVElipse(Poloha, double) bodVElipse(Poloha objekt,
			 * double pomer)}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param pomer pomer šírky a výšky elipsy
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVKruhu(double, double)
			 * @see #bodVoŠtvorci(double, double)
			 * @see #bodVObdĺžniku(double, double, double)
			 * @see #bodVHviezde(double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVElipse(double súradnicaBoduX,
				double súradnicaBoduY, double pomer)
			{
				if (0 == pomer || 0 == veľkosť) return false;

				double x0 = súradnicaBoduX - aktuálneX;
				double y0 = súradnicaBoduY - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				/*!-!
				return (pow(x1 / (veľkosť * pomer), 2) +
					pow(y1 / veľkosť, 2)) <= 1;
				*/

				x1 /= (veľkosť * pomer);
				y1 /= veľkosť;
				return (x1 * x1 + y1 * y1) <= 1;
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVElipse(double, double,
			 * double) bodVElipse(x, y, pomer)}, len namiesto súradníc bodu
			 * je použitá poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param pomer pomer šírky a výšky elipsy
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVKruhu(Poloha)
			 * @see #bodVoŠtvorci(Poloha)
			 * @see #bodVObdĺžniku(Poloha, double)
			 * @see #bodVHviezde(Poloha)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVElipse(Poloha objekt, double pomer)
			{
				if (0 == pomer || 0 == veľkosť) return false;

				double x0 = objekt.polohaX() - aktuálneX;
				double y0 = objekt.polohaY() - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				/*!-!
				return (pow(x1 / (veľkosť * pomer), 2) +
					pow(y1 / veľkosť, 2)) <= 1;
				*/

				x1 /= (veľkosť * pomer);
				y1 /= veľkosť;
				return (x1 * x1 + y1 * y1) <= 1;
			}

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v elipse
			 * pootočenej v smere robota, so stredom na aktuálnej pozícii
			 * robota a s rozmermi odvodenými z {@linkplain #veľkosť(double)
			 * veľkosti} robota a vlastnosti robota {@link #pomer() pomer}.
			 * Nasledujúca metóda dovoľuje namiesto súradníc bodu použiť
			 * objekt: {@link #bodVElipse(Poloha, double) bodVElipse(Poloha
			 * objekt)}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVKruhu(double, double)
			 * @see #bodVoŠtvorci(double, double)
			 * @see #bodVObdĺžniku(double, double)
			 * @see #bodVHviezde(double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVElipse(double súradnicaBoduX,
				double súradnicaBoduY)
			{
				if (0 == pomerVeľkosti || 0 == veľkosť) return false;

				double x0 = súradnicaBoduX - aktuálneX;
				double y0 = súradnicaBoduY - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				x1 /= (veľkosť * pomerVeľkosti);
				y1 /= veľkosť;
				return (x1 * x1 + y1 * y1) <= 1;
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVElipse(double,
			 * double) bodVElipse(x, y)}, len namiesto súradníc bodu je
			 * použitá poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVKruhu(Poloha)
			 * @see #bodVoŠtvorci(Poloha)
			 * @see #bodVObdĺžniku(Poloha)
			 * @see #bodVHviezde(Poloha)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVElipse(Poloha objekt)
			{
				if (0 == pomerVeľkosti || 0 == veľkosť) return false;

				double x0 = objekt.polohaX() - aktuálneX;
				double y0 = objekt.polohaY() - aktuálneY;

				// double polovicaHrúbkyPera = polomerPera / 2;

				double α = toRadians(90 - aktuálnyUhol);
				double x1 = rotovanéXRad(x0, y0, α);
				double y1 = rotovanéYRad(x0, y0, α);

				x1 /= (veľkosť * pomerVeľkosti);
				y1 /= veľkosť;
				return (x1 * x1 + y1 * y1) <= 1;
			}

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú vo štvorci so
			 * stredom na aktuálnej pozícii robota, rotovanom v smere robota
			 * a rozmerom podľa {@linkplain #veľkosť(double) veľkosti}
			 * robota. Nasledujúca metóda dovoľuje namiesto súradníc bodu
			 * použiť objekt:
			 * {@link #bodVoŠtvorci(Poloha) bodVoŠtvorci(Poloha objekt)}</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVKruhu(double, double)
			 * @see #bodVElipse(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double)
			 * @see #bodVHviezde(double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVoŠtvorci(double súradnicaBoduX,
				double súradnicaBoduY)
			{
				boolean jeV; double x1, y1;
				if (aktuálnyUhol % 90.0 == 0)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV = x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else
				{
					// x₀ = xm − x
					// y₀ = ym − y
					double x0 = súradnicaBoduX - aktuálneX;
					double y0 = súradnicaBoduY - aktuálneY;

					// x₁ = x₀ . cos(α) − y₀ . sin(α)
					// y₁ = x₀ . sin(α) + y₀ . cos(α)
					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					// x₁ > -veľkosť && y₁ > -veľkosť && x₁ < veľkosť && y₁ < veľkosť
					jeV = x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = veľkosť - zx, Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVoŠtvorci(double, double) bodVoŠtvorci}.</p> */
			public boolean bodVoStvorci(double súradnicaBoduX, double súradnicaBoduY) { return bodVoŠtvorci(súradnicaBoduX, súradnicaBoduY); }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVoŠtvorci(double,
			 * double) bodVoŠtvorci(x, y)}, len namiesto súradníc bodu je
			 * použitá poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVKruhu(Poloha)
			 * @see #bodVElipse(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double)
			 * @see #bodVHviezde(Poloha)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVoŠtvorci(Poloha objekt)
			{
				boolean jeV; double x1, y1;
				if (aktuálnyUhol % 90.0 == 0)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV = x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else
				{
					// x₀ = xm − x
					// y₀ = ym − y
					double x0 = objekt.polohaX() - aktuálneX;
					double y0 = objekt.polohaY() - aktuálneY;

					// x₁ = x₀ . cos(α) − y₀ . sin(α)
					// y₁ = x₀ . sin(α) + y₀ . cos(α)
					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					// x₁ > -veľkosť && y₁ > -veľkosť && x₁ < veľkosť && y₁ < veľkosť
					jeV = x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = veľkosť - zx, Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVoŠtvorci(Poloha) bodVoŠtvorci}.</p> */
			public boolean bodVoStvorci(Poloha objekt) { return bodVoŠtvorci(objekt); }

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v obdĺžniku
			 * so stredom na aktuálnej pozícii robota, rotovanom v smere
			 * robota a s rozmermi podľa {@linkplain #veľkosť(double)
			 * veľkosti} robota a zadaného pomeru strán. Nasledujúca metóda
			 * dovoľuje namiesto súradníc bodu použiť objekt: {@link 
			 * #bodVObdĺžniku(Poloha, double) bodVObdĺžniku(objekt, pomer)}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param pomer pomer šírky a výšky obdĺžnika
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVKruhu(double, double)
			 * @see #bodVElipse(double, double, double)
			 * @see #bodVoŠtvorci(double, double)
			 * @see #bodVHviezde(double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVObdĺžniku(double súradnicaBoduX,
				double súradnicaBoduY, double pomer)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV =
						x1 >= -(veľkosť * pomer) && x1 <= (veľkosť * pomer) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV =
						x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -(veľkosť * pomer) && y1 <= (veľkosť * pomer);
				}
				else
				{
					double x0 = súradnicaBoduX - aktuálneX;
					double y0 = súradnicaBoduY - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV =
						x1 >= -(veľkosť * pomer) && x1 <= (veľkosť * pomer) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť * pomer) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = (veľkosť * pomer) - zx, Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVObdĺžniku(double, double, double) bodVObdĺžniku}.</p> */
			public boolean bodVObdlzniku(double súradnicaBoduX, double súradnicaBoduY, double pomer) { return bodVObdĺžniku(súradnicaBoduX, súradnicaBoduY, pomer); }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVObdĺžniku(double,
			 * double, double) bodVObdĺžniku(x, y, pomer)}, len namiesto
			 * súradníc bodu je použitá poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param pomer pomer šírky a výšky obdĺžnika
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVKruhu(Poloha)
			 * @see #bodVElipse(Poloha, double)
			 * @see #bodVoŠtvorci(Poloha)
			 * @see #bodVHviezde(Poloha)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVObdĺžniku(Poloha objekt, double pomer)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV =
						x1 >= -(veľkosť * pomer) && x1 <= (veľkosť * pomer) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV =
						x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -(veľkosť * pomer) && y1 <= (veľkosť * pomer);
				}
				else
				{
					double x0 = objekt.polohaX() - aktuálneX;
					double y0 = objekt.polohaY() - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV =
						x1 >= -(veľkosť * pomer) && x1 <= (veľkosť * pomer) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť * pomer) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = (veľkosť * pomer) - zx, Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVObdĺžniku(Poloha, double) bodVObdĺžniku}.</p> */
			public boolean bodVObdlzniku(Poloha objekt, double pomer) { return bodVObdĺžniku(objekt, pomer); }

			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v obdĺžniku
			 * so stredom na aktuálnej pozícii robota, rotovanom v smere
			 * robota a s rozmermi podľa {@linkplain #veľkosť(double)
			 * veľkosti} robota a vlastnosti robota {@link #pomer() pomer}.
			 * Nasledujúca metóda dovoľuje namiesto súradníc bodu použiť
			 * objekt: {@link #bodVObdĺžniku(Poloha)
			 * bodVObdĺžniku(objekt)}.</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVKruhu(double, double)
			 * @see #bodVElipse(double, double)
			 * @see #bodVoŠtvorci(double, double)
			 * @see #bodVHviezde(double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVObdĺžniku(double súradnicaBoduX,
				double súradnicaBoduY)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV =
						x1 >= -(veľkosť * pomerVeľkosti) &&
						x1 <= (veľkosť * pomerVeľkosti) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = súradnicaBoduX - aktuálneX;
					y1 = súradnicaBoduY - aktuálneY;
					jeV =
						x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -(veľkosť * pomerVeľkosti) &&
						y1 <= (veľkosť * pomerVeľkosti);
				}
				else
				{
					double x0 = súradnicaBoduX - aktuálneX;
					double y0 = súradnicaBoduY - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV =
						x1 >= -(veľkosť * pomerVeľkosti) &&
						x1 <= (veľkosť * pomerVeľkosti) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť * pomerVeľkosti) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = (veľkosť * pomerVeľkosti) - zx,
						Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVObdĺžniku(double, double) bodVObdĺžniku}.</p> */
			public boolean bodVObdlzniku(double súradnicaBoduX, double súradnicaBoduY) { return bodVObdĺžniku(súradnicaBoduX, súradnicaBoduY); }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVObdĺžniku(double,
			 * double) bodVObdĺžniku(x, y)}, len namiesto súradníc bodu je
			 * použitá poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVKruhu(Poloha)
			 * @see #bodVElipse(Poloha, double)
			 * @see #bodVoŠtvorci(Poloha)
			 * @see #bodVHviezde(Poloha)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVObdĺžniku(Poloha objekt)
			{
				boolean jeV; double x1, y1;
				if (90.0 == aktuálnyUhol || 270.0 == aktuálnyUhol)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV =
						x1 >= -(veľkosť * pomerVeľkosti) &&
						x1 <= (veľkosť * pomerVeľkosti) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}
				else if (0.0 == aktuálnyUhol || 180.0 == aktuálnyUhol)
				{
					x1 = objekt.polohaX() - aktuálneX;
					y1 = objekt.polohaY() - aktuálneY;
					jeV =
						x1 >= -veľkosť && x1 <= veľkosť &&
						y1 >= -(veľkosť * pomerVeľkosti) &&
						y1 <= (veľkosť * pomerVeľkosti);
				}
				else
				{
					double x0 = objekt.polohaX() - aktuálneX;
					double y0 = objekt.polohaY() - aktuálneY;

					double α = toRadians(90 - aktuálnyUhol);
					x1 = rotovanéXRad(x0, y0, α);
					y1 = rotovanéYRad(x0, y0, α);

					jeV =
						x1 >= -(veľkosť * pomerVeľkosti) &&
						x1 <= (veľkosť * pomerVeľkosti) &&
						y1 >= -veľkosť && y1 <= veľkosť;
				}

				if (jeV && 0 != zaoblenieX && 0 != zaoblenieY)
				{
					double zx = min(abs(zaoblenieX), 2 * veľkosť * pomerVeľkosti) / 2;
					double zy = min(abs(zaoblenieY), 2 * veľkosť) / 2;
					double Δzx = (veľkosť * pomerVeľkosti) - zx,
						Δzy = veľkosť - zy;

					if (x1 > Δzx)
					{
						if (y1 > Δzy)
						{
							x1 -= Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 -= Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
					else if (x1 < -Δzx)
					{
						if (y1 > Δzy)
						{
							x1 += Δzx; y1 -= Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
						else if (y1 < -Δzy)
						{
							x1 += Δzx; y1 += Δzy;
							x1 /= zx; y1 /= zy;
							return (x1 * x1 + y1 * y1) <= 1;
						}
					}
				}

				return jeV;
			}

			/** <p><a class="alias"></a> Alias pre {@link #bodVObdĺžniku(Poloha) bodVObdĺžniku}.</p> */
			public boolean bodVObdlzniku(Poloha objekt) { return bodVObdĺžniku(objekt); }


			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v hviezde so
			 * stredom na aktuálnej pozícii robota, rotovanej v smere robota
			 * a rozmerom podľa {@linkplain #veľkosť(double) veľkosti}
			 * robota. Nasledujúca metóda dovoľuje namiesto súradníc bodu
			 * použiť objekt:
			 * {@link #bodVHviezde(Poloha) bodVHviezde(Poloha objekt)}</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVKruhu(double, double)
			 * @see #bodVElipse(double, double, double)
			 * @see #bodVoŠtvorci(double, double)
			 * @see #bodVObdĺžniku(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVHviezde(double súradnicaBoduX,
				double súradnicaBoduY)
			{
				// return dajHviezdu(veľkosť).contains(
				// 	Svet.prepočítajX(súradnicaBoduX), Svet.prepočítajY(súradnicaBoduY));
				return this.hviezda.bodV(súradnicaBoduX,
					súradnicaBoduY, veľkosť);
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVHviezde(double,
			 * double) bodVHviezde(x, y)}, len namiesto súradníc bodu je
			 * použitá poloha zadaného objektu…</p>
			 * 
			 * <p class="tip"><b>Informácia:</b> {@linkplain #mierka()
			 * Mierka} nemá na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVKruhu(Poloha)
			 * @see #bodVElipse(Poloha, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVHviezde(Poloha objekt)
			{
				// return dajHviezdu(veľkosť).contains(
				// 	Svet.prepočítajX(objekt.polohaX()),
				// 	Svet.prepočítajY(objekt.polohaY()));
				return this.hviezda.bodV(objekt.polohaX(),
					objekt.polohaY(), veľkosť);
			}


		// Kreslenie (pečiatkovanie) obrázkov

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa aktuálneho spôsobu
			 * kreslenia. Pozri aj {@link #spôsobKreslenia(int)
			 * spôsobKreslenia}. Predvolene to znamená obrázok rotovaný
			 * kolmo na aktuálny smer robota a vycentrovaný na aktuálnej
			 * polohe robota. Takže pri základných hodnotách robota, sa
			 * obrázok zobrazí vodorovne v strede plátna (pretože robot je
			 * na začiatku umiestnený v strede podlahy (v bode [0, 0])
			 * a smeruje hore (v uhle 90°)).
			 * Veľkosť kresleného obrázka je ovplyvňovaná {@linkplain 
			 * #mierka() mierkou robota}, ktorá je v predvolenom stave
			 * pomerom aktuálnej veľkosti robota a veľkosti robota, ktorú mal
			 * pri svojom vytvorení. Mierka sa dá upravovať metódou {@link 
			 * #mierka(double) mierka} a resetuje sa i pri zmene {@linkplain 
			 * #vlastnýTvar(String) vlastného obrázkového tvaru robota}.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor)
			{ obrázok(súbor, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String) obrázok}.</p> */
			public void obrazok(String súbor)
			{ obrázok(súbor, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa aktuálneho spôsobu
			 * kreslenia. Pozri aj {@link #spôsobKreslenia(int)
			 * spôsobKreslenia}. Predvolene to znamená obrázok rotovaný
			 * kolmo na aktuálny smer robota a vycentrovaný na aktuálnej
			 * polohe robota. Takže pri základných hodnotách robota, sa
			 * obrázok zobrazí vodorovne v strede plátna (pretože robot je
			 * na začiatku umiestnený v strede podlahy (v bode [0, 0])
			 * a smeruje hore (v uhle 90°)).</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor, double mierka)
			{ obrázok(súbor, spôsobKreslenia, mierka); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, double) obrázok}.</p> */
			public void obrazok(String súbor, double mierka)
			{ obrázok(súbor, spôsobKreslenia, mierka); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia.
			 * Veľkosť kresleného obrázka je ovplyvňovaná {@linkplain 
			 * #mierka() mierkou robota}, ktorá je v predvolenom stave
			 * pomerom aktuálnej veľkosti robota a veľkosti robota, ktorú mal
			 * pri svojom vytvorení. Mierka sa dá upravovať metódou {@link 
			 * #mierka(double) mierka} a resetuje sa i pri zmene {@linkplain 
			 * #vlastnýTvar(String) vlastného obrázkového tvaru robota}.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor, int spôsobKreslenia)
			{ obrázok(súbor, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, int) obrázok}.</p> */
			public void obrazok(String súbor, int spôsobKreslenia)
			{ obrázok(súbor, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Tieto metódy nesmú brať
			 * do úvahy priehľadnosť robota. Kolidovalo by to s inými
			 * mechanizmami programovacieho rámca. Je dosť iných spôsobov
			 * ako nakresliť spriehľadnaný obrázok. Napríklad nastaviť
			 * priehľadnosť inštancii triedy {@link Obrázok Obrázok} alebo
			 * kresliť obrázkový tvar spriehľadneného robota.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param mierka určuje mierku (zväčšenie alebo zmenšenie)
			 *     kreslenia obrázka; príklady: 1.0 – originálna veľkosť,
			 *     2.0 – dvojnásobná veľkosť, 0.5 – polovičná veľkosť
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor, int spôsobKreslenia,
				double mierka)
			{
				// ‼Pozor‼ Priehľadnosť sa nesmie meniť v rámci týchto
				// metód. Kolidovalo by to s priehľadnosťou robotov
				// (najmä pri kreslení obrázkových tvarov).

				Image obrázok = Obrázok.súborNaObrázok(súbor);

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				int šírkaObrázka = obrázok.getWidth(null);
				int výškaObrázka = obrázok.getHeight(null);
				if (šírkaObrázka < 0 || výškaObrázka < 0)
					throw new GRobotException("Obrázok „" + súbor +
						"“ je poškodený!", "imageFileBroken", súbor);

				int šírkaVMierke = šírkaObrázka;
				int výškaVMierke = výškaObrázka;

				AffineTransform transformácie;
				if (1.0 != mierka)
				{
					transformácie = grafikaAktívnehoPlátna.getTransform();
					grafikaAktívnehoPlátna.scale(mierka, mierka);
					prepočítanéX /= mierka;
					prepočítanéY /= mierka;
					šírkaVMierke *= mierka;
					výškaVMierke *= mierka;
				}
				else transformácie = null;

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX,
							aktuálneY - výškaVMierke,
							aktuálneX + šírkaVMierke,
							aktuálneY);

						// Obrázok zo súboru nikdy nebude inštanciou triedy
						// Obrázok, preto môžeme tento test vynechať.
						/*if (obrázok instanceof Obrázok)
							((Obrázok)obrázok).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else*/
							grafikaAktívnehoPlátna.drawImage(obrázok,
								(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaVMierke / 2.0),
							aktuálneY - (výškaVMierke / 2.0),
							aktuálneX + (šírkaVMierke / 2.0),
							aktuálneY + (výškaVMierke / 2.0));

						/*if (obrázok instanceof Obrázok)
							((Obrázok)obrázok).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else*/
							grafikaAktívnehoPlátna.drawImage(obrázok,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					grafikaAktívnehoPlátna.rotate(-α,
						prepočítanéX, prepočítanéY);

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0;
						double y0 = -výškaVMierke;
						double x1 =  šírkaVMierke;
						double y1 = 0;

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawImage(obrázok,
							(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						double x0 = -šírkaVMierke / 2.0;
						double y0 = -výškaVMierke / 2.0;
						double x1 =  šírkaVMierke / 2.0;
						double y1 =  výškaVMierke / 2.0;

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawImage(obrázok,
							(int)(prepočítanéX - (šírkaObrázka / 2.0)),
							(int)(prepočítanéY - (výškaObrázka / 2.0)),
							null);
					}

					if (1.0 == mierka)
						grafikaAktívnehoPlátna.rotate(α,
							prepočítanéX, prepočítanéY);
				}

				if (1.0 != mierka)
					grafikaAktívnehoPlátna.setTransform(transformácie);

				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, int, double) obrázok}.</p> */
			public void obrazok(String súbor, int spôsobKreslenia,
				double mierka)
			{ obrázok(súbor, spôsobKreslenia, mierka); }

			/**
			 * <p>Nakreslí obrázok v {@linkplain #mierka() mierke robota} na
			 * pozícii robota podľa aktuálneho spôsobu kreslenia s vysunutím
			 * stredu otáčania o zadané odchýlky Δx a Δy. Pozri aj {@link 
			 * #spôsobKreslenia(int) spôsobKreslenia}.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor, double Δx, double Δy)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, double, double) obrázok}.</p> */
			public void obrazok(String súbor, double Δx, double Δy)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/**
			 * <p>Nakreslí obrázok v {@linkplain #mierka() mierke robota} na
			 * pozícii robota podľa zadaného spôsobu kreslenia s vysunutím
			 * stredu otáčania o zadané odchýlky Δx a Δy.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor, int spôsobKreslenia,
				double Δx, double Δy)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, int, double, double) obrázok}.</p> */
			public void obrazok(String súbor, int spôsobKreslenia,
				double Δx, double Δy)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }


			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa aktuálneho spôsobu
			 * kreslenia s vysunutím stredu otáčania o zadané odchýlky Δx a Δy.
			 * Pozri aj {@link #spôsobKreslenia(int) spôsobKreslenia}.
			 * Odchýlky otáčania sú upravené podľa mierky.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @param mierka určuje mierku (zväčšenie alebo zmenšenie)
			 *     kreslenia obrázka; príklady: 1.0 – originálna veľkosť,
			 *     2.0 – dvojnásobná veľkosť, 0.5 – polovičná veľkosť
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 * @see GRobot#obrázok(String, int, double, double, double)
			 */
			public void obrázok(String súbor, double Δx, double Δy,
				double mierka)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, mierka); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, double, double, double) obrázok}.</p> */
			public void obrazok(String súbor, double Δx, double Δy,
				double mierka)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, mierka); }


			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia s vysunutím stredu otáčania o zadané odchýlky Δx a Δy.
			 * Odchýlky otáčania sú upravené podľa zadanej mierky.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Tieto metódy nesmú brať
			 * do úvahy priehľadnosť robota. Kolidovalo by to s inými
			 * mechanizmami programovacieho rámca. Je dosť iných spôsobov
			 * ako nakresliť spriehľadnaný obrázok. Napríklad nastaviť
			 * priehľadnosť inštancii triedy {@link Obrázok Obrázok} alebo
			 * kresliť obrázkový tvar spriehľadneného robota.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @param mierka určuje mierku (zväčšenie alebo zmenšenie)
			 *     kreslenia obrázka; príklady: 1.0 – originálna veľkosť,
			 *     2.0 – dvojnásobná veľkosť, 0.5 – polovičná veľkosť
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 */
			public void obrázok(String súbor, int spôsobKreslenia,
				double Δx, double Δy, double mierka)
			{
				// ‼Pozor‼ Priehľadnosť sa nesmie meniť v rámci týchto
				// metód. Kolidovalo by to s priehľadnosťou robotov
				// (najmä pri kreslení obrázkových tvarov).

				Image obrázok = Obrázok.súborNaObrázok(súbor);

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				int šírkaObrázka = obrázok.getWidth(null);
				int výškaObrázka = obrázok.getHeight(null);
				if (šírkaObrázka < 0 || výškaObrázka < 0)
					throw new GRobotException("Obrázok „" + súbor +
						"“ je poškodený!", "imageFileBroken", súbor);

				int šírkaVMierke = šírkaObrázka;
				int výškaVMierke = výškaObrázka;

				AffineTransform transformácie =
					grafikaAktívnehoPlátna.getTransform();

				if (1.0 != mierka)
				{
					grafikaAktívnehoPlátna.scale(mierka, mierka);
					prepočítanéX /= mierka;
					prepočítanéY /= mierka;
					šírkaVMierke *= mierka;
					výškaVMierke *= mierka;
				}

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX,
							aktuálneY - výškaVMierke,
							aktuálneX + šírkaVMierke,
							aktuálneY);

						// Obrázok zo súboru nikdy nebude inštanciou triedy
						// Obrázok, preto môžeme tento test vynechať.
						/*if (obrázok instanceof Obrázok)
							((Obrázok)obrázok).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else*/
							grafikaAktívnehoPlátna.drawImage(obrázok,
								(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaVMierke / 2.0),
							aktuálneY - (výškaVMierke / 2.0),
							aktuálneX + (šírkaVMierke / 2.0),
							aktuálneY + (výškaVMierke / 2.0));

						/*if (obrázok instanceof Obrázok)
							((Obrázok)obrázok).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else*/
							grafikaAktívnehoPlátna.drawImage(obrázok,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (1.0 == mierka)
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + Δx, prepočítanéY - Δy);
					else
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + (Δx / mierka),
							prepočítanéY - (Δy / mierka));

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0;
						double y0 = -výškaVMierke;
						double x1 =  šírkaVMierke;
						double y1 = 0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawImage(obrázok,
							(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						double x0 = -šírkaVMierke / 2.0;
						double y0 = -výškaVMierke / 2.0;
						double x1 =  šírkaVMierke / 2.0;
						double y1 =  výškaVMierke / 2.0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawImage(obrázok,
							(int)(prepočítanéX - (šírkaObrázka / 2.0)),
							(int)(prepočítanéY - (výškaObrázka / 2.0)),
							null);
					}
				}

				grafikaAktívnehoPlátna.setTransform(transformácie);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, int, double, double, double) obrázok}.</p> */
			public void obrazok(String súbor, int spôsobKreslenia,
				double Δx, double Δy, double mierka)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, mierka); }


			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa aktuálneho spôsobu
			 * kreslenia. Pozri aj {@link #spôsobKreslenia(int)
			 * spôsobKreslenia}. Predvolene to znamená obrázok rotovaný
			 * kolmo na aktuálny smer robota a vycentrovaný na aktuálnej
			 * polohe robota. Takže pri základných hodnotách robota, sa
			 * obrázok zobrazí vodorovne v strede plátna (pretože robot je
			 * na začiatku umiestnený v strede podlahy (v bode [0, 0])
			 * a smeruje hore (v uhle 90°)).
			 * Veľkosť kresleného obrázka je ovplyvňovaná {@linkplain 
			 * #mierka() mierkou robota}, ktorá je v predvolenom stave
			 * pomerom aktuálnej veľkosti robota a veľkosti robota, ktorú mal
			 * pri svojom vytvorení. Mierka sa dá upravovať metódou {@link 
			 * #mierka(double) mierka} a resetuje sa i pri zmene {@linkplain 
			 * #vlastnýTvar(String) vlastného obrázkového tvaru robota}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 */
			public void obrázok(Image obrázok)
			{ obrázok(obrázok, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image) obrázok}.</p> */
			public void obrazok(Image obrázok)
			{ obrázok(obrázok, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa aktuálneho spôsobu
			 * kreslenia. Pozri aj {@link #spôsobKreslenia(int)
			 * spôsobKreslenia}. Predvolene to znamená obrázok rotovaný
			 * kolmo na aktuálny smer robota a vycentrovaný na aktuálnej
			 * polohe robota. Takže pri základných hodnotách robota, sa
			 * obrázok zobrazí vodorovne v strede plátna (pretože robot je
			 * na začiatku umiestnený v strede podlahy (v bode [0, 0])
			 * a smeruje hore (v uhle 90°)).</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 */
			public void obrázok(Image obrázok, double mierka)
			{ obrázok(obrázok, spôsobKreslenia, mierka); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, double) obrázok}.</p> */
			public void obrazok(Image obrázok, double mierka)
			{ obrázok(obrázok, spôsobKreslenia, mierka); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia. Obrázok je všeobecný typ {@link Image Image}, za
			 * ktorý môže byť dosadený aj objekt typu {@link Obrázok
			 * Obrázok}.
			 * Veľkosť kresleného obrázka je ovplyvňovaná {@linkplain 
			 * #mierka() mierkou robota}, ktorá je v predvolenom stave
			 * pomerom aktuálnej veľkosti robota a veľkosti robota, ktorú mal
			 * pri svojom vytvorení. Mierka sa dá upravovať metódou {@link 
			 * #mierka(double) mierka} a resetuje sa i pri zmene {@linkplain 
			 * #vlastnýTvar(String) vlastného obrázkového tvaru robota}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Tieto metódy nesmú brať
			 * do úvahy priehľadnosť robota. Kolidovalo by to s inými
			 * mechanizmami programovacieho rámca. Je dosť iných spôsobov
			 * ako nakresliť spriehľadnaný obrázok. Napríklad nastaviť
			 * priehľadnosť inštancii triedy {@link Obrázok Obrázok} alebo
			 * kresliť obrázkový tvar spriehľadneného robota.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, int spôsobKreslenia)
			{ obrázok(obrázok, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, int) obrázok}.</p> */
			public void obrazok(Image obrázok, int spôsobKreslenia)
			{ obrázok(obrázok, spôsobKreslenia, 0, 0, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia. Obrázok je všeobecný typ {@link Image Image}, za
			 * ktorý môže byť dosadený aj objekt typu {@link Obrázok
			 * Obrázok}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param mierka určuje mierku (zväčšenie alebo zmenšenie)
			 *     kreslenia obrázka; príklady: 1.0 – originálna veľkosť,
			 *     2.0 – dvojnásobná veľkosť, 0.5 – polovičná veľkosť
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, int spôsobKreslenia,
				double mierka)
			{
				// ‼Pozor‼ Priehľadnosť sa nesmie meniť v rámci týchto
				// metód. Kolidovalo by to s priehľadnosťou robotov
				// (najmä pri kreslení obrázkových tvarov).

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				int šírkaObrázka = obrázok.getWidth(null);
				int výškaObrázka = obrázok.getHeight(null);
				if (šírkaObrázka < 0 || výškaObrázka < 0)
					throw new GRobotException("Obrázok je poškodený!",
						"imageBroken");

				int šírkaVMierke = šírkaObrázka;
				int výškaVMierke = výškaObrázka;

				AffineTransform transformácie;
				if (1.0 != mierka)
				{
					transformácie = grafikaAktívnehoPlátna.getTransform();
					grafikaAktívnehoPlátna.scale(mierka, mierka);
					prepočítanéX /= mierka;
					prepočítanéY /= mierka;
					šírkaVMierke *= mierka;
					výškaVMierke *= mierka;
				}
				else transformácie = null;

				Image relevantný = Obrázok.dajRelevantnýRaster(obrázok);

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX,
							aktuálneY - výškaVMierke,
							aktuálneX + šírkaVMierke,
							aktuálneY);

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNa(
								(int)prepočítanéX, (int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaVMierke / 2.0),
							aktuálneY - (výškaVMierke / 2.0),
							aktuálneX + (šírkaVMierke / 2.0),
							aktuálneY + (výškaVMierke / 2.0));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNaStred(
								(int)prepočítanéX, (int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					grafikaAktívnehoPlátna.rotate(-α,
						prepočítanéX, prepočítanéY);

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0;
						double y0 = -výškaVMierke;
						double x1 =  šírkaVMierke;
						double y1 = 0;

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNa(
								(int)prepočítanéX, (int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						double x0 = -šírkaVMierke / 2.0;
						double y0 = -výškaVMierke / 2.0;
						double x1 =  šírkaVMierke / 2.0;
						double y1 =  výškaVMierke / 2.0;

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).kresliNaStred(
								(int)prepočítanéX, (int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}

					if (1.0 == mierka)
						grafikaAktívnehoPlátna.rotate(α,
							prepočítanéX, prepočítanéY);
				}

				if (1.0 != mierka)
					grafikaAktívnehoPlátna.setTransform(transformácie);

				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, int, double ) obrázok}.</p> */
			public void obrazok(Image obrázok, int spôsobKreslenia,
				double mierka)
			{ obrázok(obrázok, spôsobKreslenia, mierka); }

			/**
			 * <p>Nakreslí obrázok v {@linkplain #mierka() mierke robota} na
			 * pozícii robota podľa aktuálneho spôsobu kreslenia s vysunutím
			 * stredu otáčania o zadané odchýlky Δx a Δy.
			 * Pozri aj {@link #spôsobKreslenia(int) spôsobKreslenia}. Obrázok
			 * je všeobecný typ {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, double Δx, double Δy)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, double, double) obrázok}.</p> */
			public void obrazok(Image obrázok, double Δx, double Δy)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }


			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa aktuálneho spôsobu
			 * kreslenia s vysunutím stredu otáčania o zadané odchýlky Δx a Δy.
			 * Pozri aj {@link #spôsobKreslenia(int) spôsobKreslenia}.
			 * Obrázok je všeobecný typ {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.
			 * Odchýlky otáčania sú upravené podľa mierky.</p>
			 * 
			 * <p>Komplexný interaktívny príklad použitia tejto metódy je
			 * v opise metódy {@link #obrázok(java.awt.Image, int, double,
			 * double, double) obrázok(obrázok, spôsobKreslenia, Δx, Δy,
			 * mierka)}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @param mierka určuje mierku (zväčšenie alebo zmenšenie)
			 *     kreslenia obrázka; príklady: 1.0 – originálna veľkosť,
			 *     2.0 – dvojnásobná veľkosť, 0.5 – polovičná veľkosť
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, double Δx, double Δy,
				double mierka)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, mierka); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, double, double, double) obrázok}.</p> */
			public void obrazok(Image obrázok, double Δx, double Δy,
				double mierka)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, mierka); }

			/**
			 * <p>Nakreslí obrázok v {@linkplain #mierka() mierke robota} na
			 * pozícii robota podľa zadaného spôsobu kreslenia s vysunutím
			 * stredu otáčania o zadané odchýlky Δx a Δy.
			 * Obrázok je všeobecný typ {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, int spôsobKreslenia,
				double Δx, double Δy)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, int, double, double) obrázok}.</p> */
			public void obrazok(Image obrázok, int spôsobKreslenia,
				double Δx, double Δy)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, (veľkosť / pôvodnáVeľkosť) *
				(pomerVeľkosti / pôvodnýPomer), veľkosť / pôvodnáVeľkosť); }

			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia s vysunutím stredu otáčania o zadané odchýlky Δx a Δy.
			 * Obrázok je všeobecný typ {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.
			 * Odchýlky otáčania sú upravené podľa mierky.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>Nasledujúci príklad ukazuje možnosti transformácie obrázkov
			 * s pomocou programovacieho rámca GRobot. Príklad je interaktívny.
			 * Po preložení a spustení sú na obrazovke zobrazené informácie
			 * o tom, ako je možné zobrazený obrázok transformovať, pričom
			 * používateľ rýchlo zistí, že obrázkom (a jeho transformáciami)
			 * vlastne na plátno kreslí.</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdimport} knižnica.*;

				{@code kwdpublic} {@code typeclass} TestRotovaniaObrázkov {@code kwdextends} {@link GRobot GRobot}
				{
					{@code comm// Posunutie stredu rotácie a mierka obrázka.}
					{@code kwdprivate} {@code typedouble} Δx = {@code num0.0}, Δy = {@code num0.0}, mierka = {@code num1.0};

					{@code comm// Obrázok, ktorý bude transformovaný.}
					{@code kwdprivate} {@link Obrázok Obrázok} obrázok;

					{@code comm// Metóda na „vyrobenie“ obsahu obrázka.}
					{@code kwdprivate} {@code typevoid} vyrobObrázok()
					{
						obrázok = {@code kwdnew} {@link Obrázok#Obrázok(int, int) Obrázok}({@code num300}, {@code num200});
						{@link GRobot#kresliNaObrázok(Obrázok) kresliNaObrázok}(obrázok);

						{@link GRobot#farba(int, int, int, int) farba}({@code num199}, {@code num201}, {@code num203}, {@code num5});
						{@code kwdfor} ({@code typedouble} i = {@code num1.0}; i &gt; {@code num0.0}; i &#45;= {@code num0.03})
							{@link GRobot#vyplňElipsu(double, double) vyplňElipsu}({@code num150.0} * i, {@code num100.0} * i);

						{@link GRobot#farba(int, int, int) farba}({@code num99}, {@code num101}, {@code num103});
						{@link GRobot#nekresliTvary() nekresliTvary}();

						{@link GRobot#písmo(String, double) písmo}({@code srg"Arial"}, {@code num32});
						{@link GRobot#skočNa(double, double) skočNa}({@code num0}, {@code num10});
						{@link Oblasť Oblasť} text1 = {@code kwdnew} {@link Oblasť#Oblasť(java.awt.Shape) Oblasť}({@link GRobot#text(String) text}({@code srg"Text v elipse"}));
						{@link GRobot#vyplňOblasť(java.awt.geom.Area) vyplňOblasť}(text1);

						{@link GRobot#písmo(String, double) písmo}({@code srg"Arial"}, {@code num16});
						{@link GRobot#skočNa(double, double) skočNa}({@code num0}, &#45;{@code num20});
						{@link Oblasť Oblasť} text2 = {@code kwdnew} {@link Oblasť#Oblasť(java.awt.Shape) Oblasť}({@link GRobot#text(String) text}({@code srg"na testovanie rotácie obrázka…"}));
						{@link GRobot#vyplňOblasť(java.awt.geom.Area) vyplňOblasť}(text2);
						obrázok.{@link Obrázok#rozmaž() rozmaž}();

						{@link GRobot#farba(Color) farba}({@link Farebnosť#čierna čierna});

						{@link GRobot#písmo(String, double) písmo}({@code srg"Arial"}, {@code num32});
						{@link GRobot#skočNa(double, double) skočNa}({@code num0}, {@code num10});
						{@link GRobot#vyplňOblasť(java.awt.geom.Area) vyplňOblasť}(text1);

						{@link GRobot#písmo(String, double) písmo}({@code srg"Arial"}, {@code num16});
						{@link GRobot#skočNa(double, double) skočNa}({@code num0}, &#45;{@code num20});
						{@link GRobot#vyplňOblasť(java.awt.geom.Area) vyplňOblasť}(text2);

						{@link GRobot#kresliNaPodlahu() kresliNaPodlahu}();
						{@link GRobot#kresliTvary() kresliTvary}();
					}

					{@code comm// Konštruktor.}
					{@code kwdprivate} TestRotovaniaObrázkov()
					{
						{@code valsuper}({@code num600}, {@code num400});
						{@link GRobot#skry() skry}();

						vyrobObrázok();

						{@link Svet Svet}.{@link Svet#vypíšRiadok(Object...) vypíšRiadok}({@code srg"Ťahaním myšou (alebo klikom) sa dá dosiahnuť:"});
						{@link Svet Svet}.{@link Svet#vypíšRiadok(Object...) vypíšRiadok}({@code srg"             Shift – vysunutie stredu otáčania"});
						{@link Svet Svet}.{@link Svet#vypíšRiadok(Object...) vypíšRiadok}({@code srg"           Control – zmena mierky obrázka"});
						{@link Svet Svet}.{@link Svet#vypíšRiadok(Object...) vypíšRiadok}({@code srg"               Alt – rotácia obrázka"});
						{@link Svet Svet}.{@link Svet#vypíšRiadok(Object...) vypíšRiadok}({@code srg"«bez modifikátora» – presunutie obrázka"});

						kreslenie();
					}

					{@code comm// Metóda, ktorá pridáva transformovaný obrázok ku kresbe na plátne.}
					{@code kwdpublic} {@code typevoid} kreslenie()
					{
						{@link Bod Bod} bod = {@link GRobot#poloha() poloha}();
						{@link GRobot#obrázok(java.awt.Image, double, double, double) obrázok}(obrázok, Δx, Δy, mierka);
						{@link GRobot#farba(Color) farba}({@link Farebnosť#modrá modrá});
						{@link GRobot#kruh(double) kruh}({@code num4});
						{@link GRobot#skoč(double, double) skoč}(Δx, Δy);
						{@link GRobot#farba(Color) farba}({@link Farebnosť#červená červená});
						{@link GRobot#kruh(double) kruh}({@code num3});
						{@link GRobot#skočNa(Poloha) skočNa}(bod);
						{@link GRobot#farba(Color) farba}({@link Farebnosť#čierna čierna});
					}

					{@code comm// Reakcia na kliknutie.}
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#klik() klik}()
					{
						{@link GRobot#ťahanieMyšou() ťahanieMyšou}();
					}

					{@code comm// Reakcia na ťahanie myšou.}
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#ťahanieMyšou() ťahanieMyšou}()
					{
						{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#myš() myš}().{@link java.awt.event.InputEvent#isShiftDown() isShiftDown}())
						{
							Δx = {@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#polohaMyšiX() polohaMyšiX}() &#45; {@link GRobot#polohaX() polohaX}();
							Δy = {@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#polohaMyšiY() polohaMyšiY}() &#45; {@link GRobot#polohaY() polohaY}();
						}
						{@code kwdelse} {@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#myš() myš}().{@link java.awt.event.InputEvent#isControlDown() isControlDown}())
						{
							mierka = {@link GRobot#vzdialenosťKMyši() vzdialenosťKMyši}() / {@code num125.0};
						}
						{@code kwdelse} {@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#myš() myš}().{@link java.awt.event.InputEvent#isAltDown() isAltDown}())
						{
							{@link Bod Bod} bod = {@link GRobot#poloha() poloha}();
							{@link GRobot#skoč(double, double) skoč}(Δx, Δy);
							{@link GRobot#otočNaMyš() otočNaMyš}();
							{@link GRobot#skočNa(Poloha) skočNa}(bod);
						}
						{@code kwdelse}
						{
							{@link GRobot#skočNaMyš() skočNaMyš}();
						}

						kreslenie();
					}

					{@code comm// Hlavná metóda.}
					{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}[] args)
					{
						{@code kwdnew} TestRotovaniaObrázkov();
					}
				}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <p><image>interaktivnaZmenaObrazka.png<alt/>Výsledok kreslenia
			 * transformáciami generovaného obrázka.</image>Ukážka možného
			 * výsledku experimentovania s obrázkom.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Tieto metódy nesmú brať
			 * do úvahy priehľadnosť robota. Kolidovalo by to s inými
			 * mechanizmami programovacieho rámca. Je dosť iných spôsobov
			 * ako nakresliť spriehľadnaný obrázok. Napríklad nastaviť
			 * priehľadnosť inštancii triedy {@link Obrázok Obrázok} alebo
			 * kresliť obrázkový tvar spriehľadneného robota.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @param mierka určuje mierku (zväčšenie alebo zmenšenie)
			 *     kreslenia obrázka; príklady: 1.0 – originálna veľkosť,
			 *     2.0 – dvojnásobná veľkosť, 0.5 – polovičná veľkosť
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, int spôsobKreslenia,
				double Δx, double Δy, double mierka)
			{
				// ‼Pozor‼ Priehľadnosť sa nesmie meniť v rámci týchto
				// metód. Kolidovalo by to s priehľadnosťou robotov
				// (najmä pri kreslení obrázkových tvarov).

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				int šírkaObrázka = obrázok.getWidth(null);
				int výškaObrázka = obrázok.getHeight(null);
				if (šírkaObrázka < 0 || výškaObrázka < 0)
					throw new GRobotException("Obrázok je poškodený!",
						"imageBroken");

				int šírkaVMierke = šírkaObrázka;
				int výškaVMierke = výškaObrázka;

				AffineTransform transformácie =
					grafikaAktívnehoPlátna.getTransform();

				if (1.0 != mierka)
				{
					grafikaAktívnehoPlátna.scale(mierka, mierka);
					prepočítanéX /= mierka;
					prepočítanéY /= mierka;
					šírkaVMierke *= mierka;
					výškaVMierke *= mierka;
				}

				Image relevantný = Obrázok.dajRelevantnýRaster(obrázok);

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX,
							aktuálneY - výškaVMierke,
							aktuálneX + šírkaVMierke,
							aktuálneY);

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX),
								(int)(prepočítanéY),
								null);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaVMierke / 2.0),
							aktuálneY - (výškaVMierke / 2.0),
							aktuálneX + (šírkaVMierke / 2.0),
							aktuálneY + (výškaVMierke / 2.0));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (1.0 == mierka)
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + Δx, prepočítanéY - Δy);
					else
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + (Δx / mierka),
							prepočítanéY - (Δy / mierka));

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0;
						double y0 = -výškaVMierke;
						double x1 =  šírkaVMierke;
						double y1 = 0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX),
								(int)(prepočítanéY),
								null);
					}
					else
					{
						double x0 = -šírkaVMierke / 2.0;
						double y0 = -výškaVMierke / 2.0;
						double x1 =  šírkaVMierke / 2.0;
						double y1 =  výškaVMierke / 2.0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}

				grafikaAktívnehoPlátna.setTransform(transformácie);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, int, double, double, double) obrázok}.</p> */
			public void obrazok(Image obrázok, int spôsobKreslenia,
				double Δx, double Δy, double mierka)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, mierka); }


			// Táto verzia nemôže byť definovaná, lebo koliduje s verziou
			// … Δx, Δy …
			// public void obrázok(String súbor, int spôsobKreslenia,
			// 	double mierkaX, double mierkaY)


			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia s vysunutím stredu otáčania o zadané odchýlky Δx a Δy.
			 * Odchýlky otáčania sú upravené podľa zadanej mierky.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Tieto metódy nesmú brať
			 * do úvahy priehľadnosť robota. Kolidovalo by to s inými
			 * mechanizmami programovacieho rámca. Je dosť iných spôsobov
			 * ako nakresliť spriehľadnaný obrázok. Napríklad nastaviť
			 * priehľadnosť inštancii triedy {@link Obrázok Obrázok} alebo
			 * kresliť obrázkový tvar spriehľadneného robota.</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť
			 *     vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @param mierkaX určuje mierku šírky obrázka
			 * @param mierkaY určuje mierku šírky obrázka
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo nebol
			 *     nájdený
			 * 
			 * @see Svet#priečinokObrázkov(String)
			 * @see GRobot#obrázok(String)
			 * @see GRobot#obrázok(String, double)
			 * @see GRobot#obrázok(String, double, double)
			 * @see GRobot#obrázok(String, double, double, double)
			 * @see GRobot#obrázok(String, int)
			 * @see GRobot#obrázok(String, int, double)
			 * @see GRobot#obrázok(String, int, double, double)
			 */
			public void obrázok(String súbor, int spôsobKreslenia,
				double Δx, double Δy, double mierkaX, double mierkaY)
			{
				// ‼Pozor‼ Priehľadnosť sa nesmie meniť v rámci týchto
				// metód. Kolidovalo by to s priehľadnosťou robotov
				// (najmä pri kreslení obrázkových tvarov).

				Image obrázok = Obrázok.súborNaObrázok(súbor);

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				int šírkaObrázka = obrázok.getWidth(null);
				int výškaObrázka = obrázok.getHeight(null);
				if (šírkaObrázka < 0 || výškaObrázka < 0)
					throw new GRobotException("Obrázok „" + súbor +
						"“ je poškodený!", "imageFileBroken", súbor);

				int šírkaVMierke = šírkaObrázka;
				int výškaVMierke = výškaObrázka;

				AffineTransform transformácie =
					grafikaAktívnehoPlátna.getTransform();

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (1.0 != mierkaX || 1.0 != mierkaY)
					{
						grafikaAktívnehoPlátna.scale(mierkaX, mierkaY);
						prepočítanéX /= mierkaX;
						prepočítanéY /= mierkaY;
						šírkaVMierke *= mierkaX;
						výškaVMierke *= mierkaY;
					}

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX,
							aktuálneY - výškaVMierke,
							aktuálneX + šírkaVMierke,
							aktuálneY);

						// Obrázok zo súboru nikdy nebude inštanciou triedy
						// Obrázok, preto môžeme tento test vynechať.
						/*if (obrázok instanceof Obrázok)
							((Obrázok)obrázok).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else*/
							grafikaAktívnehoPlátna.drawImage(obrázok,
								(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaVMierke / 2.0),
							aktuálneY - (výškaVMierke / 2.0),
							aktuálneX + (šírkaVMierke / 2.0),
							aktuálneY + (výškaVMierke / 2.0));

						/*if (obrázok instanceof Obrázok)
							((Obrázok)obrázok).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else*/
							grafikaAktívnehoPlátna.drawImage(obrázok,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (1.0 == mierkaX && 1.0 == mierkaY)
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + Δx, prepočítanéY - Δy);
					else
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + (Δx / mierkaX),
							prepočítanéY - (Δy / mierkaY));

					if (1.0 != mierkaX || 1.0 != mierkaY)
					{
						grafikaAktívnehoPlátna.scale(mierkaX, mierkaY);
						prepočítanéX /= mierkaX;
						prepočítanéY /= mierkaY;
						šírkaVMierke *= mierkaX;
						výškaVMierke *= mierkaY;
					}

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0;
						double y0 = -výškaVMierke;
						double x1 =  šírkaVMierke;
						double y1 = 0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawImage(obrázok,
							(int)prepočítanéX, (int)prepočítanéY, null);
					}
					else
					{
						double x0 = -šírkaVMierke / 2.0;
						double y0 = -výškaVMierke / 2.0;
						double x1 =  šírkaVMierke / 2.0;
						double y1 =  výškaVMierke / 2.0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawImage(obrázok,
							(int)(prepočítanéX - (šírkaObrázka / 2.0)),
							(int)(prepočítanéY - (výškaObrázka / 2.0)),
							null);
					}
				}

				grafikaAktívnehoPlátna.setTransform(transformácie);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(String, int, double, double, double, double) obrázok}.</p> */
			public void obrazok(String súbor, int spôsobKreslenia,
				double Δx, double Δy, double mierkaX, double mierkaY)
			{ obrázok(súbor, spôsobKreslenia, Δx, Δy, mierkaX, mierkaY); }


			// Táto verzia nemôže byť definovaná, lebo koliduje s verziou
			// … Δx, Δy …
			// public void obrázok(Image obrázok, int spôsobKreslenia,
			// 	double mierkaX, double mierkaY)


			/**
			 * <p>Nakreslí obrázok na pozícii robota podľa zadaného spôsobu
			 * kreslenia s vysunutím stredu otáčania o zadané odchýlky Δx a Δy.
			 * Obrázok je všeobecný typ {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.
			 * Odchýlky otáčania sú upravené podľa mierky.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Tieto metódy nesmú brať
			 * do úvahy priehľadnosť robota. Kolidovalo by to s inými
			 * mechanizmami programovacieho rámca. Je dosť iných spôsobov
			 * ako nakresliť spriehľadnaný obrázok. Napríklad nastaviť
			 * priehľadnosť inštancii triedy {@link Obrázok Obrázok} alebo
			 * kresliť obrázkový tvar spriehľadneného robota.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť vykreslený
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @param mierkaX určuje mierku šírky obrázka
			 * @param mierkaY určuje mierku výšky obrázka
			 * 
			 * @throws GRobotException ak je obrázok poškodený alebo
			 *     nebol nájdený
			 */
			public void obrázok(Image obrázok, int spôsobKreslenia,
				double Δx, double Δy, double mierkaX, double mierkaY)
			{
				// ‼Pozor‼ Priehľadnosť sa nesmie meniť v rámci týchto
				// metód. Kolidovalo by to s priehľadnosťou robotov
				// (najmä pri kreslení obrázkových tvarov).

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				int šírkaObrázka = obrázok.getWidth(null);
				int výškaObrázka = obrázok.getHeight(null);
				if (šírkaObrázka < 0 || výškaObrázka < 0)
					throw new GRobotException("Obrázok je poškodený!",
						"imageBroken");

				int šírkaVMierke = šírkaObrázka;
				int výškaVMierke = výškaObrázka;

				AffineTransform transformácie =
					grafikaAktívnehoPlátna.getTransform();

				Image relevantný = Obrázok.dajRelevantnýRaster(obrázok);

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (1.0 != mierkaX || 1.0 != mierkaY)
					{
						grafikaAktívnehoPlátna.scale(mierkaX, mierkaY);
						prepočítanéX /= mierkaX;
						prepočítanéY /= mierkaY;
						šírkaVMierke *= mierkaX;
						výškaVMierke *= mierkaY;
					}

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX,
							aktuálneY - výškaVMierke,
							aktuálneX + šírkaVMierke,
							aktuálneY);

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX),
								(int)(prepočítanéY),
								null);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaVMierke / 2.0),
							aktuálneY - (výškaVMierke / 2.0),
							aktuálneX + (šírkaVMierke / 2.0),
							aktuálneY + (výškaVMierke / 2.0));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					if (1.0 == mierkaX && 1.0 == mierkaY)
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + Δx, prepočítanéY - Δy);
					else
						grafikaAktívnehoPlátna.rotate(-α,
							prepočítanéX + (Δx / mierkaX),
							prepočítanéY - (Δy / mierkaY));

					if (1.0 != mierkaX || 1.0 != mierkaY)
					{
						grafikaAktívnehoPlátna.scale(mierkaX, mierkaY);
						prepočítanéX /= mierkaX;
						prepočítanéY /= mierkaY;
						šírkaVMierke *= mierkaX;
						výškaVMierke *= mierkaY;
					}

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0;
						double y0 = -výškaVMierke;
						double x1 =  šírkaVMierke;
						double y1 = 0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNa((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX),
								(int)(prepočítanéY),
								null);
					}
					else
					{
						double x0 = -šírkaVMierke / 2.0;
						double y0 = -výškaVMierke / 2.0;
						double x1 =  šírkaVMierke / 2.0;
						double y1 =  výškaVMierke / 2.0;
						double x2 = -Δx;
						double y2 = -Δy;
						double x3 = aktuálneX + Δx +
							rotovanéXRad(x2, y2, α);
						double y3 = aktuálneY + Δy +
							rotovanéYRad(x2, y2, α);

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y0, α),
							y3 + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x0, y1, α),
							y3 + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y0, α),
							y3 + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							x3 + rotovanéXRad(x1, y1, α),
							y3 + rotovanéYRad(x1, y1, α));

						if (relevantný instanceof Obrázok)
							((Obrázok)relevantný).
								kresliNaStred((int)prepočítanéX,
									(int)prepočítanéY,
									grafikaAktívnehoPlátna);
						else
							grafikaAktívnehoPlátna.drawImage(relevantný,
								(int)(prepočítanéX - (šírkaObrázka / 2.0)),
								(int)(prepočítanéY - (výškaObrázka / 2.0)),
								null);
					}
				}

				grafikaAktívnehoPlátna.setTransform(transformácie);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obrázok(Image, int, double, double, double, double) obrázok}.</p> */
			public void obrazok(Image obrázok, int spôsobKreslenia,
				double Δx, double Δy, double mierkaX, double mierkaY)
			{ obrázok(obrázok, spôsobKreslenia, Δx, Δy, mierkaX, mierkaY); }


		// Text

			/**
			 * <p>Napíše<sup>[1]</sup> zadaný text na pozícii robota podľa
			 * aktuálneho spôsobu kreslenia (pozri: {@link 
			 * #spôsobKreslenia(int) spôsobKreslenia}) alebo vytvorí tvar
			 * obrysu zadaného textu (čo záleží na tom, či je tento robot
			 * momentálne {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný}
			 * alebo nie a či je {@linkplain #nekresliTvary() zakázané
			 * kreslenie tvarov}; pozri vysvetlenie pri návratovej hodnote).
			 * Predvolene roboty píšu text rotovaný kolmo na ich aktuálny smer
			 * a vycentrovaný na ich aktuálnej polohe. Takže pri základných
			 * hodnotách robota, sa text zobrazí vodorovne v strede plátna
			 * (pretože robot býva pri vytvorení umiestnený v strede podlahy
			 * (v bode [0, 0]) a nasmerovaný hore (v uhle 90°)).</p>
			 * 
			 * <p><small>[1] – alebo skôr „nakreslí“ zadaný text – písanie textu
			 * robotom totiž prebieha podobne, ako keby robot vytvoril z textu
			 * pečiatku a tú vytlačil podľa aktuálneho spôsobu kreslenia
			 * (predvolene vycentrovanú na svojej pozícii a rotovanú podľa
			 * svojho smeru); jednoducho <b>s textom napísaným robotom je
			 * zaobchádzané ako s grafikou</b>…</small></p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda nemôže prijímať
			 * variabilný počet argumentov (podobne ako metódy sveta {@link 
			 * Svet#vypíš(Object[]) vypíš} a {@link Svet#vypíšRiadok(Object[])
			 * vypíšRiadok}), pretože má definované rôzne verzie, ktoré
			 * umožňujú programátorovi operatívne meniť spôsob (a/alebo
			 * polohu) kreslenia textov. Z toho dôvodu bola definovaná
			 * statická metóda {@link #S(Object[]) S}, ktorá prijíma
			 * variabilný počet argumentov, ktoré konvertuje na jeden zlúčený
			 * reťazec. (Na získanie ďalších podrobností pozri opis metódy
			 * {@link #S(Object[]) S}.)</p>
			 * 
			 * @param text text, ktorý má byť vypísaný
			 * @return ak nie je robot {@linkplain Oblasť#zamestnaj(GRobot)
			 *     zamestnaný} a je {@linkplain #kresliTvary() povolené
			 *     kreslenie tvarov}, metóda píše text a má návratovú hodnotu
			 *     {@code valnull};
			 *     v opačnom prípade metóda nenapíše nič a vracia objekt typu
			 *     {@link Shape Shape} (tvar) reprezentujúci obrys zadaného
			 *     textu (tvar textu)
			 * 
			 * @see Plátno#vypíš(Object[]) Plátno.vypíš(Object...)
			 * @see Plátno#vypíšRiadok(Object[])
			 *     Plátno.vypíšRiadok(Object...)
			 * @see #text(String, int)
			 * @see #text(String, double, double)
			 * @see #text(String, int, double, double)
			 */
			public Shape text(String text)
			{ return text(text, spôsobKreslenia); }

			/**
			 * <p>Napíše<sup>[1]</sup> zadaný text na pozícii robota podľa
			 * aktuálneho spôsobu kreslenia (pozri: {@link 
			 * #spôsobKreslenia(int) spôsobKreslenia}) a s vysunutím stredu
			 * otáčania o zadané odchýlky Δx a Δy alebo vytvorí tvar
			 * obrysu zadaného textu (čo záleží na tom, či je tento robot
			 * momentálne {@linkplain Oblasť#zamestnaj(GRobot) zamestnaný}
			 * alebo nie a či je {@linkplain #nekresliTvary() zakázané
			 * kreslenie tvarov}; pozri vysvetlenie pri návratovej hodnote).
			 * Predvolene roboty píšu text rotovaný kolmo na ich aktuálny smer
			 * a vycentrovaný na ich aktuálnej polohe. Takže pri základných
			 * hodnotách robota, sa text zobrazí vodorovne v strede plátna
			 * (pretože robot býva pri vytvorení umiestnený v strede podlahy
			 * (v bode [0, 0]) a nasmerovaný hore (v uhle 90°)).</p>
			 * 
			 * <p><small>[1] – alebo skôr „nakreslí“ zadaný text – písanie textu
			 * robotom totiž prebieha podobne, ako keby robot vytvoril z textu
			 * pečiatku a tú vytlačil podľa aktuálneho spôsobu kreslenia
			 * (predvolene vycentrovanú na svojej pozícii a rotovanú podľa
			 * svojho smeru); jednoducho <b>s textom napísaným robotom je
			 * zaobchádzané ako s grafikou</b>…</small></p>
			 * 
			 * @param text text, ktorý má byť vypísaný
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @return ak nie je robot {@linkplain Oblasť#zamestnaj(GRobot)
			 *     zamestnaný} a je {@linkplain #kresliTvary() povolené
			 *     kreslenie tvarov}, metóda píše text a má návratovú hodnotu
			 *     {@code valnull};
			 *     v opačnom prípade metóda nenapíše nič a vracia objekt typu
			 *     {@link Shape Shape} (tvar) reprezentujúci obrys zadaného
			 *     textu (tvar textu)
			 * 
			 * @see Plátno#vypíš(Object[]) Plátno.vypíš(Object...)
			 * @see Plátno#vypíšRiadok(Object[])
			 *     Plátno.vypíšRiadok(Object...)
			 * @see #text(String)
			 * @see #text(String, int)
			 * @see #text(String, int, double, double)
			 */
			public Shape text(String text, double Δx, double Δy)
			{ return text(text, spôsobKreslenia, Δx, Δy); }

			/**
			 * <p>Napíše<sup>[1]</sup> zadaný text na pozícii robota podľa
			 * zadaného spôsobu kreslenia alebo vytvorí tvar obrysu zadaného
			 * textu. Záleží od toho, či je tento robot {@linkplain 
			 * Oblasť#zamestnaj(GRobot) zamestnaný} a či je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov} (pozri
			 * vysvetlenie pri návratovej hodnote).</p>
			 * 
			 * <p><small>[1] – alebo skôr „nakreslí“ zadaný text – písanie textu
			 * robotom totiž prebieha podobne, ako keby robot vytvoril
			 * z textu pečiatku a tú vytlačil podľa zadaného spôsobu
			 * kreslenia…</small></p>
			 * 
			 * @param text text, ktorý má byť vypísaný
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @return ak nie je robot {@linkplain Oblasť#zamestnaj(GRobot)
			 *     zamestnaný} a je {@linkplain #kresliTvary() povolené
			 *     kreslenie tvarov}, metóda píše text a má návratovú hodnotu
			 *     {@code valnull};
			 *     v opačnom prípade metóda nenapíše nič a vracia objekt typu
			 *     {@link Shape Shape} (tvar) reprezentujúci obrys zadaného
			 *     textu (tvar textu)
			 * 
			 * @see Plátno#vypíš(Object[]) Plátno.vypíš(Object...)
			 * @see Plátno#vypíšRiadok(Object[])
			 *     Plátno.vypíšRiadok(Object...)
			 * @see #text(String)
			 * @see #text(String, double, double)
			 * @see #text(String, int, double, double)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape text(String text, int spôsobKreslenia)
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				grafikaAktívnehoPlátna.setFont(aktuálnePísmo);

				FontMetrics rozmery = grafikaAktívnehoPlátna.getFontMetrics();
				int šírkaTextu = rozmery.stringWidth(text);
				int poklesTextu = (rozmery.getDescent() * 3) / 2;
				// System.out.println("Pokles " + text + ": " + poklesTextu);

				if (!kresliTvary)
				{
					TextLayout rozloženieTextu = new TextLayout(text,
						aktuálnePísmo, grafikaAktívnehoPlátna.
							getFontRenderContext());

					AffineTransform transformácie = new AffineTransform();

					if ((90.0 == aktuálnyUhol) ||
						(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
					{
						if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
						{
							transformácie.setToTranslation(
								(float)prepočítanéX,
								(float)prepočítanéY);
						}
						else
						{
							transformácie.setToTranslation(
								(float)(prepočítanéX - (šírkaTextu / 2.0)),
								(float)(prepočítanéY + poklesTextu));
						}
					}
					else
					{
						double α = toRadians(aktuálnyUhol - 90);
						transformácie.rotate(-α, prepočítanéX, prepočítanéY);

						if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
						{
							transformácie.translate(
								(float)prepočítanéX,
								(float)prepočítanéY);
						}
						else
						{
							transformácie.translate(
								(float)(prepočítanéX - (šírkaTextu / 2.0)),
								(float)(prepočítanéY + poklesTextu));
						}
					}

					poslednýTypTvaru = TypTvaru.NIČ;
					return rozloženieTextu.getOutline(transformácie);
				}

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX, aktuálneY, aktuálneX + šírkaTextu,
							aktuálneY + poklesTextu + rozmery.getAscent());

						grafikaAktívnehoPlátna.drawString(text,
							(float)prepočítanéX, (float)prepočítanéY);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaTextu / 2.0),
							aktuálneY - poklesTextu,
							aktuálneX + (šírkaTextu / 2.0),
							aktuálneY + rozmery.getAscent());

						grafikaAktívnehoPlátna.drawString(text,
							(float)(prepočítanéX - (šírkaTextu / 2.0)),
							(float)(prepočítanéY + poklesTextu));

						// http://docstore.mik.ua/orelly/java-ent/jfc/ch04_09.htm
						// 
						// java.awt.font.FontRenderContext frc =
						// 	grafikaAktívnehoPlátna.getFontRenderContext();
						// 
						// Rectangle2D bounds = aktuálnePísmo.
						// 	getStringBounds(text, frc);
						// java.awt.font.LineMetrics metrics =
						// 	aktuálnePísmo.getLineMetrics(text, frc);
						// 
						// float width = (float)bounds.getWidth();
						// float lineheight = metrics.getHeight();
						// float ascent = metrics.getAscent();
						// 
						// grafikaAktívnehoPlátna.drawString(text,
						// 	(float)(prepočítanéX - (width / 2.0)),
						// 	(float)(prepočítanéY - (lineheight / 2.0) +
						// 		ascent));
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					grafikaAktívnehoPlátna.rotate(-α,
						prepočítanéX, prepočítanéY);

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0; double y0 = 0;
						double x1 = šírkaTextu;
						double y1 = poklesTextu + rozmery.getAscent();

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawString(text,
							(float)prepočítanéX, (float)prepočítanéY);
					}
					else
					{
						double x0 = -(šírkaTextu / 2.0);
						double y0 = -poklesTextu;
						double x1 = (šírkaTextu / 2.0);
						double y1 = rozmery.getAscent();

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawString(text,
							(float)(prepočítanéX - (šírkaTextu / 2.0)),
							(float)(prepočítanéY + poklesTextu));
					}

					grafikaAktívnehoPlátna.rotate(α,
						prepočítanéX, prepočítanéY);
				}

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
				return null;
			}

			/**
			 * <p>Napíše<sup>[1]</sup> zadaný text na pozícii robota podľa
			 * zadaného spôsobu kreslenia a s vysunutím stredu otáčania
			 * o zadané odchýlky Δx a Δy alebo vytvorí tvar obrysu zadaného
			 * textu. Záleží od toho, či je tento robot {@linkplain 
			 * Oblasť#zamestnaj(GRobot) zamestnaný} a či je {@linkplain 
			 * #nekresliTvary() zakázané kreslenie tvarov} (pozri
			 * vysvetlenie pri návratovej hodnote).</p>
			 * 
			 * <p><small>[1] – alebo skôr „nakreslí“ zadaný text – písanie textu
			 * robotom totiž prebieha podobne, ako keby robot vytvoril
			 * z textu pečiatku a tú vytlačil podľa zadaného spôsobu
			 * kreslenia…</small></p>
			 * 
			 * @param text text, ktorý má byť vypísaný
			 * @param spôsobKreslenia môže byť buď hodnota {@link 
			 *     #KRESLI_PRIAMO}, alebo kombinácia hodnôt {@link 
			 *     #KRESLI_NA_STRED} a {@link #KRESLI_ROTOVANÉ}.
			 * @param Δx vysunutie stredu otáčania v smere osi x
			 * @param Δy vysunutie stredu otáčania v smere osi y
			 * @return ak nie je robot {@linkplain Oblasť#zamestnaj(GRobot)
			 *     zamestnaný} a je {@linkplain #kresliTvary() povolené
			 *     kreslenie tvarov}, metóda píše text a má návratovú hodnotu
			 *     {@code valnull};
			 *     v opačnom prípade metóda nenapíše nič a vracia objekt typu
			 *     {@link Shape Shape} (tvar) reprezentujúci obrys zadaného
			 *     textu (tvar textu)
			 * 
			 * @see Plátno#vypíš(Object[]) Plátno.vypíš(Object...)
			 * @see Plátno#vypíšRiadok(Object[])
			 *     Plátno.vypíšRiadok(Object...)
			 * @see #text(String)
			 * @see #text(String, double, double)
			 * @see #text(String, int)
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #cesta()
			 * @see #kresliTvary() kresliTvary
			 * @see #nekresliTvary() nekresliTvary
			 * @see Oblasť#zamestnaj(GRobot)
			 * @see Oblasť#uvoľni()
			 */
			public Shape text(String text, int spôsobKreslenia,
				double Δx, double Δy)
			{
				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				grafikaAktívnehoPlátna.setFont(aktuálnePísmo);

				FontMetrics rozmery = grafikaAktívnehoPlátna.getFontMetrics();
				int šírkaTextu = rozmery.stringWidth(text);
				int poklesTextu = (rozmery.getDescent() * 3) / 2;
				// System.out.println("Pokles " + text + ": " + poklesTextu);

				if (!kresliTvary)
				{
					TextLayout rozloženieTextu = new TextLayout(text,
						aktuálnePísmo, grafikaAktívnehoPlátna.
							getFontRenderContext());

					AffineTransform transformácie = new AffineTransform();

					if ((90.0 == aktuálnyUhol) ||
						(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
					{
						if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
						{
							transformácie.setToTranslation(
								(float)prepočítanéX,
								(float)prepočítanéY);
						}
						else
						{
							transformácie.setToTranslation(
								(float)(prepočítanéX - (šírkaTextu / 2.0)),
								(float)(prepočítanéY + poklesTextu));
						}
					}
					else
					{
						double α = toRadians(aktuálnyUhol - 90);
						transformácie.rotate(-α, prepočítanéX, prepočítanéY);

						if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
						{
							transformácie.translate(
								(float)prepočítanéX,
								(float)prepočítanéY);
						}
						else
						{
							transformácie.translate(
								(float)(prepočítanéX - (šírkaTextu / 2.0)),
								(float)(prepočítanéY + poklesTextu));
						}
					}

					poslednýTypTvaru = TypTvaru.NIČ;
					return rozloženieTextu.getOutline(transformácie);
				}

				poslednýTypTvaru = TypTvaru.VÝPLŇ;

				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

				if ((90.0 == aktuálnyUhol) ||
					(0 == (spôsobKreslenia & KRESLI_ROTOVANÉ)))
				{
					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						aktualizujPôsobisko(
							aktuálneX, aktuálneY, aktuálneX + šírkaTextu,
							aktuálneY + poklesTextu + rozmery.getAscent());

						grafikaAktívnehoPlátna.drawString(text,
							(float)prepočítanéX, (float)prepočítanéY);
					}
					else
					{
						aktualizujPôsobisko(
							aktuálneX - (šírkaTextu / 2.0),
							aktuálneY - poklesTextu,
							aktuálneX + (šírkaTextu / 2.0),
							aktuálneY + rozmery.getAscent());

						grafikaAktívnehoPlátna.drawString(text,
							(float)(prepočítanéX - (šírkaTextu / 2.0)),
							(float)(prepočítanéY + poklesTextu));

						// http://docstore.mik.ua/orelly/java-ent/jfc/ch04_09.htm
						// 
						// java.awt.font.FontRenderContext frc =
						// 	grafikaAktívnehoPlátna.getFontRenderContext();
						// 
						// Rectangle2D bounds = aktuálnePísmo.
						// 	getStringBounds(text, frc);
						// java.awt.font.LineMetrics metrics =
						// 	aktuálnePísmo.getLineMetrics(text, frc);
						// 
						// float width = (float)bounds.getWidth();
						// float lineheight = metrics.getHeight();
						// float ascent = metrics.getAscent();
						// 
						// grafikaAktívnehoPlátna.drawString(text,
						// 	(float)(prepočítanéX - (width / 2.0)),
						// 	(float)(prepočítanéY - (lineheight / 2.0) +
						// 		ascent));
					}
				}
				else
				{
					double α = toRadians(aktuálnyUhol - 90);

					grafikaAktívnehoPlátna.rotate(-α,
						prepočítanéX + Δx, prepočítanéY - Δy);

					if (0 == (spôsobKreslenia & KRESLI_NA_STRED))
					{
						double x0 = 0; double y0 = 0;
						double x1 = šírkaTextu;
						double y1 = poklesTextu + rozmery.getAscent();

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawString(text,
							(float)prepočítanéX, (float)prepočítanéY);
					}
					else
					{
						double x0 = -(šírkaTextu / 2.0);
						double y0 = -poklesTextu;
						double x1 = (šírkaTextu / 2.0);
						double y1 = rozmery.getAscent();

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y0, α),
							aktuálneY + rotovanéYRad(x0, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x0, y1, α),
							aktuálneY + rotovanéYRad(x0, y1, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y0, α),
							aktuálneY + rotovanéYRad(x1, y0, α));

						aktualizujPôsobisko(
							aktuálneX + rotovanéXRad(x1, y1, α),
							aktuálneY + rotovanéYRad(x1, y1, α));

						grafikaAktívnehoPlátna.drawString(text,
							(float)(prepočítanéX - (šírkaTextu / 2.0)),
							(float)(prepočítanéY + poklesTextu));
					}

					grafikaAktívnehoPlátna.rotate(α,
						prepočítanéX + Δx, prepočítanéY - Δy);
				}

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
				return null;
			}


			/**
			 * <p>Táto metóda umožní používateľovi upraviť text priamo na plátne.
			 * Správa sa rovnako ako metóda {@link #upravText(String, double)
			 * upravText} so zadanou zápornou hodnotou predvolenej šírky
			 * textového komponentu. V opise uvedenej metódy sú príklady
			 * použitia mechanizmu úpravy textov.</p>
			 * 
			 * @param text predvolený textu určený na úpravu
			 * @return {@code valtrue} ak sa úpravu podarilo zahájiť,
			 *     inak {@code valfalse}
			 * 
			 * @see #upravText(String, double)
			 * @see #ukončenieÚpravyTextu(String, int)
			 */
			public boolean upravText(String text)
			{ return upravText(text, -1); }

			/**
			 * <p>Táto metóda umožní používateľovi upraviť text priamo na plátne.
			 * Metóda zobrazí na aktuálnych súradniciach robota priehľadný
			 * komponent na úpravu textu so zadaným textom vo farbe aktuálneho
			 * robota. Po stlačení {@code ENTER}, {@code ESC}, {@code TAB},
			 * {@code Shift + TAB} alebo po deaktivácii textového komponentu
			 * je úprava automaticky ukončená a je spustená metóda
			 * {@link #ukončenieÚpravyTextu(String, int)
			 * ukončenieÚpravyTextu}, ktorú by mal programátor prekryť
			 * a zariadiť spracovanie zadaného textu.</p>
			 * 
			 * <p><b>Príklady:</b></p>
			 * 
			 * <p>Prvý príklad je jednoduchší. Výsledok po spustení programu
			 * vyzerá takto:</p>
			 * 
			 * <p><image>upravaTextu-1.png<alt/>Ukážka príkladu úpravy textu
			 * tesne po spustení.</image>(Plátno v ukážke je zmenšené.)</p>
			 * 
			 * <p>Po kliknutí na ľubovoľné miesto na ploche sa začne úprava
			 * textu (ak už neprebieha). Ak sa úprava textu neskončí
			 * stlačením klávesu {@code ESC}, tak sa zmeny textu prijmú.
			 * (Niekedy môže byť žiadnuce, aby sa zmeny prijali v každom
			 * prípade. Vtedy treba podmienku {@code kwdif }({@link 
			 * GRobot#SPÔSOB_ESCAPE SPÔSOB_ESCAPE}<code> != spôsob)</code>
			 * odstrániť alebo prislúchajúcim spôsobom upraviť.)</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdimport} knižnica.*;

				{@code kwdpublic} {@code typeclass} TestÚpravTextov {@code kwdextends} {@link GRobot GRobot}
				{
					{@code comm// Textov určený na úpravu}
					{@code kwdprivate} {@link String String} text = {@code srg"Môj text na úpravu"};

					{@code comm// Súkromný konštruktor hlavnej triedy}
					{@code kwdprivate} TestÚpravTextov()
					{
						{@link GRobot#skry() skry}();
						{@link GRobot#text(String) text}(text);
					}

					{@code comm// Obsluha udalosti kliknutia myšou – odštartuje úpravu (ak neprebieha)}
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#klik() klik}()
					{
						{@code kwdif} ({@link GRobot#upravText(String, double) upravText}(text, {@code num200}))
							{@link Plátno podlaha}.{@link Plátno#vymažGrafiku() vymažGrafiku}();
					}

					{@code comm// Prekrytá metóda spracúvajúca ukončenie aktuálnej úpravy}
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#ukončenieÚpravyTextu(String, int) ukončenieÚpravyTextu}({@link String String} text, {@code typeint} spôsob)
					{
						{@code comm// Text sa uloží len ak nebol stlačený kláves ESCAPE,…}
						{@code kwdif} ({@link GRobot#SPÔSOB_ESCAPE SPÔSOB_ESCAPE} != spôsob) {@code valthis}.text = text;

						{@code comm// …ale vypíše sa v každom prípade.}
						{@link GRobot#text(String) text}({@code valthis}.text);
					}

					{@code comm// Hlavná metóda}
					{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String} args[])
					{
						{@code kwdnew} TestÚpravTextov();
					}
				}
				</pre>
			 * 
			 * <p>Nasledujúci príklad je komplikovanejší – ukazuje ako
			 * striedavo upravovať niekoľko textov na ploche. Tesne po
			 * spustení vyzerá obsah plátna takto:
			 * 
			 * <p><image>upravaTextu-2.png<alt/>Ukážka príkladu úpravy
			 * viacerých textov tesne po spustení.</image>(Plátno v ukážke
			 * je zmenšené.)</p>
			 * 
			 * <p> </p>
			 * 
			 * <pre CLASS="example">
				{@code kwdimport} knižnica.*;

				{@code kwdpublic} {@code typeclass} TestÚpravTextov {@code kwdextends} {@link GRobot GRobot}
				{
					{@code comm// Využitie triedy Častica na definovanie novej triedy,}
					{@code comm// ktorá bude použitá na uchovávanie textových objektov,}
					{@code comm// ktoré budú upravovateľné. Trieda využíva služby hlavného}
					{@code comm// robota.}
					{@code kwdprivate} {@code typeclass} TextNaÚpravu {@code kwdextends} {@link Častica Častica}
					{
						{@code comm// Aktuálna hodnota textu určeného na úpravu}
						{@code kwdpublic} {@link String String} text;

						{@code comm// Aktuálna farba textu určeného na úpravu}
						{@code kwdpublic} {@link Farba Farba} farba;

						{@code comm// Konštruktor}
						{@code kwdpublic} TextNaÚpravu({@link String String} text, {@code typedouble} x, {@code typedouble} y, {@link Farba Farba} farba)
						{
							{@code valthis}.text = text;
							{@code valthis}.x = x;
							{@code valthis}.y = y;
							{@code valthis}.farba = farba;
						}

						{@code comm// Nakreslenie textu}
						{@code kwdpublic} {@code typevoid} nakresli()
						{
							{@link GRobot#skočNa(Poloha) skočNa}({@code valthis});
							{@link GRobot#farba(Color) farba}(farba);
							{@link GRobot#text(String) text}(text);
						}
					}

					{@code comm// Pole inštancií textov určených na úpravy}
					{@code kwdprivate} TextNaÚpravu texty[] =
					{
						{@code kwdnew} TextNaÚpravu({@code srg"Červený text"}, {@code num0}, {@code num50}, {@link Farebnosť#červená červená}),
						{@code kwdnew} TextNaÚpravu({@code srg"Zelený text"}, {@code num0}, {@code num0}, {@link Farebnosť#zelená zelená}),
						{@code kwdnew} TextNaÚpravu({@code srg"Modrý text"}, {@code num0}, &#45;{@code num50}, {@link Farebnosť#modrá modrá}),
					};

					{@code comm// Inštancia, ktorá si bude uchovávať aktuálne upravovaný objekt}
					{@code kwdprivate} TextNaÚpravu upravujeSa = {@code valnull};

					{@code comm// Súkromný konštruktor hlavnej triedy}
					{@code kwdprivate} TestÚpravTextov()
					{
						{@link GRobot#skry() skry}();
						{@link GRobot#písmo(String, double) písmo}({@code srg"Calibri"}, {@code num30});
						{@code kwdfor} (TextNaÚpravu text : texty)
							text.nakresli();
					}

					{@code comm// Obsluha udalosti kliknutia myšou}
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#klik() klik}()
					{
						{@code kwdif} ({@code valnull} == upravujeSa)
						{
							{@code comm// Zakaždým, keď sa nič neupravuje, tak sa prekreslí}
							{@code comm// obrazovka a ak sa pritom zistí, že bolo kliknuté}
							{@code comm// v rámci vymedzeného obdĺžnika niektorého z textov,}
							{@code comm// tak sa zaháji jeho úprava…}
							{@link Plátno podlaha}.{@link Plátno#vymažGrafiku() vymažGrafiku}();

							{@code kwdfor} (TextNaÚpravu text : texty)
							{
								{@link GRobot#skočNa(Poloha) skočNa}(text);
								{@code kwdif} ({@link GRobot#myšVObdĺžniku(double, double) myšVObdĺžniku}({@code num100}, {@code num20}))
								{
									{@link GRobot#skočNa(Poloha) skočNa}(text);
									{@link GRobot#farba(Color) farba}(text.farba);
									{@code currupravText}(text.text, {@code num200});
									upravujeSa = text;
								}
								{@code kwdelse} text.nakresli();
							}
						}
					}

					{@code comm// Prekrytá metóda spracúvajúca ukončenie aktuálnej úpravy}
					{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#ukončenieÚpravyTextu(String, int) ukončenieÚpravyTextu}({@link String String} text, {@code typeint} spôsob)
					{
						{@code kwdif} ({@link GRobot#SPÔSOB_ESCAPE SPÔSOB_ESCAPE} != spôsob)
							upravujeSa.text = text;
						<hr/>
						{@code comm// Na tomto mieste by bolo vhodné implementovať mechanizmus}
						{@code comm// pohybu po upravovaných inštanciách klávesom TAB (pohyb}
						{@code comm// dopredu – SPÔSOB_TABULÁTOR == spôsob, pohyb dozadu –}
						{@code comm// – SPÔSOB_SHIFT_TABULÁTOR == spôsob). Stačilo by nájsť,}
						{@code comm// ten prvok v poli, ktorý je práve upravovaný a podľa toho}
						{@code comm// zahájiť úpravu nasledujúceho alebo predchádzajúceho prvku.}
						{@code comm// Aby bol tento príklad kratší, tak podrobná implementácia}
						{@code comm// tohto mechanizmu je uvedená nižšie, za týtmo príkladom…}
						<hr/>
						{@code comm// Nakreslí a ukončí sa úprava aktuálneho prvku}
						upravujeSa.nakresli();
						upravujeSa = {@code valnull};
					}

					{@code comm// Hlavná metóda}
					{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String} args[])
					{
						{@code kwdnew} TestÚpravTextov();
					}
				}
				</pre>
			 * 
			 * <p>Ďalej je uvedená implementácia presúvania sa medzi textami
			 * tabulátorom, ktorá je spomenutá v komentároch príkladu vyššie.
			 * Touto implementáciou treba nahradiť trojicu riadkov začínajúcu
			 * sa komentárom {@code comm// Nakreslí a ukončí sa úprava
			 * aktuálneho prvku} (na konci reakcie {@link 
			 * #ukončenieÚpravyTextu(String, int) ukončenieÚpravyTextu} –
			 * pár riadkov od konca zdrojového kódu celého príkladu):</p>
			 * 
			 * <pre CLASS="example">
				{@code comm// Táto inštancia bude slúžiť na signalizáciu zahájenia úpravy}
				{@code comm// nového textu – pri posunutí klávesom TAB to bude nasledujúca}
				{@code comm// inštancia v poli, pri posunutí naspäť (Shift + TAB) to bude}
				{@code comm// predchádzajúca… (Predvolene to nebude žiadna.)}
				TextNaÚpravu začniÚpravuNovéhoTextu = {@code valnull};

				{@code kwdif} ({@link GRobot#SPÔSOB_TABULÁTOR SPÔSOB_TABULÁTOR} == spôsob)
				{
					{@code kwdif} (upravujeSa == texty[texty.length &#45; {@code num1}])
					{
						{@code comm// Posledná inštancia presunie upravovanie na prvú:}
						začniÚpravuNovéhoTextu = texty[{@code num0}];
					}
					{@code kwdelse} {@code kwdfor} ({@code typeint} i = texty.length &#45; {@code num2}; i &gt;= {@code num0}; &#45;&#45;i)
					{
						{@code comm// Je jedno v akom smere prehľadávame pole, tak}
						{@code comm// sme sa rozhodli pre spätné vyhľadávanie (aby}
						{@code comm// sme cyklus mierne výpočtovo odľahčili…).}

						{@code comm// Po nájdení aktuálneho prvku „označíme“ nasledujúci:}
						{@code kwdif} (upravujeSa == texty[i])
						{
							začniÚpravuNovéhoTextu = texty[i + {@code num1}];
							{@code kwdbreak};
						}
					}
				}
				{@code kwdelse} {@code kwdif} ({@link GRobot#SPÔSOB_SHIFT_TABULÁTOR SPÔSOB_SHIFT_TABULÁTOR} == spôsob)
				{
					{@code kwdif} (upravujeSa == texty[{@code num0}])
					{
						{@code comm// Prvá inštancia presunie upravovanie na poslednú:}
						začniÚpravuNovéhoTextu = texty[texty.length &#45; {@code num1}];
					}
					{@code kwdelse} {@code kwdfor} ({@code typeint} i = {@code num1}; i &lt; texty.length; ++i)
					{
						{@code comm// Prehľadávame od druhej inštancie po poslednú.}

						{@code comm// Po nájdení aktuálneho prvku „označíme“ predchádzajúci:}
						{@code kwdif} (upravujeSa == texty[i])
						{
							začniÚpravuNovéhoTextu = texty[i - {@code num1}];
							{@code kwdbreak};
						}
					}
				}

				{@code comm// Nakreslí a ukončí sa úprava aktuálneho prvku}
				upravujeSa.nakresli();
				upravujeSa = {@code valnull};

				{@code comm// Ak sme predtým zadali požiadavku na zahájenie úpravy}
				{@code comm// nového textu, tak túto požiadavku korektne spracujeme:}
				{@code kwdif} ({@code valnull} != začniÚpravuNovéhoTextu)
				{
					{@code comm// Vymazanie podlahy a prekreslenie ostatných textov}
					{@link Plátno podlaha}.{@link Plátno#vymažGrafiku() vymažGrafiku}();
					{@code kwdfor} (TextNaÚpravu prekresli : texty)
						{@code kwdif} (začniÚpravuNovéhoTextu != prekresli)
							prekresli.nakresli();

					{@link GRobot#skočNa(Poloha) skočNa}(začniÚpravuNovéhoTextu);
					{@link GRobot#farba(Color) farba}(začniÚpravuNovéhoTextu.farba);
					{@code currupravText}(začniÚpravuNovéhoTextu.text, {@code num200});
					upravujeSa = začniÚpravuNovéhoTextu;
				}
				</pre>
			 * 
			 * @param text predvolený textu určený na úpravu
			 * @param šírka predvolená šírka textového komponentu – ak je
			 *     zadané záporné číslo, tak bude mať komponent šírku
			 *     totožnú so šírkou prevoleného textu
			 * @return {@code valtrue} ak sa úpravu podarilo zahájiť,
			 *     inak {@code valfalse}
			 * 
			 * @see #upravText(String)
			 * @see #ukončenieÚpravyTextu(String, int)
			 */
			public boolean upravText(String text, double šírka)
			{
				for (int b = 0; b < 2; ++b)
					for (int i = 0; i < upravText.length; ++i)
					{
						// System.out.print(i + ": ");

						if (null == upravText[i])
						{
							upravText[i] = new UpravText();
							if (upravText[i].začniÚpravu(text, šírka, false))
								return true;
						}

						if (upravText[i].začniÚpravu(text, šírka, 0 == b))
							return true;
					}
				return false;
			}


			/**
			 * <p>Táto metóda je predvolene prázdna. Je určená na prekrytie
			 * a je spúšťaná po ukončení úpravy textu začatej metódou {@link 
			 * #upravText(String, double) upravText}. Prvý argumet je konečná
			 * podoba upraveného textu a druhý argument je jeden
			 * z nasledujúcich spôsobov:</p>
			 * 
			 * <table>
			 * <tr><td>{@link #SPÔSOB_ESCAPE SPÔSOB_ESCAPE}</td><td
			 * >–</td><td>bol stlačený kláves {@code ESC}</td></tr>
			 * <tr><td>{@link #SPÔSOB_ENTER SPÔSOB_ENTER}</td><td
			 * >–</td><td>bol stlačený kláves {@code ENTER}</td></tr>
			 * <tr><td>{@link #SPÔSOB_TABULÁTOR SPÔSOB_TABULÁTOR}<br />
			 * {@link #SPÔSOB_TAB SPÔSOB_TAB}</td><td
			 * >–</td><td>bol stlačený kláves {@code TABULÁTOR}</td></tr>
			 * <tr><td>{@link #SPÔSOB_SHIFT_TABULÁTOR
			 * SPÔSOB_SHIFT_TABULÁTOR}<br />{@link #SPÔSOB_SHIFT_TAB
			 * SPÔSOB_SHIFT_TAB}</td><td>–</td><td>bola stlačená klávesová
			 * kombinácia {@code Shift + tabulátor}</td></tr>
			 * <tr><td>{@link #SPÔSOB_DEAKTIVÁCIA SPÔSOB_DEAKTIVÁCIA}</td><td
			 * >–</td><td>komponent textového prvku bol deaktivovaný
			 * (napríklad po kliknutí myšou na plátno)</td></tr>
			 * </table>
			 * 
			 * @param text konečná podoba upraveného textu, ktorá môže byť
			 *     spracovaná podľa potreby
			 * @param spôsob jeden z vyššie uvedených spôsobov ukončenia
			 *     úpravy textu
			 * 
			 * @see #upravText(String)
			 * @see #upravText(String, double)
			 */
			public void ukončenieÚpravyTextu(String text, int spôsob) {}

			/** <p><a class="alias"></a> Alias pre {@link #ukončenieÚpravyTextu(String, int) ukončenieÚpravyTextu}.</p> */
			public void ukoncenieUpravyTextu(String text, int spôsob) {}


		// Formát

			/**
			 * <p>Táto metóda slúži na jednoduché formátovanie reálnych čísiel.
			 * Prijíma reálne číslo a hodnotu počtu desatinných miest, ktoré
			 * majú byť zobrazené.
			 * Rovnaká metóda je definovaná aj v triede {@link Svet Svet}:
			 * {@link Svet#F(double, int) F(číslo, desatinné)}.
			 * Metóda má ešte jednu verziu: {@link GRobot#F(double, int, int)
			 * Svet.F(číslo, šírka, desatinné)}.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <pre CLASS="example">
				{@code typedouble} {@code a = }{@code num10.335}{@code ;}
				{@link Svet Svet}{@code .}{@link Svet#vypíšRiadok(Object...) vypíšRiadok}{@code (}{@code srg"Hodnota: "}{@code , }{@code currF}{@code (a, }{@code num2}{@code ));}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <pre CLASS="example">
				{@code Hodnota: 10,34}
				</pre>
			 * 
			 * <p>Znak použitý na oddelenie desatinných miest naformátovaného
			 * čísla je možné zmeniť volaním metódy {@link 
			 * Svet#oddeľovačDesatinnejČasti(char) oddeľovačDesatinnejČasti}.
			 * Použitie znaku na oddelenie tisícov je možné upraviť (vypnúť,
			 * zmeniť) volaním metódy {@link Svet#oddeľovačTisícov(Character)
			 * oddeľovačTisícov}.</p>
			 * 
			 * @param číslo hodnota, ktorá má byť naformátovaná
			 * @param desatinné počet desatinných miest, ktoré majú byť uvedené
			 *     vo výslednom (naformátovanom) tvare
			 * 
			 * @see Svet#formát
			 * @see Svet#oddeľovačPrvkovPoľa(String)
			 * @see Svet#oddeľovačDesatinnejČasti(char)
			 * @see Svet#oddeľovačTisícov(Character)
			 * @see Svet#vypíš(Object[])
			 * @see Svet#F(double, int)
			 * @see Svet#F(double, int, int)
			 * @see GRobot#F(double, int, int)
			 */
			public /*static*/ String F(double číslo, int desatinné)
			{ return Svet.F(číslo, 1, desatinné); }

			/**
			 * <p>Táto metóda slúži na jednoduché formátovanie reálnych čísiel.
			 * Prijíma reálne číslo, potom hodnotu určujúcu šírku výsledného
			 * reťazca (počet znakov), na ktorú má byť zarovnaný zľava
			 * a nakoniec počet desatinných miest, ktoré majú byť zobrazené.
			 * Rovnaká metóda je definovaná aj v triede {@link Svet Svet}:
			 * {@link Svet#F(double, int, int) F(číslo, šírka, desatinné)}.
			 * Metóda má ešte jednu verziu: {@link GRobot#F(double, int)
			 * Svet.F(číslo, desatinné)}.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <pre CLASS="example">
				{@code typedouble} {@code a = }{@code num10.335}{@code ;}
				{@link Svet Svet}{@code .}{@link Svet#vypíšRiadok(Object...) vypíšRiadok}{@code (}{@code srg"1234567"}{@code , }{@link Konštanty#riadok riadok}{@code , }{@code currF}{@code (a, }{@code num7}{@code , }{@code num2}{@code ));}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <pre CLASS="example">
				{@code 1234567}
				{@code   10,34}
				</pre>
			 * 
			 * <p>Znak použitý na oddelenie desatinných miest naformátovaného
			 * čísla je možné zmeniť volaním metódy {@link 
			 * Svet#oddeľovačDesatinnejČasti(char) oddeľovačDesatinnejČasti}.
			 * Použitie znaku na oddelenie tisícov je možné upraviť (vypnúť,
			 * zmeniť) volaním metódy {@link Svet#oddeľovačTisícov(Character)
			 * oddeľovačTisícov}.</p>
			 * 
			 * @param číslo hodnota, ktorá má byť naformátovaná
			 * @param šírka najmenší počet znakov výsledného naformátovaného
			 *     reťazca (pri krátkych číslach budú chýbajúce znaky doplnené
			 *     medzerami)
			 * @param desatinné počet desatinných miest, ktoré majú byť uvedené
			 *     vo výslednom (naformátovanom) tvare
			 * 
			 * @see Svet#formát
			 * @see Svet#oddeľovačPrvkovPoľa(String)
			 * @see Svet#oddeľovačDesatinnejČasti(char)
			 * @see Svet#oddeľovačTisícov(Character)
			 * @see Svet#vypíš(Object[])
			 * @see Svet#F(double, int)
			 * @see Svet#F(double, int, int)
			 * @see GRobot#F(double, int)
			 */
			public /*static*/ String F(double číslo, int šírka, int desatinné)
			{ return Svet.F(číslo, šírka, desatinné); }


			/**
			 * <p>Táto metóda slúži na rýchly prevod rôznych objektov do
			 * textovej podoby a ich zlúčenie do jedného reťazca. Pri
			 * zlučovaní používa rovnaké pravidlá, aké sú opísané v opise
			 * metódy {@link Plátno Plátno}<code>.</code>{@link 
			 * Plátno#vypíš(Object[]) vypíš}<code>(argumenty)</code>. Súvisí
			 * to napríklad so spôsobom pridávania medzier medzi reťazce
			 * zlučovaných argumentov, automatickým formátovaním čísiel
			 * a podobne.</p>
			 * 
			 * <!-- TODO ďalšie podrobnosti? -->
			 * 
			 * <p><b>Ukážka použitia:</b></p>
			 * 
			 * <pre CLASS="example">
				{@link GRobot#text(String) text}({@code currS}({@code srg"Skóre:"}, aktuálneSkóre));
				</pre>
			 * 
			 * @param argumenty zoznam argumentov rôzneho údajového typu
			 *     oddelený čiarkami
			 * 
			 * @see Svet#vypíš(Object[])
			 * @see Svet#S(Object[])
			 */
			public /*static*/ String S(Object... argumenty)
			{ return Svet.S(argumenty); }


		// Cesta

			/**
			 * <p>Začne záznam cesty robota. Odteraz sa pohyb robota bude
			 * zaznamenávať. Zaznamenaná cesta vytvorí oblasť, ktorú je možné
			 * kedykoľvek nakresliť, vyplniť alebo obkresliť čiarou. Cesta je
			 * použiteľná aj s myšou, pozri {@link #myšVCeste() myšVCeste}.
			 * Táto metóda spustí spôsob záznamu cesty počas ktorého nebude
			 * braná do úvahy poloha pera – každá časť cesty bude pridaná tak,
			 * ako keby bolo pero položené. Takto je možné vytvoriť cestu
			 * v „tichom režime“ a dodatočne ju kompletne vykresliť. Ak
			 * chceme zmeniť spôsob záznamu, musíme použiť metódu:
			 * {@link #začniCestu(boolean)}.</p>
			 * 
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void začniCestu()
			{
				cesta.reset();
				cesta.moveTo(
					Svet.prepočítajX(aktuálneX),
					Svet.prepočítajY(aktuálneY));
				/*
				cesta.addPoint(
					(int)Svet.prepočítajX(aktuálneX),
					(int)Svet.prepočítajY(aktuálneY));
				*/
				záznamCesty = true;
				záznamCestyBezPolohyPera = true;
			}

			/** <p><a class="alias"></a> Alias pre {@link #začniCestu() začniCestu}.</p> */
			public void zacniCestu() { začniCestu(); }

			/**
			 * <p>Začne záznam novej cesty robota. Odteraz sa pohyb robota bude
			 * zaznamenávať. Zaznamenaná cesta vytvorí oblasť, ktorú je možné
			 * kedykoľvek nakresliť, vyplniť alebo obkresliť čiarou. Cesta je
			 * použiteľná aj s myšou (pozri {@link #myšVCeste() myšVCeste}).
			 * Parameter {@code rešpektujPolohuPera} určuje, či má byť počas
			 * záznamu cesty braná do úvahy aj poloha pera a výslednú cestu
			 * má byť vytvorená z rôznych častí, ktoré smú alebo nesmú byť
			 * vykreslené, podľa toho, či bolo počas záznamu cesty pero
			 * zdvihnuté alebo položené. Niekedy nie je výhodné brať do
			 * úvahy polohu pera. Napríklad ak chceme zaznamenať celú cestu
			 * v „tichom režime“ – so zdvihnutým perom a dodatočne ju
			 * kompletne vykresliť.</p>
			 * 
			 * @param rešpektujPolohuPera ak je rovné {@code valtrue},
			 *     záznam cesty bude brať do úvahy polohu pera
			 * 
			 * @see #začniCestu()
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #uzavriCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void začniCestu(boolean rešpektujPolohuPera)
			{
				cesta.reset();
				cesta.moveTo(
					Svet.prepočítajX(aktuálneX),
					Svet.prepočítajY(aktuálneY));
				/*
				cesta.addPoint(
					(int)Svet.prepočítajX(aktuálneX),
					(int)Svet.prepočítajY(aktuálneY));
				*/
				záznamCesty = true;
				záznamCestyBezPolohyPera = !rešpektujPolohuPera;
			}

			/** <p><a class="alias"></a> Alias pre {@link #začniCestu(boolean) začniCestu}.</p> */
			public void zacniCestu(boolean rešpektujPolohuPera) { začniCestu(rešpektujPolohuPera); }

			/**
			 * <p>Ukončí záznam cesty a ponechá ju na ďalšie použitie. Dokedy
			 * opätovne nepoužijeme metódu {@link #začniCestu() začniCestu}
			 * alebo metódu {@link #zrušCestu() zrušCestu}, je zaznamenaná
			 * cesta opakovane použiteľná.</p>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #zrušCestu()
			 * @see #uzavriCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void skončiCestu()
			{
				záznamCesty = false;
				záznamCestyBezPolohyPera = true;
			}

			/** <p><a class="alias"></a> Alias pre {@link #skončiCestu() skončiCestu}.</p> */
			public void skonciCestu() { skončiCestu(); }

			/**
			 * <p>Ukončí a zmaže záznam cesty.</p>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #uzavriCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void zrušCestu()
			{
				cesta.reset();
				záznamCesty = false;
				záznamCestyBezPolohyPera = true;
			}

			/** <p><a class="alias"></a> Alias pre {@link #zrušCestu() zrušCestu}.</p> */
			public void zrusCestu() { zrušCestu(); }

			/**
			 * <p>Ukončí záznam cesty, uzavrie cestu (prepojí posledný bod
			 * s prvým bodom posledného kresleného segmentu) a ponechá ju na
			 * ďalšie použitie. Dokedy opätovne nepoužijeme metódu {@link 
			 * #začniCestu() začniCestu} alebo metódu {@link #zrušCestu()
			 * zrušCestu}, je zaznamenaná cesta ľubovoľný počet ráz
			 * použiteľná.</p>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void uzavriCestu()
			{
				if (záznamCesty)
				{
					cesta.closePath();
					záznamCesty = false;
					záznamCestyBezPolohyPera = true;
				}
			}


			/** <p><a class="alias"></a> Alias pre {@link #uzavriCestu() uzavriCestu}.</p> */
			public void zavriCestu() { uzavriCestu(); }

			/**
			 * <p>Ukončí záznam cesty a vyplní zaznamenanú cestu aktuálnou
			 * farbou robota.</p>
			 * 
			 * <p class="tip"><b>Tip:</b> Ak chcete vytvorenú cestu rotovať
			 * alebo posúvať, vytvorte z nej {@link Oblasť oblasť} a použite
			 * metódu {@link #vyplňOblasť(Area) vyplňOblasť} alebo použite
			 * triedu {@link SVGPodpora SVGPodpora}, ktorá má definované
			 * {@linkplain SVGPodpora#dajVýsledný(Shape,
			 * SVGPodpora.Transformácia,
			 * SVGPodpora.Transformácia[]) metódy na ľubovoľnú
			 * transformáciu tvarov}.</p>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #uzavriCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void vyplňCestu()
			{
				poslednýTypTvaru = TypTvaru.VÝPLŇ;
				/*
				 * @throws RuntimeException ak cesta nejestvuje
				if (0 == cesta.npoints) throw new RuntimeException("Cesta " +
					"nejestvuje. Na jej vytvorenie použite pred začatím " +
					"pohybu robota po podlahe alebo strope metódu " +
					"začniCestu().");
				*/
				záznamCesty = false;
				záznamCestyBezPolohyPera = true;
				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
				grafikaAktívnehoPlátna.fill(cesta);
				// grafikaAktívnehoPlátna.fillPolygon(cesta);
				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňCestu() vyplňCestu}.</p> */
			public void vyplnCestu() { vyplňCestu(); }

			/**
			 * <p>Ukončí záznam cesty a nakreslí zaznamenanú cestu aktuálnou
			 * farbou a hrúbkou čiary.</p>
			 * 
			 * <p>Použitie tohto príkazu sa stáva nenahraditeľným napríklad
			 * v prípade, že chceme použiť polopriehľadné pero, ktoré pri
			 * klasickom kreslení zanecháva v uzlových bodoch pohybu robota
			 * prebytočnú farbu. Vtedy je v podstate nevyhnutné zvoliť
			 * nasledujúci postup:</p>
			 * 
			 * <ol>
			 * <li>zdvihnúť pero robota,</li>
			 * <li>začať záznam cesty (spôsobom „bez ohľadu na polohu
			 * pera“),</li>
			 * <li>vykonať potrebné pohyby robotom</li>
			 * <li>a použiť túto metódu na nakreslenie výslednej
			 * cesty.</li>
			 * </ol>
			 * 
			 * <p>Bez ohľadu na uvedený prípad, metóda je použiteľná
			 * ľubovoľne. Napríklad ak chceme dráhu robota prekresliť po
			 * inom kreslení (čím ju v podstate dostaneme do popredia)
			 * a podobne.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Otvorená cesta sa odlišuje
			 * od uzavretej. Metódy robota {@link #uzavriCestu() uzavriCestu}
			 * a {@link #obkresliCestu() obkresliCestu} spôsobujú uzavretie
			 * cesty, ostatné metódy spôsobujúce ukončenie záznamu cesty,
			 * vrátane tejto, nechávajú cestu otvorenou. V súčasnej verzii
			 * programovacieho rámca je možné transformovať, to jest napríklad
			 * rotovať alebo posúvať, aj otvorené cesty, a to vďaka novej
			 * triede {@link SVGPodpora SVGPodpora}, ktorá má definované
			 * {@linkplain SVGPodpora#dajVýsledný(Shape,
			 * SVGPodpora.Transformácia, SVGPodpora.Transformácia[]) metódy
			 * na ľubovoľnú transformáciu akéhokoľvek tvaru}.
			 * <!-- TODO overiť nové možnosti transformácie tvarov podľa
			 * aktuálnych vlastností robota a spomenúť to tu. -->
			 * Uzavretú cestu je možné rotovať a/alebo posúvať i tak, že sa
			 * z nej vytvorí {@link Oblasť oblasť} a použije sa metóda
			 * {@link #obkresliOblasť(Area) obkresliOblasť}.</p>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #uzavriCestu()
			 * @see #vyplňCestu()
			 * @see #obkresliCestu()
			 * @see #cesta()
			 */
			public void kresliCestu()
			{
				poslednýTypTvaru = TypTvaru.OBRYS;
				/*
				 * @throws RuntimeException ak cesta nejestvuje
				if (0 == cesta.npoints) throw new RuntimeException("Cesta " +
					"nejestvuje. Na jej vytvorenie použite pred začatím " +
					"pohybu robota po podlahe alebo strope metódu " +
					"začniCestu().");
				*/
				záznamCesty = false;
				záznamCestyBezPolohyPera = true;
				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
				grafikaAktívnehoPlátna.setStroke(čiara);
				grafikaAktívnehoPlátna.draw(cesta);
				// grafikaAktívnehoPlátna.drawPolyline(cesta.xpoints, cesta.ypoints, cesta.npoints);
				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/**
			 * <p>Táto metóda funguje rovnako ako keby sme volali metódy {@link 
			 * #uzavriCestu() uzavriCestu} a {@link #kresliCestu()
			 * kresliCestu} za sebou (v uvedenom poradí). To znamená, že
			 * cesta sa uzavrie vtedy a len vtedy, ak ešte stále v čase jej
			 * volania prebieha záznam cesty, ktorý je súčasne s jej volaním
			 * ukončený. Potom je vykreslená výsledná cesta.</p>
			 * 
			 * <p class="tip"><b>Tip:</b> Ak chcete vytvorenú cestu rotovať
			 * a/alebo posúvať, vytvorte z nej {@link Oblasť oblasť}
			 * a použite metódu {@link #obkresliOblasť(Area) obkresliOblasť}
			 * alebo použite triedu {@link SVGPodpora SVGPodpora}, ktorá
			 * má definované {@linkplain SVGPodpora#dajVýsledný(Shape,
			 * SVGPodpora.Transformácia,
			 * SVGPodpora.Transformácia[]) metódy na ľubovoľnú
			 * transformáciu tvarov}.</p>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #uzavriCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #cesta()
			 */
			public void obkresliCestu()
			{
				poslednýTypTvaru = TypTvaru.OBRYS;
				/*
				 * @throws RuntimeException ak cesta nejestvuje
				if (0 == cesta.npoints) throw new RuntimeException("Cesta " +
					"nejestvuje. Na jej vytvorenie použite pred začatím " +
					"pohybu robota po podlahe alebo strope metódu " +
					"začniCestu().");
				*/
				if (záznamCesty)
				{
					cesta.closePath();
					záznamCesty = false;
					záznamCestyBezPolohyPera = true;
				}

				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
				grafikaAktívnehoPlátna.setStroke(čiara);
				grafikaAktívnehoPlátna.draw(cesta);
				// grafikaAktívnehoPlátna.drawPolygon(cesta);
				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}


			/**
			 * <p>Ukončí záznam cesty a vráti cestu ako tvar. Metóda je
			 * využiteľná (respektíve tvar, ktorý vracia je využiteľný) na
			 * tvorbu {@linkplain Oblasť oblasti}, {@linkplain 
			 * #nekresliDo(Shape) obmedzenie kreslenia}, {@linkplain 
			 * SVGPodpora#dajVýsledný(Shape, SVGPodpora.Transformácia,
			 * SVGPodpora.Transformácia[]) vytvorenie transformovaného
			 * tvaru} a podobne.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>V nasledujúcom príklade najskôr zaznamenáme otvorenú
			 * cestu v tvare lomenej čiary a túto cestu potom využijeme na
			 * nakreslenie útvaru podobného mandale. Namiesto volania
			 * metódy {@code currcesta} by bolo možné využiť triedu Javy
			 * {@link Shape Shape} na uchovanie objektu cesty, aby bolo
			 * vykonávanie príkladu mierne efektívnejšie. Komentáre
			 * v príklade ukazujú, ako by sa to dalo docieliť.</p>
			 * 
			 * <p>Na ozrejmenie fungovania príkladu je dôležité poukázať
			 * na rozdiel medzi súradnicovým priestorom Javy (predvoleným
			 * súradnicovým priestorom, ktorý je používaný v oblasti
			 * 2D počítačovej grafiky) a súradnicovým priestorom
			 * programovacieho rámca GRobot (ktorý je v podstate štandardným
			 * karteziánskym súradnicovým priestorom). Zhňme to v dvoch
			 * samostatných bodoch:</p>
			 * 
			 * <ul>
			 * 
			 * <li>Java predvolene pracuje so súradnicovým systémom,
			 * ktorý je bežne používaný v 2D počítačovej grafike. Stred,
			 * respektíve počiatok, súradnicovej sústavy (to jest bod so
			 * súradnicami [0, 0]) je umiestnený vždy v ľavom hornom rohu
			 * zobrazovanej oblasti (buď celej obrazovky, obrázka, plátna,
			 * alebo niečoho podobného). Hodnoty na x-ovej, respektíve
			 * horizontálnej, osi rastú zľava doprava (to je spoločné pre
			 * obidva súradnicové systémy) a hodnoty y-ovej, respektíve
			 * vertikálnej, osi rastú zhora nadol (čiže presne opačne než
			 * pri klasickom karteziánskom súradnicovom systéme).</li>
			 * 
			 * <li>Súradnicový systém programovacieho rámca GRobot má
			 * počiatok súradnicovej sústavy v strede plátna a aby sme
			 * to skrátili, tak jediným ďalším rozdielom oproti
			 * predchádzajúcemu systému je smer rastu hodnôt vertikálnej
			 * osi – zospodu nahor (čiže rovnako ako pri klasickom
			 * karteziánskom súradnicovom systéme).</li>
			 * 
			 * </ul>
			 * 
			 * <p>Tento rozdiel sa prejavuje aj pri transformáciách triedy
			 * {@link SVGPodpora SVGPodpora}. V nasledujúcom príklade je
			 * na riadku 47 príkaz transformácie otočenia
			 * ({@code kwdnew}{@code 
			 *  }{@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int,
			 * java.lang.Double[]) Transformácia}{@code (}{@link 
			 * SVGPodpora.Transformácia Transformácia}{@code .}{@link 
			 * SVGPodpora.Transformácia#OTOČ OTOČ}…), ktorý
			 * má posunutý stred otáčania do bodu [200, 200]. Sú to
			 * súradnice vyjadrené v súradnicovom systéme Javy. Tento bod
			 * v tomto prípade korešponduje so stredom súradnicovej sústavy
			 * programovacieho rámca GRobot, ktorý je vždy prepočítavaný podľa
			 * aktuálnych rozmerov plátien tak, aby bol v ich strede. Na
			 * riadku 14 je volanie nadradeného konštruktora ({@code 
			 * valsuper}{@code (}{@code num400}{@code , }{@code num400}{@code 
			 * )}{@code ;}), ktoré nastavuje rozmery plátien na 400 × 400
			 * bodov a z toho vyplýva, že aktuálny stred súradnicovej
			 * sústavy programovacieho rámca je posunutý do bodu [200, 200]
			 * súradnicového priestoru Javy.</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdimport} knižnica.*;
				{@code kwdimport} knižnica.{@link SVGPodpora SVGPodpora}.{@link Transformácia Transformácia};

				{@code comm// Ak by sme sa rozhodli využiť triedu Javy }{@link Shape Shape}{@code comm, tak takto by sme ju}
				{@code comm// importovali:}
				{@code comm// import java.awt.Shape;}

				{@code kwdpublic} {@code typeclass} TvarZCesty {@code kwdextends} {@link GRobot GRobot}
				{
					{@code comm// Konštruktor}
					{@code kwdpublic} TvarZCesty()
					{
						{@code comm// Nastavenie romerov plátna na 400 × 400 bodov:}
						{@code valsuper}({@code num400}, {@code num400});

						{@code comm// Zdvihnutie pera a zahájenie záznamu cesty:}
						{@link #zdvihniPero() zdvihniPero}();
						{@link #začniCestu() začniCestu}();

						{@code comm// „Nakreslenie“ cesty (jej zaznamenanie do vnútornej pamäte robota):}
						{@link #dopredu(double) dopredu}({@code num60});
						{@link #vpravo(double) vpravo}({@code num60});
						{@link #dopredu(double) dopredu}({@code num60});
						{@link #vľavo(double) vľavo}({@code num120});
						{@link #dopredu(double) dopredu}({@code num60});
						{@link #vpravo(double) vpravo}({@code num60});
						{@link #dopredu(double) dopredu}({@code num60});

						{@code comm// Ak by sme sa rozhodli využiť triedu Javy Shape,}
						{@code comm// tak takto by definovali jej inštanciu:}
						{@code comm// }{@link Shape Shape}{@code comm cesta = }{@code currcesta}{@code comm();}

						{@code comm// Úprava hrúbky čiary:}
						{@link #hrúbkaČiary(double) hrúbkaČiary}({@code num2.5});

						{@code comm// Kreslenie transformovanej cesty:}
						{@code kwdfor} ({@code typeint} i = {@code num0}; i &lt; {@code num12}; ++i)
						{
							{@link #náhodnáFarba() náhodnáFarba}();

							{@code comm// Ak by sme sa rozhodli využiť triedu Javy Shape, tak na}
							{@code comm// nasledujúcom riadku by nebolo volanie metódy „cesta(),“ ale}
							{@code comm// použitie inštancie triedy Shape: „cesta“ (zjednodušene}
							{@code comm// povedané by bolo treba zmazať zátvorky za identifikátorom}
							{@code comm// „cesta“):}
							{@link Plátno podlaha}.{@link Plátno#kresli(Shape) kresli}({@link SVGPodpora SVGPodpora}.{@link SVGPodpora#dajVýsledný(Shape, SVGPodpora.Transformácia, SVGPodpora.Transformácia[]) dajVýsledný}({@code currcesta}(),
								{@code kwdnew} {@link SVGPodpora.Transformácia#SVGPodpora.Transformácia(int, java.lang.Double[]) Transformácia}({@link SVGPodpora.Transformácia Transformácia}.{@link SVGPodpora.Transformácia#OTOČ OTOČ},
									i * {@code num30.0}, {@code num200.0}, {@code num200.0})));
						}
					}

					{@code comm// Hlavná metóda.}
					{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}... args)
					{
						{@link Svet Svet}.{@link Svet#použiKonfiguráciu(String) použiKonfiguráciu}({@code srg"tvar-z-cesty.cfg"});
						{@code kwdnew} TvarZCesty();
					}
				}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <table class="centered">
			 * <tr><td><image>tvarZCesty1.png<alt/></image></td>
			 * <td><image>tvarZCesty2.png<alt/></image></td></tr>
			 * <tr><td colspan="2"><p class="image">Dve ukážky možných
			 * výsledkov kreslenia príkladu.</p></td></tr></table>
			 * 
			 * @see #začniCestu()
			 * @see #začniCestu(boolean)
			 * @see #skončiCestu()
			 * @see #zrušCestu()
			 * @see #uzavriCestu()
			 * @see #vyplňCestu()
			 * @see #kresliCestu()
			 * @see #obkresliCestu()
			 * @see #kružnica(double)
			 * @see #kruh(double)
			 * @see #elipsa(double, double)
			 * @see #kresliElipsu(double, double)
			 * @see #vyplňElipsu(double, double)
			 * @see #štvorec(double)
			 * @see #kresliŠtvorec(double)
			 * @see #vyplňŠtvorec(double)
			 * @see #obdĺžnik(double, double)
			 * @see #kresliObdĺžnik(double, double)
			 * @see #vyplňObdĺžnik(double, double)
			 * @see #hviezda(double)
			 * @see #kresliHviezdu(double)
			 * @see #vyplňHviezdu(double)
			 * @see #kružnica()
			 * @see #kruh()
			 * @see #elipsa(double)
			 * @see #kresliElipsu(double)
			 * @see #vyplňElipsu(double)
			 * @see #štvorec()
			 * @see #kresliŠtvorec()
			 * @see #vyplňŠtvorec()
			 * @see #obdĺžnik(double)
			 * @see #kresliObdĺžnik(double)
			 * @see #vyplňObdĺžnik(double)
			 * @see #hviezda()
			 * @see #kresliHviezdu()
			 * @see #vyplňHviezdu()
			 * @see #text(String)
			 * @see #text(String, int)
			 */
			public Shape cesta()
			{
				poslednýTypTvaru = TypTvaru.NIČ;
				/*
				 * @throws RuntimeException ak cesta nejestvuje
				if (0 == cesta.npoints) throw new RuntimeException("Cesta " +
					"nejestvuje. Na jej vytvorenie použite pred začatím " +
					"pohybu robota po podlahe alebo strope metódu " +
					"začniCestu().");
				Ak cesta nejestvuje, metóda spôsobí vznik výnimky.
				*/
				záznamCesty = false;
				záznamCestyBezPolohyPera = true;
				return new Path2D.Double(cesta);
			}

			/** <p><a class="alias"></a> Alias pre {@link #cesta() cesta}.</p> */
			public Shape cestu() { return cesta(); }

			/** <p><a class="alias"></a> Alias pre {@link #cesta() cesta}.</p> */
			public Shape cesty() { return cesta(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice myši nachádzajú v uzavretej
			 * oblasti cesty, ktorá bola zaznamenaná kreslením aktuálneho
			 * robota od posledného použitia metódy {@link #začniCestu()
			 * začniCestu}. Cesta je zaznamenávaná až do použitia metód {@link 
			 * #skončiCestu() skončiCestu}, {@link #zrušCestu() zrušCestu},
			 * {@link #vyplňCestu() vyplňCestu} alebo {@link #kresliCestu()
			 * kresliCestu}. Dokedy opätovne nepoužijeme metódu {@link 
			 * #začniCestu() začniCestu} alebo metódu {@link #zrušCestu()
			 * zrušCestu}, je zaznamenaná cesta opakovane použiteľná.</p>
			 * 
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #myšVElipse(double, double)
			 * @see #myšVKruhu(double)
			 * @see #myšVPôsobisku()
			 * @see #myšVoŠtvorci(double)
			 * @see #myšVObdĺžniku(double, double)
			 * @see #myšVHviezde(double)
			 * @see #myšVOblasti(Area)
			 */
			public boolean myšVCeste()
			{
				return cesta.contains(
					Svet.prepočítajX(ÚdajeUdalostí.súradnicaMyšiX),
					Svet.prepočítajY(ÚdajeUdalostí.súradnicaMyšiY));
			}

			/** <p><a class="alias"></a> Alias pre {@link #myšVCeste() myšVCeste}.</p> */
			public boolean mysVCeste() { return myšVCeste(); }

			/**
			 * <p>Zistí, či sa aktuálne súradnice zadaného bodu nachádzajú
			 * v uzavretej oblasti cesty, ktorá bola zaznamenaná kreslením
			 * aktuálneho robota od posledného použitia metódy {@link 
			 * #začniCestu() začniCestu}. Cesta je zaznamenávaná až do
			 * použitia metód {@link #skončiCestu() skončiCestu}, {@link 
			 * #zrušCestu() zrušCestu}, {@link #vyplňCestu() vyplňCestu}
			 * alebo {@link #kresliCestu() kresliCestu}. Dokedy opätovne
			 * nepoužijeme metódu {@link #začniCestu() začniCestu} alebo
			 * metódu {@link #zrušCestu() zrušCestu}, je zaznamenaná cesta
			 * opakovane použiteľná. Nasledujúca metóda dovoľuje namiesto
			 * súradníc bodu použiť objekt: {@link #bodVCeste(Poloha)
			 * bodVCeste(Poloha objekt)}.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVOblasti(double, double, Area)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVCeste(double súradnicaBoduX, double súradnicaBoduY)
			{
				return cesta.contains(Svet.prepočítajX(súradnicaBoduX),
					Svet.prepočítajY(súradnicaBoduY));
			}

			// /**
				//  * <p>Zistí, či sa súradnice zadaného bodu nachádzajú
				//  * v uzavretej oblasti cesty, ktorá bola zaznamenaná
				//  * kreslením aktuálneho robota od posledného použitia
				//  * metódy {@link #začniCestu() začniCestu}. Cesta je
				//  * zaznamenávaná až do použitia metód {@link #skončiCestu()
				//  * skončiCestu}, {@link #zrušCestu() zrušCestu},
				//  * {@link #vyplňCestu() vyplňCestu} alebo {@link #kresliCestu()
				//  * kresliCestu}. Dokedy opätovne nepoužijeme metódu {@link 
				//  * #začniCestu() začniCestu} alebo metódu {@link #zrušCestu()
				//  * zrušCestu}, je zaznamenaná cesta opakovane použiteľná.</p>
				//  * 
				//  * @param bod súradnice bodu
				//  * @return {@code valtrue} – áno; {@code valfalse} – nie
				//  * 
				//  * @see #bodVPôsobisku(Point2D)
				//  * @see #bodVKruhu(Point2D, double)
				//  * @see #bodVElipse(Point2D, double, double)
				//  * @see #bodVoŠtvorci(Point2D, double)
				//  * @see #bodVObdĺžniku(Point2D, double, double)
				//  * @see #bodVOblasti(Point2D, Area)
				//  * @see #bodVTvare(Point2D, Shape)
				//  */
				// public boolean bodVCeste(Point2D bod)
				// {
				// 	return cesta.contains(Svet.prepočítajX(bod.getX()),
				// 		Svet.prepočítajY(bod.getY()));
				// }

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVCeste(double, double)
			 * bodVCeste(x, y)}, len namiesto súradníc bodu je použitá poloha
			 * zadaného objektu…</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVOblasti(Poloha, Area)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVCeste(Poloha objekt)
			{
				return cesta.contains(Svet.prepočítajX(objekt.polohaX()),
					Svet.prepočítajY(objekt.polohaY()));
			}


		// Oblasti

			/**
			 * <p>Zamestná tento robot na účely tvorby, prípadne kreslenia,
			 * zadanej oblasti. Má rovnaký efekt ako volanie metódy {@link 
			 * Oblasť#zamestnaj(GRobot) oblasť.zamestnaj(robot)}. Od okamihu
			 * zamestnania stráca robot dočasne svoje schopnosti kreslenia
			 * útvarov a písania textov. Je to z dôvodu ich presunutia do
			 * tvorby {@linkplain Oblasť oblasti}. Zamestnaný robot nekreslí
			 * útvary ani nie je schopný písať texty dovtedy, kým nie je zo
			 * služby {@linkplain #uvoľni(Oblasť) uvoľnený}
			 * ({@linkplain #prepusti(Oblasť) prepustený}).</p>
			 * 
			 * <p>Robot nesmie byť zamestnaný pre inú oblasť, lebo vznikne
			 * výnimka.</p>
			 * 
			 * @param oblasť objekt typu {@link Oblasť}
			 * 
			 * @throws GRobotException ak je robot zamestnaný pre inú oblasť
			 * 
			 * @see #uvoľni(Oblasť)
			 * @see #uvoľni()
			 * @see #zamestnaný()
			 * @see #zamestnaný(Oblasť)
			 */
			public void zamestnaj(Oblasť oblasť) { oblasť.zamestnaj(this); }

			/**
			 * <p>Uvoľní tento robot z úloh tvorby (prípadne kreslenia) zadanej
			 * oblasti. Má rovnaký efekt ako volanie metódy {@link 
			 * Oblasť#uvoľni(GRobot) oblasť.uvoľni(robot)}. Ak tento robot
			 * nebol zamestnaný pre zadanú oblasť, tak nemá volanie metódy
			 * žiadny efekt.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov {@code curruvoľni} má
			 * v programovacom rámci GRobot deväť rôznych metód:
			 * {@link GRobot GRobot}{@code .}{@link GRobot#uvoľni()
			 * uvoľni}{@code ()},
			 * {@link GRobot GRobot}{@code .}{@link GRobot#uvoľni(Oblasť)
			 * uvoľni}{@code (}{@link Oblasť Oblasť}{@code )},
			 * {@link Oblasť Oblasť}{@code .}{@link Oblasť#uvoľni()
			 * uvoľni}{@code ()},
			 * {@link Oblasť Oblasť}{@code .}{@link Oblasť#uvoľni(GRobot)
			 * uvoľni}{@code (}{@link GRobot GRobot}{@code )} –
			 * slúžia na uvoľnenie robota zo zamestnania pre stanovenú
			 * oblasť (čo je geometrická trieda),
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni() uvoľni}{@code ()} –
			 * slúži na uvoľnenie hlavného okna sveta, t. j. umožnenie
			 * zmeny veľkosti okna používateľovi (ide o opak metódy {@link 
			 * Svet#upevni() Svet.upevni}) a nakoniec
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(GRobot)
			 * uvoľni}{@code (}{@link GRobot GRobot}{@code )},
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(java.lang.Class)
			 * uvoľni}{@code (}{@link java.lang.Class Class}{@code )},
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(Plazma)
			 * uvoľni}{@code (}{@link Plazma Plazma}{@code )}
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(Obrázok)
			 * uvoľni}{@code (}{@link Obrázok Obrázok}{@code )}
			 * a {@link Svet Svet}{@code .}{@link Svet#uvoľni(java.lang.String)
			 * uvoľni}{@code (}{@link java.lang.String String}{@code )} –
			 * slúžia na uvoľňovanie nepotrebných inštancií robotov,
			 * vytvorených alebo prečítaných obrázkov a prečítaných zvukov
			 * z vnútorných zoznamov zdrojov (robotov, obrázkov, zvukov), čo
			 * je jednak nevyhnutnou podmienkou ich úspešného vymazania
			 * z pamäte zberačom odpadkov Javy a jednak to môže byť niekedy
			 * potrebné (napríklad ak sa obsah súboru so zdrojom uloženým na
			 * disku zmenil).</p>
			 * 
			 * @param oblasť objekt typu {@link Oblasť}
			 * 
			 * @see #zamestnaj(Oblasť)
			 * @see #uvoľni()
			 * @see #zamestnaný()
			 * @see #zamestnaný(Oblasť)
			 */
			public void uvoľni(Oblasť oblasť) { oblasť.uvoľni(this); }

			/** <p><a class="alias"></a> Alias pre {@link #uvoľni(Oblasť) uvoľni}.</p> */
			public void uvolni(Oblasť oblasť) { uvoľni(oblasť); }

			/** <p><a class="alias"></a> Alias pre {@link #uvoľni(Oblasť) uvoľni}.</p> */
			public void prepusti(Oblasť oblasť) { uvoľni(oblasť); }

			/**
			 * <p>Automaticky uvoľní robot z úloh tvorby (prípadne kreslenia)
			 * oblasti. Má podobný efekt ako volanie metódy {@link 
			 * Oblasť#uvoľni() oblasť.uvoľni()}. Ak robot nebol zamestnaný pre
			 * žiadnu oblasť, tak nemá volanie metódy žiadny efekt.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov {@code curruvoľni} má
			 * v programovacom rámci GRobot deväť rôznych metód:
			 * {@link GRobot GRobot}{@code .}{@link GRobot#uvoľni()
			 * uvoľni}{@code ()},
			 * {@link GRobot GRobot}{@code .}{@link GRobot#uvoľni(Oblasť)
			 * uvoľni}{@code (}{@link Oblasť Oblasť}{@code )},
			 * {@link Oblasť Oblasť}{@code .}{@link Oblasť#uvoľni()
			 * uvoľni}{@code ()},
			 * {@link Oblasť Oblasť}{@code .}{@link Oblasť#uvoľni(GRobot)
			 * uvoľni}{@code (}{@link GRobot GRobot}{@code )} –
			 * slúžia na uvoľnenie robota zo zamestnania pre stanovenú
			 * oblasť (čo je geometrická trieda),
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni() uvoľni}{@code ()} –
			 * slúži na uvoľnenie hlavného okna sveta, t. j. umožnenie
			 * zmeny veľkosti okna používateľovi (ide o opak metódy {@link 
			 * Svet#upevni() Svet.upevni}) a nakoniec
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(GRobot)
			 * uvoľni}{@code (}{@link GRobot GRobot}{@code )},
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(java.lang.Class)
			 * uvoľni}{@code (}{@link java.lang.Class Class}{@code )},
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(Plazma)
			 * uvoľni}{@code (}{@link Plazma Plazma}{@code )}
			 * {@link Svet Svet}{@code .}{@link Svet#uvoľni(Obrázok)
			 * uvoľni}{@code (}{@link Obrázok Obrázok}{@code )}
			 * a {@link Svet Svet}{@code .}{@link Svet#uvoľni(java.lang.String)
			 * uvoľni}{@code (}{@link java.lang.String String}{@code )} –
			 * slúžia na uvoľňovanie nepotrebných inštancií robotov,
			 * vytvorených alebo prečítaných obrázkov a prečítaných zvukov
			 * z vnútorných zoznamov zdrojov (robotov, obrázkov, zvukov), čo
			 * je jednak nevyhnutnou podmienkou ich úspešného vymazania
			 * z pamäte zberačom odpadkov Javy a jednak to môže byť niekedy
			 * potrebné (napríklad ak sa obsah súboru so zdrojom uloženým na
			 * disku zmenil).</p>
			 * 
			 * @see #zamestnaj(Oblasť)
			 * @see #uvoľni(Oblasť)
			 * @see #zamestnaný()
			 * @see #zamestnaný(Oblasť)
			 */
			public void uvoľni()
			{
				if (null != zamestnanýPre)
				{
					zamestnanýPre.zamestnanec = null;
					kresliTvary = true;
					zamestnanýPre = null;
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #uvoľni() uvoľni}.</p> */
			public void uvolni() { uvoľni(); }

			/** <p><a class="alias"></a> Alias pre {@link #uvoľni(Oblasť) uvoľni}.</p> */
			public void prepusti() { uvoľni(); }

			/**
			 * <p>Overí, či je tento robot zamestnaný pre potreby niektorej
			 * oblasti.</p>
			 * 
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #zamestnaj(Oblasť)
			 * @see #uvoľni(Oblasť)
			 * @see #uvoľni()
			 * @see #zamestnaný(Oblasť)
			 */
			public boolean zamestnaný() { return zamestnanýPre != null; }

			/** <p><a class="alias"></a> Alias pre {@link #zamestnaný() zamestnaný}.</p> */
			public boolean zamestnany() { return zamestnanýPre != null; }

			/**
			 * <p>Overí, či je tento robot zamestnaný pre potreby
			 * určenej oblasti.</p>
			 * 
			 * @param oblasť cieľová oblasť
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see #zamestnaj(Oblasť)
			 * @see #uvoľni(Oblasť)
			 * @see #uvoľni()
			 * @see #zamestnaný()
			 */
			public boolean zamestnaný(Oblasť oblasť)
			{ return zamestnanýPre == oblasť; }

			/** <p><a class="alias"></a> Alias pre {@link #zamestnaný(Oblasť) zamestnaný}.</p> */
			public boolean zamestnany(Oblasť oblasť)
			{ return zamestnanýPre == oblasť; }


			/**
			 * <p>Obkreslí zadanú oblasť hrúbkou a farbou čiary nastavenou pre
			 * tento robot. Oblasť rotuje podľa smeru robota (za východisko
			 * je považovaných 90°; odchýlka v kladom alebo zápornom smere
			 * náležite rotuje oblasť) a posunie o súradnice robota na plátne
			 * (stred sa nachádza v bode [0, 0] – v strede plátna; ak je
			 * robot v strede plátna, poloha oblasti sa nezmení).</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * @param oblasť objekt typu {@link Area} (resp. {@link Oblasť})
			 * 
			 * @see Oblasť#kresli()
			 * @see Oblasť#kresli(GRobot)
			 */
			public void obkresliOblasť(Area oblasť)
			{
				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);
				grafikaAktívnehoPlátna.setStroke(čiara);

				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
				{
					grafikaAktívnehoPlátna.draw(oblasť);
					aktualizujPôsobisko(oblasť.getBounds2D());
				}
				else
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					Area a = oblasť.createTransformedArea(at);

					grafikaAktívnehoPlátna.draw(a);
					aktualizujPôsobisko(a.getBounds2D());
				}

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #obkresliOblasť(Area) obkresliOblasť}.</p> */
			public void obkresliOblast(Area oblasť) { obkresliOblasť(oblasť); }

			/**
			 * <p>Vyplní plochu zadanej oblasti farbou nastavenou pre tento
			 * robot, pričom vypĺňanú oblasť rotuje podľa smeru robota (za
			 * východisko je považovaných 90°; odchýlka v kladom alebo
			 * zápornom smere náležite rotuje oblasť) a posúva ju o súradnice
			 * robota na plátne (stred sa nachádza v bode [0, 0] – v strede
			 * plátna; ak je robot v strede plátna, poloha oblasti sa
			 * nezmení).</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * @param oblasť objekt typu {@link Area} (resp. {@link Oblasť})
			 * 
			 * @see Oblasť#vyplň()
			 * @see Oblasť#vyplň(GRobot)
			 */
			public void vyplňOblasť(Area oblasť)
			{
				// grafikaAktívnehoPlátna.setColor(farbaRobota);
				nastavVlastnostiGrafiky(grafikaAktívnehoPlátna);
				nastavFarbuAleboVýplňPodľaRobota(grafikaAktívnehoPlátna);

				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
				{
					grafikaAktívnehoPlátna.fill(oblasť);
					aktualizujPôsobisko(oblasť.getBounds2D());
				}
				else
				{
					AffineTransform at = new AffineTransform();

					// (Na tejto metóde som testoval mierku. Odtiaľto
					// sa to rozkopírovalo do celého programovacieho rámca…)
					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
						// System.out.println("mierka: " + mierka);
					}

					at.translate(aktuálneX, -aktuálneY);
					Area a = oblasť.createTransformedArea(at);

					grafikaAktívnehoPlátna.fill(a);
					aktualizujPôsobisko(a.getBounds2D());
				}

				obnovVlastnostiGrafiky(grafikaAktívnehoPlátna);
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňOblasť(Area) vyplňOblasť}.</p> */
			public void vyplnOblast(Area oblasť) { vyplňOblasť(oblasť); }

			/**
			 * <p>Vyplní plochu zadanej oblasti zadanou textúrou, pričom oblasť
			 * rotuje podľa smeru<sup>[1]</sup> robota a posúva ju
			 * o súradnice<sup>[2]</sup> robota na plátne. Rotácia a poloha
			 * textúry nie sú nijako ovplyvňované polohou a smerom robota.
			 * Textúra je zadaná ako názov súboru s obrázkom, ktorý bude
			 * použitý na dlaždicové vyplnenie plochy oblasti.</p>
			 * 
			 * <p><small>[1] – za východisko je považovaných 90°; odchýlka
			 * v kladom alebo zápornom smere náležite rotuje
			 * oblasť.</small><br />
			 * <small>[2] – stred sa nachádza v bode [0, 0] – v strede
			 * plátna; ak je robot v strede plátna, poloha oblasti sa
			 * nezmení.</small></p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Parametre textúry sa dajú
			 * ovplyvňovať špeciálnymi príkazmi. Súvisí s nimi i predvolené
			 * správanie príkazov vypĺňania. Predvolený bod začiatku vypĺňania
			 * dlaždicami sa nachádza v strede plátna alebo vypĺňaného
			 * obrázka. Pozrite si aj opis metódy
			 * {@link Svet#posunutieVýplne(double, double) posunutieVýplne},
			 * kde nájdete príklad použitia a odkazy na metódy
			 * upravujúce ďalšie parametre obrázkových výplní.</p>
			 * 
			 * @param oblasť objekt typu {@link Area} (resp. {@link Oblasť})
			 * @param súbor názov súboru s obrázkom textúry
			 * 
			 * @throws GRobotException ak súbor s obrázkom nebol nájdený
			 * 
			 * @see Svet#priečinokObrázkov()
			 * @see Svet#priečinokObrázkov(String)
			 * @see Oblasť#vyplň(String)
			 * @see Oblasť#vyplň(GRobot, String)
			 */
			public void vyplňOblasť(Area oblasť, String súbor)
			{
				BufferedImage obrázok = Obrázok.súborNaObrázok(súbor);

				grafikaAktívnehoPlátna.setPaint(
					new TexturePaint(obrázok, new Rectangle2D.Double(
						Svet.posuňVýplňX, Svet.posuňVýplňY,
						obrázok.getWidth()  * Svet.mierkaVýplneX,
						obrázok.getHeight() * Svet.mierkaVýplneY)));

				Area a = oblasť; double β = 0.0;

				if (0 != Svet.otočVýplňΑ)
				{
					β = toRadians(Svet.otočVýplňΑ);
					grafikaAktívnehoPlátna.rotate(-β,
						Svet.otočVýplňX, Svet.otočVýplňY);
					a = oblasť.createTransformedArea(
						AffineTransform.getRotateInstance(β,
						Svet.otočVýplňX, Svet.otočVýplňY));
				}

				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
				{
					grafikaAktívnehoPlátna.fill(a);
					aktualizujPôsobisko(oblasť.getBounds2D());
				}
				else
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					oblasť = oblasť.createTransformedArea(at);

					if (0 != Svet.otočVýplňΑ)
						a = oblasť.createTransformedArea(
							AffineTransform.getRotateInstance(β,
							Svet.otočVýplňX, Svet.otočVýplňY));
					else a = oblasť;

					grafikaAktívnehoPlátna.fill(a);
					aktualizujPôsobisko(oblasť.getBounds2D());
				}

				if (0 != Svet.otočVýplňΑ)
				{
					grafikaAktívnehoPlátna.rotate(β,
						Svet.otočVýplňX, Svet.otočVýplňY);
				}

				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňOblasť(Area, String) vyplňOblasť}.</p> */
			public void vyplnOblast(Area oblasť, String súbor)
			{ vyplňOblasť(oblasť, súbor); }

			/**
			 * <p>Vyplní plochu zadanej oblasti zadanou textúrou, pričom oblasť
			 * rotuje podľa smeru<sup>[1]</sup> robota a posúva ju
			 * o súradnice<sup>[2]</sup> robota na plátne. Rotácia a poloha
			 * textúry nie sú nijako ovplyvňované polohou a smerom robota.
			 * Textúra bude použitá na dlaždicové vyplnenie plochy oblasti. Je
			 * zadaná ako objekt typu {@link Image Image}, za ktorý môže byť
			 * dosadený aj objekt typu {@link Obrázok Obrázok}.</p>
			 * 
			 * <p><small>[1] – za východisko je považovaných 90°; odchýlka
			 * v kladom alebo zápornom smere náležite rotuje
			 * oblasť.</small><br />
			 * <small>[2] – stred sa nachádza v bode [0, 0] – v strede
			 * plátna; ak je robot v strede plátna, poloha oblasti sa
			 * nezmení.</small></p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Parametre textúry sa dajú
			 * ovplyvňovať špeciálnymi príkazmi. Súvisí s nimi i predvolené
			 * správanie príkazov vypĺňania. Predvolený bod začiatku vypĺňania
			 * dlaždicami sa nachádza v strede plátna alebo vypĺňaného
			 * obrázka. Pozrite si aj opis metódy
			 * {@link Svet#posunutieVýplne(double, double) posunutieVýplne},
			 * kde nájdete príklad použitia a odkazy na metódy
			 * upravujúce ďalšie parametre obrázkových výplní.</p>
			 * 
			 * @param oblasť objekt typu {@link Area} (resp. {@link Oblasť})
			 * @param výplň obrázok textúry
			 * 
			 * @see Oblasť#vyplň(Image)
			 * @see Oblasť#vyplň(GRobot, Image)
			 */
			public void vyplňOblasť(Area oblasť, Image výplň)
			{
				BufferedImage obrázok =
					Obrázok.preveďNaBufferedImage(výplň);
				BufferedImage relevantný =
					Obrázok.dajRelevantnýRaster(obrázok);

				float priehľadnosť = (obrázok instanceof Obrázok) ?
					((Obrázok)obrázok).priehľadnosť : 1.0f;

				if (priehľadnosť > 0)
				{
					grafikaAktívnehoPlátna.setPaint(
						new TexturePaint(relevantný, new Rectangle2D.Double(
							Svet.posuňVýplňX, Svet.posuňVýplňY,
							relevantný.getWidth(null)  * Svet.mierkaVýplneX,
							relevantný.getHeight(null) * Svet.mierkaVýplneY)));

					Area a = oblasť; double β = 0.0;

					if (0 != Svet.otočVýplňΑ)
					{
						β = toRadians(Svet.otočVýplňΑ);
						grafikaAktívnehoPlátna.rotate(-β,
							Svet.otočVýplňX, Svet.otočVýplňY);
						a = oblasť.createTransformedArea(
							AffineTransform.getRotateInstance(β,
							Svet.otočVýplňX, Svet.otočVýplňY));
					}

					if (priehľadnosť < 1)
					{
						Composite záloha =
							grafikaAktívnehoPlátna.getComposite();
						grafikaAktívnehoPlátna.setComposite(
							AlphaComposite.getInstance(
								AlphaComposite.SRC_OVER,
								priehľadnosť));

						if (aktuálnyUhol == 90 && aktuálneX == 0 &&
							aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
							pôvodnýPomer == pomerVeľkosti)
						{
							grafikaAktívnehoPlátna.fill(a);
							aktualizujPôsobisko(oblasť.getBounds2D());
						}
						else
						{
							AffineTransform at = new AffineTransform();

							double prepočítanéX = Svet.prepočítajX(aktuálneX);
							double prepočítanéY = Svet.prepočítajY(aktuálneY);

							at.rotate(toRadians(90 - aktuálnyUhol),
								prepočítanéX, prepočítanéY);

							if (pôvodnáVeľkosť != veľkosť ||
								pôvodnýPomer != pomerVeľkosti)
							{
								double mierka = veľkosť / pôvodnáVeľkosť;
								double mierkaX = mierka * (pomerVeľkosti /
									pôvodnýPomer);
								at.translate(prepočítanéX, prepočítanéY);
								at.scale(mierkaX, mierka);
								at.translate(-prepočítanéX, -prepočítanéY);
							}

							at.translate(aktuálneX, -aktuálneY);
							oblasť = oblasť.createTransformedArea(at);

							if (0 != Svet.otočVýplňΑ)
								a = oblasť.createTransformedArea(
									AffineTransform.getRotateInstance(β,
									Svet.otočVýplňX, Svet.otočVýplňY));
							else a = oblasť;

							grafikaAktívnehoPlátna.fill(a);
							aktualizujPôsobisko(oblasť.getBounds2D());
						}

						grafikaAktívnehoPlátna.setComposite(záloha);
					}
					else
					{
						if (aktuálnyUhol == 90 && aktuálneX == 0 &&
							aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
							pôvodnýPomer == pomerVeľkosti)
						{
							grafikaAktívnehoPlátna.fill(a);
							aktualizujPôsobisko(oblasť.getBounds2D());
						}
						else
						{
							AffineTransform at = new AffineTransform();

							double prepočítanéX = Svet.prepočítajX(aktuálneX);
							double prepočítanéY = Svet.prepočítajY(aktuálneY);

							at.rotate(toRadians(90 - aktuálnyUhol),
								prepočítanéX, prepočítanéY);

							if (pôvodnáVeľkosť != veľkosť ||
								pôvodnýPomer != pomerVeľkosti)
							{
								double mierka = veľkosť / pôvodnáVeľkosť;
								double mierkaX = mierka * (pomerVeľkosti /
									pôvodnýPomer);
								at.translate(prepočítanéX, prepočítanéY);
								at.scale(mierkaX, mierka);
								at.translate(-prepočítanéX, -prepočítanéY);
							}

							at.translate(aktuálneX, -aktuálneY);
							oblasť = oblasť.createTransformedArea(at);

							if (0 != Svet.otočVýplňΑ)
								a = oblasť.createTransformedArea(
									AffineTransform.getRotateInstance(β,
									Svet.otočVýplňX, Svet.otočVýplňY));
							else a = oblasť;

							grafikaAktívnehoPlátna.fill(a);
							aktualizujPôsobisko(oblasť.getBounds2D());
						}
					}

					if (0 != Svet.otočVýplňΑ)
					{
						grafikaAktívnehoPlátna.rotate(β,
							Svet.otočVýplňX, Svet.otočVýplňY);
					}

					Svet.automatickéPrekreslenie();
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyplňOblasť(Area, Image) vyplňOblasť}.</p> */
			public void vyplnOblast(Area oblasť, Image výplň)
			{ vyplňOblasť(oblasť, výplň); }


			/**
			 * <p>Zistí, či sa súradnice zadaného bodu nachádzajú v zadanej
			 * oblasti, ktorá je na účely porovnania rotovaná podľa smeru
			 * robota (za východisko je považovaných 90°; odchýlka v kladom
			 * alebo zápornom smere náležite rotuje oblasť) a posunutá
			 * o súradnice robota na plátne (stred sa nachádza v bode [0, 0] –
			 * v strede plátna; ak je robot v strede plátna, poloha oblasti
			 * sa nezmení). Nasledujúca metóda dovoľuje namiesto súradníc
			 * bodu použiť objekt: {@link #bodVOblasti(Poloha, Area)
			 * bodVOblasti(Poloha objekt, Area oblasť)}.</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @param oblasť oblasť, ktorá má byť použitá na overenie
			 * @return {@code valtrue} – áno; {@code valfalse} – nie
			 * 
			 * @see Oblasť#bodV(double, double)
			 * @see #bodVPôsobisku(double, double)
			 * @see #bodVKruhu(double, double, double)
			 * @see #bodVElipse(double, double, double, double)
			 * @see #bodVoŠtvorci(double, double, double)
			 * @see #bodVObdĺžniku(double, double, double, double)
			 * @see #bodVHviezde(double, double, double)
			 * @see #bodVCeste(double, double)
			 * @see #bodVTvare(double, double, Shape)
			 */
			public boolean bodVOblasti(double súradnicaBoduX,
				double súradnicaBoduY, Area oblasť)
			{
				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
					return oblasť.contains(Svet.prepočítajX(súradnicaBoduX),
						Svet.prepočítajY(súradnicaBoduY));

				AffineTransform at = new AffineTransform();

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				at.rotate(toRadians(90 - aktuálnyUhol),
					prepočítanéX, prepočítanéY);

				if (pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti)
				{
					double mierka = veľkosť / pôvodnáVeľkosť;
					double mierkaX = mierka * (pomerVeľkosti /
						pôvodnýPomer);
					at.translate(prepočítanéX, prepočítanéY);
					at.scale(mierkaX, mierka);
					at.translate(-prepočítanéX, -prepočítanéY);
				}

				at.translate(aktuálneX, -aktuálneY);
				Area a = oblasť.createTransformedArea(at);

				return a.contains(Svet.prepočítajX(súradnicaBoduX),
					Svet.prepočítajY(súradnicaBoduY));
			}

			/**
			 * <p>Funguje rovnako ako metóda {@link #bodVOblasti(double, double,
			 * Area) bodVOblasti(x, y, oblasť)}, len namiesto súradníc bodu
			 * je použitá poloha zadaného objektu…</p>
			 * 
			 * <p>Metóda berie do úvahy aj aktuálnu
			 * {@linkplain GRobot#mierka() mierku} robota.</p>
			 * 
			 * @param objekt objekt, ktorého poloha je použitá namiesto
			 *     súradníc bodu
			 * @param oblasť oblasť, ktorá má byť použitá na overenie
			 * @return {@code valtrue}/&#8203;{@code valfalse}
			 * 
			 * @see Oblasť#bodV(Poloha)
			 * @see #bodVPôsobisku(Poloha)
			 * @see #bodVKruhu(Poloha, double)
			 * @see #bodVElipse(Poloha, double, double)
			 * @see #bodVoŠtvorci(Poloha, double)
			 * @see #bodVObdĺžniku(Poloha, double, double)
			 * @see #bodVHviezde(Poloha, double)
			 * @see #bodVCeste(Poloha)
			 * @see #bodVTvare(Poloha, Shape)
			 */
			public boolean bodVOblasti(Poloha objekt, Area oblasť)
			{
				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
					return oblasť.contains(Svet.prepočítajX(objekt.polohaX()),
						Svet.prepočítajY(objekt.polohaY()));

				AffineTransform at = new AffineTransform();

				double prepočítanéX = Svet.prepočítajX(aktuálneX);
				double prepočítanéY = Svet.prepočítajY(aktuálneY);

				at.rotate(toRadians(90 - aktuálnyUhol),
					prepočítanéX, prepočítanéY);

				if (pôvodnáVeľkosť != veľkosť ||
					pôvodnýPomer != pomerVeľkosti)
				{
					double mierka = veľkosť / pôvodnáVeľkosť;
					double mierkaX = mierka * (pomerVeľkosti /
						pôvodnýPomer);
					at.translate(prepočítanéX, prepočítanéY);
					at.scale(mierkaX, mierka);
					at.translate(-prepočítanéX, -prepočítanéY);
				}

				at.translate(aktuálneX, -aktuálneY);
				Area a = oblasť.createTransformedArea(at);

				return a.contains(Svet.prepočítajX(objekt.polohaX()),
					Svet.prepočítajY(objekt.polohaY()));
			}


		// Poradie

			/**
			 * <p><a class="setter"></a> Preradí tento robot do vrstvy
			 * s určeným poradovým číslom. Vrstva môže byť chápaná ako
			 * symbolická hodnota, ktorá ovplyvňuje poradie kreslenia
			 * robotov (podrobnosti sú v opise metódy {@link #vrstva()
			 * vrstva()}). Zmenou hodnoty vrstvy sa nezmení umiestnenie
			 * robota v rámci vnútorného zoznamu robotov. Vrstva ovplyvňuje
			 * poradie kreslenia v rámci všetkých robotov, pričom poradie
			 * kreslenia robotov umiestnených v rovnakej vrstve je určené
			 * poradím vo vnútornom zozname robotov.</p>
			 * 
			 * @param vrstva poradové číslo vrstvy kreslenia, do ktorej má
			 *     byť tento robot premiestnený
			 */
			public void vrstva(int vrstva)
			{
				Vrstva.preraď(this, vrstva);
				Svet.automatickéPrekreslenie();
			}

			/**
			 * <p><a class="getter"></a> Vráti poradové číslo vrstvy kreslenia,
			 * v ktorej je umiestnený tento robot.
			 * 
			 * Predvolené číslo vrstvy je {@code num0}. Stúpajúca hodnota
			 * čísla vrstvy znamená neskoršie kreslenie, čiže „zobrazenie
			 * (robota, resp. ním reprezentovaného objektu) viac v popredí.“
			 * Ešte raz v skratke: Robot s vyšším číslom vrstvy bude nakreslený
			 * neskôr, čo znamená, že bude vizuálne prekrývať roboty s nižšími
			 * číslami vrstiev. (Čísla vrstiev môžu byť aj záporné.)</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>Desať robotov v kruhu je po spustení kreslených v tom poradí,
			 * ako boli vytvorené. Kliknutie ľavým tlačidlom myši „priblíži“
			 * robot (presunie ho do vyššej vrstvy) a kliknutie iným
			 * (predpokladajme, že pravým, ale môže to byť aj stredné)
			 * tlačidlom vykoná opak.</p>
			 * 
			 * <pre CLASS="example">
				{@code kwdimport} knižnica.*;

				{@code kwdpublic} {@code typeclass} Vrstvy {@code kwdextends} {@link GRobot GRobot}
				{
					{@code kwdpublic} {@code typeclass} Trojzubec {@code kwdextends} {@link GRobot GRobot}
					{
						{@code kwdpublic} Trojzubec({@code typedouble} uhol)
						{
							{@code comm// Nastavenie vlastností (odvodeného) robota.}
							{@link GRobot#uhol(double) uhol}(uhol);
							{@link GRobot#veľkosť(double) veľkosť}({@code num60});
							{@link GRobot#preskočVpravo(double) preskočVpravo}({@code num120});
							{@link GRobot#hrúbkaČiary(double) hrúbkaČiary}({@code num2});
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#kresliTvar() kresliTvar}()
						{
							{@code comm// Kreslenie tvaru:}

							{@link GRobot#farba(Color) farba}({@link Farebnosť#svetlošedá svetlošedá});
							{@link GRobot#kružnica() kružnica}();

							{@link GRobot#farba(Color) farba}({@link Farebnosť#modrá modrá});
							{@link GRobot#vypĺňajTvary() vypĺňajTvary}();
							{@link GRobot#trojzubec() trojzubec}();

							{@link GRobot#farba(Color) farba}({@link Farebnosť#žltá žltá});
							{@link GRobot#nevypĺňajTvary() nevypĺňajTvary}();
							{@link GRobot#trojzubec() trojzubec}();

							{@link GRobot#farba(Color) farba}({@link Farebnosť#svetlozelená svetlozelená});
							{@link GRobot#text(String) text}({@code srg""} + {@link GRobot#vrstva() vrstva}());
						}

						{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link GRobot#klik() klik}()
						{
							{@code comm// Klik ľavým tlačidlom posunie robota do vyššej vrstvy (do}
							{@code comm// popredia) a klik ľavým naopak. Roboty v rovnakých vrstvách}
							{@code comm// sú kreslení buď podľa poradia, v ktorom boli vytvorení, alebo}
							{@code comm// podľa upraveného poradia (pozri napríklad medódy: naVrch,}
							{@code comm// naSpodok, vyššie, nižšie…).}
							{@code kwdif} ({@link GRobot#myšV() myšV}())
							{
								{@code kwdif} ({@link ÚdajeUdalostí ÚdajeUdalostí}.{@link ÚdajeUdalostí#tlačidloMyši(int) tlačidloMyši}({@link Konštanty#ĽAVÉ ĽAVÉ}))
									{@link GRobot#vrstva(int) vrstva}({@link GRobot#vrstva() vrstva}() + {@code num1});
								{@code kwdelse}
									{@link GRobot#vrstva(int) vrstva}({@link GRobot#vrstva() vrstva}() - {@code num1});
							}
						}
					}

					{@code kwdprivate} Vrstvy()
					{
						{@code comm// Konštruktor nadradenej triedy (GRobot) upraví veľkosť plátna.}
						{@code comm// (Toto je použiteľné len pri hlavnom robote.)}
						{@code valsuper}({@code num400}, {@code num400});
						{@link GRobot#skry() skry}();

						{@code comm// Vytvorenie desiatich robotov (zoradených za sebou na kružnici).}
						{@code kwdfor} ({@code typeint} i = {@code num0}; i < {@code num360}; i += {@code num36}) {@code kwdnew} Trojzubec(i);
					}

					{@code comm// Hlavná metóda. (Vstupný bod programu.)}
					{@code kwdpublic} {@code kwdstatic} {@code typevoid} main({@link String String}... args) { {@code kwdnew} Vrstvy(); }
				}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <p><image>vrstvy.png<alt/>Vzhľad príkladu
			 * s vrstvami.</image>Vzhľad príkladu s vrstvami.</p>
			 * 
			 * @return celé číslo určujúce poradové číslo vrstvy kreslenia
			 *     pre tento robot
			 */
			public int vrstva()
			{
				return vrstva;
			}

			/**
			 * <p>Presunie tento robot do popredia s ohľadom na umiestnenie
			 * robotov do vrstiev. Technicky to znamená, že robot bude
			 * umiestnený na koniec vnútorného zoznamu robotov. Poradie
			 * umiestnenia robotov v tomto zozname ovplyvňuje poradie kreslenia
			 * robotov nachádzajúcich sa v spoločnej vrstve. Pri štandardnom
			 * spracovaní s pomocou {@linkplain #vyzviRoboty(int) výzvy} treba
			 * počítať s tým, že tento robot bude odteraz vyzývaný ako posledný
			 * (bez ohľadu na umiestnenie do vrstiev).</p>
			 * 
			 * @see #naSpodok()
			 * @see #vyššie()
			 * @see #nižšie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #jePred(GRobot)
			 * @see #jeZa(GRobot)
			 */
			public void naVrch()
			{
				if (zoznamRobotov.size() <= 1) return;
				synchronized (ÚdajeUdalostí.zámokUdalostí)
				{
					int index = zoznamRobotov.indexOf(this);
					Vrstva.vymaž(index, zoznamRobotov.size() - 1);
					zoznamRobotov.remove(this);
					zoznamRobotov.add(this);
					Vrstva.vlož(index, zoznamRobotov.size() - 1);
				}
				zoznamZmenený2 = zoznamZmenený1 = true;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/**
			 * <p>Presunie tento robot do pozadia s ohľadom na umiestnenie
			 * robotov do vrstiev. Technicky to znamená, že robot bude
			 * umiestnený na začiatok vnútorného zoznamu robotov. Poradie
			 * umiestnenia robotov v tomto zozname ovplyvňuje poradie kreslenia
			 * robotov nachádzajúcich sa v spoločnej vrstve. Pri štandardnom
			 * spracovaní s pomocou {@linkplain #vyzviRoboty(int) výzvy} treba
			 * počítať s tým, že tento robot bude odteraz vyzývaný ako prvý
			 * (bez ohľadu na umiestnenie do vrstiev).</p>
			 * 
			 * @see #naVrch()
			 * @see #vyššie()
			 * @see #nižšie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #jePred(GRobot)
			 * @see #jeZa(GRobot)
			 */
			public void naSpodok()
			{
				if (zoznamRobotov.size() <= 1) return;
				synchronized (ÚdajeUdalostí.zámokUdalostí)
				{
					int index = zoznamRobotov.indexOf(this);
					Vrstva.vymaž(0, index);
					zoznamRobotov.remove(this);
					zoznamRobotov.add(0, this);
					Vrstva.vlož(0, index);
				}
				zoznamZmenený2 = zoznamZmenený1 = true;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/**
			 * <p>Presunie tento robot o úroveň vyššie v rámci poradia
			 * kreslenia robotov s ohľadom na umiestnenie robotov do vrstiev.
			 * Technicky to znamená to, že robot bude umiestnený o jeden
			 * prvok ďalej v rámci vnútorného zoznamu robotov. Poradie
			 * umiestnenia robotov v tomto zozname ovplyvňuje poradie
			 * kreslenia robotov nachádzajúcich sa v spoločnej vrstve. Pri
			 * štandardnom spracovaní s pomocou {@linkplain #vyzviRoboty(int)
			 * výzvy} to bude znamenať, že tento robot bude odteraz vyzývaný
			 * o niečo neskôr (poradie vyzývania nesúvisí s umiestnením
			 * robotov do vrstiev).</p>
			 * 
			 * @see #naVrch()
			 * @see #naSpodok()
			 * @see #nižšie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #jePred(GRobot)
			 * @see #jeZa(GRobot)
			 */
			public void vyššie()
			{
				if (zoznamRobotov.size() <= 1) return;
				int indexOf = zoznamRobotov.indexOf(this);
				if (-1 == indexOf || indexOf + 1 >=
					zoznamRobotov.size()) return;
				synchronized (ÚdajeUdalostí.zámokUdalostí)
				{
					GRobot r = zoznamRobotov.get(indexOf + 1);
					Vrstva.vymaž(r); Vrstva.vymaž(this);
					zoznamRobotov.set(indexOf + 1,
						zoznamRobotov.get(indexOf));
					zoznamRobotov.set(indexOf, r);
					Vrstva.vlož(r); Vrstva.vlož(this);
				}
				zoznamZmenený2 = zoznamZmenený1 = true;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vyššie() vyššie}.</p> */
			public void vyssie() { vyššie(); }

			/**
			 * <p>Presunie tento robot o úroveň nižšie v rámci poradia
			 * kreslenia robotov s ohľadom na umiestnenie robotov do vrstiev.
			 * Technicky to znamená to, že robot bude umiestnený o jeden prvok
			 * skôr v rámci vnútorného zoznamu robotov. Poradie umiestnenia
			 * robotov v tomto zozname ovplyvňuje poradie kreslenia robotov
			 * nachádzajúcich sa v spoločnej vrstve. Pri štandardnom spracovaní
			 * s pomocou {@linkplain #vyzviRoboty(int) výzvy} to bude znamenať,
			 * že tento robot bude odteraz vyzývaný o niečo skôr
			 * (poradie vyzývania nesúvisí s umiestnením robotov do vrstiev).</p>
			 * 
			 * @see #naVrch()
			 * @see #naSpodok()
			 * @see #vyššie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #somPred(GRobot)
			 * @see #somZa(GRobot)
			 */
			public void nižšie()
			{
				if (zoznamRobotov.size() <= 1) return;
				int indexOf = zoznamRobotov.indexOf(this);
				if (indexOf - 1 <= 0) return;
				synchronized (ÚdajeUdalostí.zámokUdalostí)
				{
					GRobot r = zoznamRobotov.get(indexOf - 1);
					Vrstva.vymaž(r); Vrstva.vymaž(this);
					zoznamRobotov.set(indexOf - 1,
						zoznamRobotov.get(indexOf));
					zoznamRobotov.set(indexOf, r);
					Vrstva.vlož(r); Vrstva.vlož(this);
				}
				zoznamZmenený2 = zoznamZmenený1 = true;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #nižšie() nižšie}.</p> */
			public void nizsie() { nižšie(); }

			/**
			 * <p>Presunie tento robot pred zadaný robot (z pohľadu
			 * zoradenia robotov vo vnútornom zozname, pričom umiestnenie
			 * robotov do vrstiev zostane neovplyvnené). Technicky to znamená,
			 * že tento robot bude vo vnútornom zozname robotov umiestnený
			 * „za“ zadaný robot, to jest – jeho poradové číslo v zozname
			 * robotov bude vyššie.
			 * Poradie umiestnenia robotov v tomto zozname ovplyvňuje
			 * poradie kreslenia robotov nachádzajúcich sa v spoločnej vrstve,
			 * pričom roboty s nižším poradovým číslom sú kreslené skôr, preto
			 * sú v rámci jednej vrstvy zobrazené pod svojími rovesníkmi.
			 * Pri štandardnom spracovaní s pomocou {@linkplain 
			 * #vyzviRoboty(int) výzvy} bude tento robot odteraz vyzývaný
			 * tesne po zadanom robote
			 * (poradie vyzývania nesúvisí s umiestnením robotov do vrstiev).</p>
			 * 
			 * @param ktorého robot, pred ktorého má byť tento robot
			 *     posunutý
			 * 
			 * @see #naVrch()
			 * @see #naSpodok()
			 * @see #vyššie()
			 * @see #nižšie()
			 * @see #za(GRobot)
			 * @see #somPred(GRobot)
			 * @see #somZa(GRobot)
			 */
			public void pred(GRobot ktorého)
			{
				if (zoznamRobotov.size() <= 1 || ktorého == this) return;
				synchronized (ÚdajeUdalostí.zámokUdalostí)
				{
					int index1 = zoznamRobotov.indexOf(this),
						index2 = zoznamRobotov.indexOf(ktorého);
					if (-1 == index2) index2 = zoznamRobotov.size() - 1;
					Vrstva.vymaž(index1, index2);

					zoznamRobotov.remove(this);
					int indexOf = zoznamRobotov.indexOf(ktorého);
					if (-1 == indexOf) indexOf = zoznamRobotov.size();
					zoznamRobotov.add(indexOf + 1, this);

					Vrstva.vlož(index1, index2);
				}
				zoznamZmenený2 = zoznamZmenený1 = true;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #pred(GRobot) pred}.</p> */
			public void nad(GRobot ktorého) { pred(ktorého); }

			/**
			 * <p>Presunie tento robot za zadaný robot (z pohľadu zoradenia
			 * robotov vo vnútornom zozname robotov, pričom umiestnenie
			 * robotov do vrstiev zostane neovplyvnené). Technicky to znamená,
			 * že tento robot bude vo vnútornom zozname robotov umiestnený
			 * „pred“ zadaný robot, to jest – jeho poradové číslo v zozname
			 * robotov bude nižšie.
			 * Poradie umiestnenia robotov v tomto zozname ovplyvňuje poradie
			 * kreslenia robotov nachádzajúcich sa v spoločnej vrstve, pričom
			 * roboty s nižším poradovým číslom sú kreslené skôr, preto sú
			 * v rámci jednej vrstvy zobrazené pod svojími rovesníkmi. Pri
			 * štandardnom spracovaní s pomocou {@linkplain #vyzviRoboty(int)
			 * výzvy} bude tento robot odteraz vyzývaný skôr, než zadaný robot
			 * (poradie vyzývania nesúvisí s umiestnením robotov do vrstiev).</p>
			 * 
			 * @param ktorého robot, za ktorého má byť tento robot
			 *     umiestnený
			 * 
			 * @see #naVrch()
			 * @see #naSpodok()
			 * @see #vyššie()
			 * @see #nižšie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #somPred(GRobot)
			 * @see #somZa(GRobot)
			 */
			public void za(GRobot ktorého)
			{
				if (zoznamRobotov.size() <= 1 || ktorého == this) return;
				synchronized (ÚdajeUdalostí.zámokUdalostí)
				{
					int index1 = zoznamRobotov.indexOf(this),
						index2 = zoznamRobotov.indexOf(ktorého);
					if (-1 == index2) index2 = 0;
					Vrstva.vymaž(index1, index2);

					zoznamRobotov.remove(this);
					int indexOf = zoznamRobotov.indexOf(ktorého);
					if (-1 == indexOf) indexOf = 0;
					zoznamRobotov.add(indexOf, this);

					Vrstva.vlož(index1, index2);
				}
				zoznamZmenený2 = zoznamZmenený1 = true;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #za(GRobot) za}.</p> */
			public void pod(GRobot ktorého) { za(ktorého); }

			/**
			 * <p>Overí, či je tento robot pred zadaným robotom. S ohľadom na
			 * umiestnenie robotov do vrstiev to nemusí nevyhnutne znamenať,
			 * že tento robot bude skutočne nakreslený pred zadaným robotom.
			 * Ak chcete overiť skutočné poradie zobrazovania, porovnajte
			 * najskôr hodnoty umiestnenia robotov vo {@linkplain 
			 * GRobot#vrstva() vrstvách}.
			 * Metóda vráti {@code valtrue} pre všetkých robotov, ktorí sú
			 * technicky umiestnení za týmto robotom (to znamená, že sú vo
			 * vnútornom zozname robotov na pozícii s nižším poradovým číslom).
			 * Metóda berie do úvahy aj skrytých robotov.</p>
			 * 
			 * @param ktorým robot, voči ktorému má byť overená poloha tohto
			 *     robota
			 * @return {@code valtrue} ak je tento robot umiestnený nad
			 *     určeným robotom, inak {@code valfalse}
			 * 
			 * @see #naVrch()
			 * @see #naSpodok()
			 * @see #vyššie()
			 * @see #nižšie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #somZa(GRobot)
			 */
			public boolean somPred(GRobot ktorým)
			{
				if (this == ktorým) return false;
				for (GRobot r : zoznamRobotov)
				{
					if (r == this) return false;
					if (r == ktorým) return true;
				}
				return false;
			}

			/** <p><a class="alias"></a> Alias pre {@link #somPred(GRobot) somPred}.</p> */
			public boolean somNad(GRobot ktorým) { return somPred(ktorým); }

			/** <p><a class="alias"></a> Alias pre {@link #somPred(GRobot) somPred}.</p> */
			public boolean jeZa(GRobot ktorý) { return somPred(ktorý); }

			/** <p><a class="alias"></a> Alias pre {@link #somPred(GRobot) somPred}.</p> */
			public boolean jePod(GRobot ktorý) { return somPred(ktorý); }

			/**
			 * <p>Overí, či je tento robot za zadaným robotom. S ohľadom na
			 * umiestnenie robotov do vrstiev to nemusí nevyhnutne znamenať,
			 * že tento robot bude skutočne nakreslený za zadaným robotom.
			 * Ak chcete overiť skutočné poradie zobrazovania, porovnajte
			 * najskôr hodnoty umiestnenia robotov vo {@linkplain 
			 * GRobot#vrstva() vrstvách}.
			 * Metóda vráti {@code valtrue} pre všetky roboty, ktoré sú
			 * technicky umiestnené pred týmto robotom (to znamená, že sú vo
			 * vnútornom zozname robotov na pozícii s vyšším poradovým číslom).
			 * Metóda berie do úvahy aj skryté roboty.</p>
			 * 
			 * @param ktorým robot, voči ktorému má byť overená poloha tohto
			 *     robota
			 * @return {@code valtrue} ak je tento robot umiestnený pod
			 *     určeným robotom, inak {@code valfalse}
			 * 
			 * @see #naVrch()
			 * @see #naSpodok()
			 * @see #vyššie()
			 * @see #nižšie()
			 * @see #pred(GRobot)
			 * @see #za(GRobot)
			 * @see #somPred(GRobot)
			 */
			public boolean somZa(GRobot ktorým)
			{
				if (this == ktorým) return false;
				for (GRobot r : zoznamRobotov)
				{
					if (r == this) return true;
					if (r == ktorým) return false;
				}
				return false;
			}

			/** <p><a class="alias"></a> Alias pre {@link #somZa(GRobot) somZa}.</p> */
			public boolean somPod(GRobot ktorým) { return somZa(ktorým); }

			/** <p><a class="alias"></a> Alias pre {@link #somZa(GRobot) somZa}.</p> */
			public boolean jePred(GRobot ktorý) { return somZa(ktorý); }

			/** <p><a class="alias"></a> Alias pre {@link #somZa(GRobot) somZa}.</p> */
			public boolean jeNad(GRobot ktorý) { return somZa(ktorý); }


		// Spojnice

			/**
			 * <p>Vráti inštanciu jestvujúcej spojnice medzi týmto a zadaným
			 * robotom alebo vráti hodnotu {@code valnull}, ak spojnica
			 * nejestvuje.</p>
			 * 
			 * @param cieľ partnerský (cieľový) robot medzi ktorým má byť
			 *     hľadaná jestvujúca spojnica
			 * @return jestvujúca {@linkplain Spojnica inštancia spojnice}
			 *     alebo {@code valnull}
			 * 
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 * @see #spojniceZ()
			 * @see #spojniceDo()
			 * @see #súSpojniceZ()
			 * @see #súSpojniceDo()
			 */
			public Spojnica dajSpojnicu(GRobot cieľ)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
					if (s.cieľ == cieľ) return s;

				return null;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať
			 * aktuálnu farbu a hrúbku (aj typ) čiary tohto robota, ak
			 * spojnica medzi týmto a zadaným robotom jestvuje, jej farba
			 * a hrúbka (aj typ) čiary sa aktualizujú podľa zdrojového robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						s.farba = farbaRobota;
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farbaRobota, cieľ.farba(),
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * hrúbku čiary a aktuálnu farbu tohto robota (typ čiary bude
			 * predvolený – súvislá čiara). Ak spojnica jestvuje, hrúbka čiary
			 * sa aktualizuje zadanou hodnotou (typ bude opäť predvolený –
			 * súvislá čiara) a farba sa aktualizuje podľa aktuálnej farby
			 * tohto robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> V tomto prípade je povolené
			 * zadávať zápornú hodnotu hrúbky čiary, ktorá značí automatický
			 * štýl čiary spojnice určený podľa aktuálneho štýlu čiary
			 * zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param hrúbka hrúbka čiary spojnice
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @throws GRobotException ak je hrúbka čiary záporná
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, double hrúbka)
			{
				if (null == cieľ || this == cieľ) return null;

				if (hrúbka < 0) throw new GRobotException(
					"Hrúbka čiary nesmie byť záporná!", "negativeLineWidth",
					new IllegalArgumentException());

				Stroke čiara = (hrúbka < 0) ? null : new BasicStroke(
					(float)hrúbka, BasicStroke.CAP_ROUND,
					BasicStroke.JOIN_ROUND);

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						s.farba = farbaRobota;
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farbaRobota, cieľ.farba(),
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * farbu čiary a hrúbku (aj typ) čiary podľa aktuálneho
			 * nastavenia tohto robota. Ak spojnica jestvuje, jej farba sa
			 * aktualizuje zadanou hodnotou a hrúbka čiary sa aktualizuje
			 * podľa aktuálnej hrúbky (a typu) čiary tohto robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétnej farby
			 * je povolené zadať aj hodnotu {@code valnull}, ktorá signalizuje
			 * automatickú farbu podľa aktuálnej hodnoty zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param farba farba čiary spojnice (argument musí byť objekt
			 *     typu {@link Color Color} alebo potomok)
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Color farba)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farba,
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * hrúbku a farbu čiary (typ čiary bude predvolený – súvislá
			 * čiara). Ak spojnica jestvuje, hrúbka a farba čiary sa
			 * aktualizujú zadanými hodnotami (typ bude opäť predvolený –
			 * súvislá čiara).
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> V tomto prípade je povolené
			 * zadávať zápornú hodnotu hrúbky čiary a hodnotu
			 * {@code valnull} namiesto konkrétnej farby, čo značí
			 * automatické hodnoty podľa aktuálnych vlastností zdrojového
			 * robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param hrúbka hrúbka čiary spojnice
			 * @param farba farba čiary spojnice (argument musí byť objekt
			 *     typu {@link Color Color} alebo potomok)
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @throws GRobotException ak je hrúbka čiary záporná
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, double hrúbka, Color farba)
			{
				if (null == cieľ || this == cieľ) return null;

				if (hrúbka < 0) throw new GRobotException(
					"Hrúbka čiary nesmie byť záporná!", "negativeLineWidth",
					new IllegalArgumentException());

				Stroke čiara = (hrúbka < 0) ? null : new BasicStroke(
					(float)hrúbka, BasicStroke.CAP_ROUND,
					BasicStroke.JOIN_ROUND);

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farba,
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať farbu
			 * čiary určenú zadaným objektom a hrúbku (aj typ) čiary podľa
			 * aktuálneho nastavenia tohto robota. Ak spojnica jestvuje, jej
			 * farba sa aktualizuje podľa farby zadaného objektu a hrúbka (aj
			 * typ) čiary sa aktualizuje podľa aktuálnej hrúbky čiary tohto
			 * robota. (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétnej farby
			 * je povolené zadať aj hodnotu {@code valnull}, ktorá signalizuje
			 * automatickú farbu podľa aktuálnej hodnoty zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param objekt objekt, podľa ktorého bude určená farba čiary
			 *     spojnice
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Farebnosť objekt)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == objekt)
							s.farba = null;
						else
							s.farba = objekt.farba();
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(objekt.farba(), objekt.farba(),
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * hrúbku a farbu čiary podľa zadaného objektu (typ čiary bude
			 * predvolený – súvislá čiara). Ak spojnica jestvuje, hrúbka čiary
			 * sa aktualizuje zadanou hodnotou a farba sa aktualizuje podľa
			 * farby zadaného objektu (typ čiary bude opäť predvolený – súvislá
			 * čiara).
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> V tomto prípade je povolené
			 * zadávať zápornú hodnotu hrúbky čiary a hodnotu
			 * {@code valnull} namiesto konkrétnej inštancie farebnosti, čo
			 * značí automatické hodnoty podľa aktuálnych vlastností
			 * zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param hrúbka hrúbka čiary spojnice
			 * @param objekt objekt, podľa ktorého sa určí farba čiary
			 *     spojnice
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @throws GRobotException ak je hrúbka čiary záporná
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ,
				double hrúbka, Farebnosť objekt)
			{
				if (null == cieľ || this == cieľ) return null;

				if (hrúbka < 0) throw new GRobotException(
					"Hrúbka čiary nesmie byť záporná!", "negativeLineWidth",
					new IllegalArgumentException());

				Stroke čiara = (hrúbka < 0) ? null : new BasicStroke(
					(float)hrúbka, BasicStroke.CAP_ROUND,
					BasicStroke.JOIN_ROUND);

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == objekt)
							s.farba = null;
						else
							s.farba = objekt.farba();
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(objekt.farba(), objekt.farba(),
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadaný
			 * typ čiary a aktuálnu farbu tohto robota. Ak spojnica jestvuje,
			 * typ čiary sa aktualizuje podľa zadaného objektu a farba sa
			 * aktualizuje podľa aktuálnej farby tohto robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho štýlu
			 * čiary je povolené zadať aj hodnotu {@code valnull}, čo značí
			 * automatický štýl čiary spojnice určený podľa aktuálneho štýlu
			 * čiary zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param čiara objekt určujúci typ čiary spojnice
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Stroke čiara)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						s.farba = farbaRobota;
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farbaRobota, cieľ.farba(),
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadaný
			 * typ a farbu čiary. Ak spojnica jestvuje, typ a farba čiary sa
			 * aktualizujú zadanými hodnotami.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho štýlu
			 * čiary alebo farby je povolené zadať aj hodnotu {@code valnull},
			 * čo značí automatické hodnoty podľa aktuálnych vlastností
			 * zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param čiara objekt určujúci typ čiary spojnice
			 * @param farba farba čiary spojnice (argument musí byť objekt
			 *     typu {@link Color Color} alebo potomok)
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Stroke čiara, Color farba)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farba,
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať typ
			 * a farbu čiary podľa zadaných objektov. Ak spojnica jestvuje,
			 * typ a farba čiary sa aktualizujú podľa zadaných objektov.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Všetky verzie metódy <code>spojnica</code>,
			 * ktoré neobsahujú parametre {@code orezanieZačiatku}
			 * a {@code orezanieKonca} rušia oblasti orezania začiatku a konca
			 * spojnice.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho štýlu
			 * čiary alebo inštancie farebnosti je povolené zadať aj hodnotu
			 * {@code valnull}, čo značí automatické hodnoty podľa aktuálnych
			 * vlastností zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param čiara objekt určujúci typ čiary spojnice
			 * @param objekt objekt, podľa ktorého sa určí farba čiary
			 *     spojnice
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ,
				Stroke čiara, Farebnosť objekt)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == objekt)
							s.farba = null;
						else
							s.farba = objekt.farba();
						s.čiara = čiara;
						s.orezanieZačiatku = null;
						s.orezanieKonca = null;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(objekt.farba(), objekt.farba(),
					čiara, this, cieľ, null, null);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať
			 * aktuálnu farbu a hrúbku (aj typ) čiary tohto robota, ak
			 * spojnica medzi týmto a zadaným robotom jestvuje, jej farba
			 * a hrúbka (aj typ) čiary sa aktualizujú podľa zdrojového robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						s.farba = farbaRobota;
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farbaRobota, cieľ.farba(),
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * hrúbku čiary a aktuálnu farbu tohto robota (typ čiary bude
			 * predvolený – súvislá čiara). Ak spojnica jestvuje, hrúbka čiary
			 * sa aktualizuje zadanou hodnotou (typ bude opäť predvolený –
			 * súvislá čiara) a farba sa aktualizuje podľa aktuálnej farby
			 * tohto robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> V tomto prípade je povolené
			 * zadávať zápornú hodnotu hrúbky čiary, čo značí automatický
			 * štýl čiary spojnice určený podľa aktuálneho štýlu čiary
			 * zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param hrúbka hrúbka čiary spojnice
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @throws GRobotException ak je hrúbka čiary záporná
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, double hrúbka,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				if (hrúbka < 0) throw new GRobotException(
					"Hrúbka čiary nesmie byť záporná!", "negativeLineWidth",
					new IllegalArgumentException());

				Stroke čiara = (hrúbka < 0) ? null : new BasicStroke(
					(float)hrúbka, BasicStroke.CAP_ROUND,
					BasicStroke.JOIN_ROUND);

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						s.farba = farbaRobota;
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farbaRobota, cieľ.farba(),
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * farbu čiary a hrúbku (aj typ) čiary podľa aktuálneho
			 * nastavenia tohto robota. Ak spojnica jestvuje, jej farba sa
			 * aktualizuje zadanou hodnotou a hrúbka čiary sa aktualizuje
			 * podľa aktuálnej hrúbky (a typu) čiary tohto robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétnej farby
			 * je povolené zadať aj hodnotu {@code valnull}, ktorá signalizuje
			 * automatickú farbu podľa aktuálnej hodnoty zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param farba farba čiary spojnice (argument musí byť objekt
			 *     typu {@link Color Color} alebo potomok)
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Color farba,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farba,
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * hrúbku a farbu čiary (typ čiary bude predvolený – súvislá
			 * čiara). Ak spojnica jestvuje, hrúbka a farba čiary sa
			 * aktualizujú zadanými hodnotami (typ bude opäť predvolený –
			 * súvislá čiara).
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> V tomto prípade je povolené
			 * zadávať zápornú hodnotu hrúbky čiary a hodnotu
			 * {@code valnull} namiesto konkrétnej farby, čo značí
			 * automatické hodnoty podľa aktuálnych vlastností zdrojového
			 * robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param hrúbka hrúbka čiary spojnice
			 * @param farba farba čiary spojnice (argument musí byť objekt
			 *     typu {@link Color Color} alebo potomok)
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @throws GRobotException ak je hrúbka čiary záporná
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, double hrúbka, Color farba,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				if (hrúbka < 0) throw new GRobotException(
					"Hrúbka čiary nesmie byť záporná!", "negativeLineWidth",
					new IllegalArgumentException());

				Stroke čiara = (hrúbka < 0) ? null : new BasicStroke(
					(float)hrúbka, BasicStroke.CAP_ROUND,
					BasicStroke.JOIN_ROUND);

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farba,
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať farbu
			 * čiary určenú zadaným objektom a hrúbku (aj typ) čiary podľa
			 * aktuálneho nastavenia tohto robota. Ak spojnica jestvuje, jej
			 * farba sa aktualizuje podľa farby zadaného objektu a hrúbka (aj
			 * typ) čiary sa aktualizuje podľa aktuálnej hrúbky čiary tohto
			 * robota. (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho objektu
			 * farebnosti je povolené zadať hodnotu {@code valnull}, čo značí
			 * automatickú farbu podľa aktuálnej hodnoty zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param objekt objekt, podľa ktorého bude určená farba čiary
			 *     spojnice
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Farebnosť objekt,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == objekt)
							s.farba = null;
						else
							s.farba = objekt.farba();
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(objekt.farba(), objekt.farba(),
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadanú
			 * hrúbku a farbu čiary podľa zadaného objektu (typ čiary bude
			 * predvolený – súvislá čiara). Ak spojnica jestvuje, hrúbka čiary
			 * sa aktualizuje zadanou hodnotou a farba sa aktualizuje podľa
			 * farby zadaného objektu (typ čiary bude opäť predvolený – súvislá
			 * čiara).
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> V tomto prípade je povolené
			 * zadávať zápornú hodnotu hrúbky čiary a hodnotu
			 * {@code valnull} namiesto konkrétnej inštancie farebnosti, čo
			 * značí automatické hodnoty podľa aktuálnych vlastností
			 * zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param hrúbka hrúbka čiary spojnice
			 * @param objekt objekt, podľa ktorého sa určí farba čiary
			 *     spojnice
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @throws GRobotException ak je hrúbka čiary záporná
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, double hrúbka,
				Farebnosť objekt, Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				if (hrúbka < 0) throw new GRobotException(
					"Hrúbka čiary nesmie byť záporná!", "negativeLineWidth",
					new IllegalArgumentException());

				Stroke čiara = (hrúbka < 0) ? null : new BasicStroke(
					(float)hrúbka, BasicStroke.CAP_ROUND,
					BasicStroke.JOIN_ROUND);

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == objekt)
							s.farba = null;
						else
							s.farba = objekt.farba();
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(objekt.farba(), objekt.farba(),
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadaný
			 * typ čiary a aktuálnu farbu tohto robota. Ak spojnica jestvuje,
			 * typ čiary sa aktualizuje podľa zadaného objektu a farba sa
			 * aktualizuje podľa aktuálnej farby tohto robota.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho štýlu
			 * čiary je povolené zadať hodnotu {@code valnull}, čo značí
			 * automatický štýl čiary spojnice určený podľa aktuálneho štýlu
			 * čiary zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param čiara objekt určujúci typ čiary spojnice
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Stroke čiara,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						s.farba = farbaRobota;
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farbaRobota, cieľ.farba(),
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať zadaný
			 * typ a farbu čiary. Ak spojnica jestvuje, typ a farba čiary sa
			 * aktualizujú zadanými hodnotami.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho štýlu
			 * čiary alebo farby je povolené zadať hodnotu {@code valnull},
			 * čo značí automatické hodnoty podľa aktuálnych vlastností
			 * zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param čiara objekt určujúci typ čiary spojnice
			 * @param farba farba čiary spojnice (argument musí byť objekt
			 *     typu {@link Color Color} alebo potomok)
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Stroke čiara, Color farba,
				Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farba,
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}

			/**
			 * <p>Vytvorí novú alebo upraví parametre jestvujúcej spojnice
			 * medzi týmto a zadaným robotom. Nová spojnica bude mať typ
			 * a farbu čiary podľa zadaných objektov. Ak spojnica jestvuje,
			 * typ a farba čiary sa aktualizujú podľa zadaných objektov.
			 * (Ide o spojnicu smerujúcu od tohto robota.)
			 * Navyše budú nastavené alebo aktualizované parametre orezania
			 * začiatku a/alebo konca spojnice – posledné dva parametre
			 * ({@code orezanieZačiatku} a {@code orezanieKonca}) môžu
			 * určovať tvar oblasti orezania spojnice počas jej kreslenia.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Namiesto konkrétneho štýlu
			 * čiary alebo inštancie farebnosti je povolené zadať hodnotu
			 * {@code valnull}, čo značí automatické hodnoty podľa aktuálnych
			 * vlastností zdrojového robota.</p>
			 * 
			 * @param cieľ partnerský robot medzi ktorým bude vytvorená
			 *     alebo upravená jestvujúca spojnica
			 * @param čiara objekt určujúci typ čiary spojnice
			 * @param objekt objekt, podľa ktorého sa určí farba čiary
			 *     spojnice
			 * @param orezanieZačiatku tvar orezania začiatku spojnice alebo
			 *     {@code valnull} (začiatok spojnice je určený polohou
			 *     tohto, zdrojového, robota)
			 * @param orezanieKonca tvar orezania konca spojnice alebo
			 *     {@code valnull} (koniec spojnice je určený polohou
			 *     cieľového robota – pozri parameter {@code cieľ})
			 * @return nová alebo jestvujúca {@linkplain Spojnica inštancia
			 *     spojnice}
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica spojnica(GRobot cieľ, Stroke čiara,
				Farebnosť objekt, Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == objekt)
							s.farba = null;
						else
							s.farba = objekt.farba();
						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(objekt.farba(), objekt.farba(),
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}


			// Súkromná metóda na kopírovanie spojníc…
			private Spojnica spojnica(GRobot cieľ, Stroke čiara, Color farba,
				Color farbaKonca, Shape orezanieZačiatku, Shape orezanieKonca)
			{
				if (null == cieľ || this == cieľ) return null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						if (null == farba)
							s.farba = null;
						else if (farba instanceof Farba)
							s.farba = (Farba)farba;
						else
							s.farba = new Farba(farba);

						if (null == farbaKonca)
							s.farbaKonca = null;
						else if (farbaKonca instanceof Farba)
							s.farbaKonca = (Farba)farbaKonca;
						else
							s.farbaKonca = new Farba(farbaKonca);

						s.čiara = čiara;
						s.orezanieZačiatku = orezanieZačiatku;
						s.orezanieKonca = orezanieKonca;
						Svet.automatickéPrekreslenie();
						return s;
					}
				}

				Spojnica s = new Spojnica(farba, farbaKonca,
					čiara, this, cieľ, orezanieZačiatku, orezanieKonca);
				spojnice.add(s);
				Svet.automatickéPrekreslenie();
				return s;
			}


			/**
			 * <p>Skopíruje (alebo aktualizuje) všetky spojnice podľa zadaného
			 * robota. Skopírujú (aktualizujú) sa jednak spojnice, ktoré boli
			 * definované smerom k zadanému robotu a aj spojnice definované
			 * smerom od neho.</p>
			 * 
			 * @param odKtorého robot, podľa ktorého budú vytvorené nové
			 *     (prípadne aktualizované jestvujúce) spojnice aktuálneho
			 *     robota
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public void kopírujSpojnice(GRobot odKtorého)
			{
				for (GRobot partner : zoznamRobotov)
				{
					for (int i = 0; i < partner.spojnice.size(); ++i)
					{
						Spojnica s = partner.spojnice.get(i);

						if (s.cieľ == odKtorého)
						{
							partner.spojnica(this, s.čiara, s.farba,
								s.orezanieZačiatku, s.orezanieKonca);
						}
					}
				}

				for (Spojnica s : odKtorého.spojnice)
					spojnica(s.cieľ, s.čiara, s.farba, s.farbaKonca,
						s.orezanieZačiatku, s.orezanieKonca);

				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #kopírujSpojnice(GRobot) kopírujSpojnice}.</p> */
			public void kopirujSpojnice(GRobot odKtorého)
			{ kopírujSpojnice(odKtorého); }

			/**
			 * <p>Zruší všetky spojnice smerujúce k tomuto aj od tohto robota.</p>
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #jeSpojnica(GRobot)
			 */
			public void zrušSpojnice()
			{
				for (GRobot partner : zoznamRobotov)
				{
					for (int i = 0; i < partner.spojnice.size(); ++i)
					{
						Spojnica s = partner.spojnice.get(i);
						if (s.cieľ == this) partner.spojnice.remove(i--);
					}
				}

				spojnice.clear();
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #zrušSpojnice() zrušSpojnice}.</p> */
			public void zrusSpojnice() { zrušSpojnice(); }

			/**
			 * <p>Zruší jestvujúcu spojnicu medzi týmto a zadaným robotom.
			 * (Smerujúcu od tohto robota.)</p>
			 * 
			 * @param cieľ partnerský robot voči ktorému bude zrušená
			 *     jestvujúca spojnica
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnice()
			 * @see #jeSpojnica(GRobot)
			 */
			public void zrušSpojnicu(GRobot cieľ)
			{
				Spojnica naZrušenie = null;

				for (Spojnica s : spojnice)
				{
					if (s.cieľ == cieľ)
					{
						naZrušenie = s;
						break;
					}
				}

				if (null != naZrušenie)
				{
					spojnice.remove(naZrušenie);
					Svet.automatickéPrekreslenie();
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #zrušSpojnicu(GRobot) zrušSpojnicu}.</p> */
			public void zrusSpojnicu(GRobot cieľ) { zrušSpojnicu(cieľ); }

			/**
			 * <p>Zistí, či medzi týmto a zadaným robotom jestvuje spojnica
			 * smerujúca od tohto robota.</p>
			 * 
			 * @param cieľ partnerský robot voči ktorému bude overená
			 *     existencia spojnice
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojnica(GRobot)
			 * @see #spojnica(GRobot, double)
			 * @see #spojnica(GRobot, Color)
			 * @see #spojnica(GRobot, double, Color)
			 * @see #spojnica(GRobot, double, Farebnosť)
			 * @see #spojnica(GRobot, Farebnosť)
			 * @see #spojnica(GRobot, Stroke)
			 * @see #spojnica(GRobot, Stroke, Color)
			 * @see #spojnica(GRobot, Stroke, Farebnosť)
			 * @see #spojnica(GRobot, Shape, Shape)
			 * @see #spojnica(GRobot, double, Shape, Shape)
			 * @see #spojnica(GRobot, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Color, Shape, Shape)
			 * @see #spojnica(GRobot, double, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Farebnosť, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Color, Shape, Shape)
			 * @see #spojnica(GRobot, Stroke, Farebnosť, Shape, Shape)
			 * @see #kopírujSpojnice(GRobot)
			 * @see #zrušSpojnicu(GRobot)
			 * @see #zrušSpojnice()
			 * @see #spojniceZ()
			 * @see #spojniceDo()
			 * @see #súSpojniceZ()
			 * @see #súSpojniceDo()
			 */
			public boolean jeSpojnica(GRobot cieľ)
			{
				for (Spojnica s : spojnice)
					if (s.cieľ == cieľ) return true;
				return false;
			}

			/** <p><a class="alias"></a> Alias pre {@link #jeSpojnica(GRobot) jeSpojnica}.</p> */
			public boolean máSpojnicu(GRobot cieľ) { return jeSpojnica(cieľ); }

			/** <p><a class="alias"></a> Alias pre {@link #jeSpojnica(GRobot) jeSpojnica}.</p> */
			public boolean maSpojnicu(GRobot cieľ) { return jeSpojnica(cieľ); }

			/**
			 * <p>Vytvorí zoznam všetkých spojníc smerujúcich z tohto
			 * robota.</p>
			 * 
			 * @return zoznam spojníc smerujúcich z tohto robota
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojniceDo()
			 * @see #súSpojniceZ()
			 * @see #súSpojniceDo()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica[] spojniceZ()
			{
				Spojnica[] zoznam = new Spojnica[spojnice.size()];
				return spojnice.toArray(zoznam);
			}

			/**
			 * <p>Vytvorí zoznam všetkých spojníc smerujúcich do tohto
			 * robota.</p>
			 * 
			 * @return zoznam spojníc smerujúcich do tohto robota
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojniceZ()
			 * @see #súSpojniceZ()
			 * @see #súSpojniceDo()
			 * @see #jeSpojnica(GRobot)
			 */
			public Spojnica[] spojniceDo()
			{
				Vector<Spojnica> spojnice = new Vector<>();
				try
				{
					for (GRobot partner : zoznamRobotov)
						for (Spojnica spojnica : partner.spojnice)
							if (spojnica.cieľ == this) spojnice.add(spojnica);

					Spojnica[] zoznam = new Spojnica[spojnice.size()];
					return spojnice.toArray(zoznam);
				}
				finally
				{
					spojnice.clear();
					spojnice = null;
				}
			}

			/**
			 * <p>Overí, či jestvuje aspoň jedna spojnica smerujúca z tohto
			 * robota. Niekedy je užitočné rýchlo overiť túto informáciu bez
			 * zbytočného vytvárania inštancií zoznamov.</p>
			 * 
			 * @return {@code valtrue}, ak jestvuje aspoň jedna spojnica
			 *     smerujúca z tohto robota
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojniceZ()
			 * @see #spojniceDo()
			 * @see #súSpojniceDo()
			 * @see #jeSpojnica(GRobot)
			 */
			public boolean súSpojniceZ() { return !spojnice.isEmpty(); }

			/** <p><a class="alias"></a> Alias pre {@link #súSpojniceZ() súSpojniceZ}.</p> */
			public boolean suSpojniceZ() { return súSpojniceZ(); }

			/**
			 * <p>Overí, či jestvuje aspoň jedna spojnica smerujúca do tohto
			 * robota. Niekedy je užitočné rýchlo overiť túto informáciu bez
			 * zbytočného vytvárania inštancií zoznamov.</p>
			 * 
			 * @see #dajSpojnicu(GRobot)
			 * @see #spojniceZ()
			 * @see #spojniceDo()
			 * @see #súSpojniceZ()
			 * @see #jeSpojnica(GRobot)
			 */
			public boolean súSpojniceDo()
			{
				for (GRobot partner : zoznamRobotov)
					for (Spojnica spojnica : partner.spojnice)
						if (spojnica.cieľ == this) return true;
				return false;
			}

			/** <p><a class="alias"></a> Alias pre {@link #súSpojniceDo() súSpojniceDo}.</p> */
			public boolean suSpojniceDo() { return súSpojniceDo(); }


		// Veľkosť robota, kolízna oblasť a detekcia kolízií

			/**
			 * <p><a class="getter"></a> Zistí aktuálnu veľkosť robota.
			 * Veľkosť robota je číslo, ktoré (v základnom stave
			 * robota) vymedzuje polomer kruhového priestoru so stredom na
			 * súradniciach robota. Chápanie údaju o veľkosti môže
			 * programátor upraviť preprogramovaním súvisiacich metód.
			 * Predvolená hodnota je {@code num10.0}. Veľkosť robota sa,
			 * okrem kreslenia predvoleného tvaru robota, používa aj pri
			 * základnom spôsobe {@linkplain #koliduje(GRobot) detekcie
			 * kolízií}, používajú ju bezparametrické verzie metód
			 * {@link #dopredu() dopredu} a {@link #vzad() vzad} a má vplyv
			 * aj na kreslenie {@linkplain #vlastnýTvar(String) vlastného
			 * obrázkového tvaru robota} (pozri aj metódu {@link #mierka()
			 * mierka}).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @return veľkosť robota
			 * 
			 * @see #veľkosť(double)
			 * @see #veľkosťDoma()
			 * @see #pomerDoma()
			 * @see #veľkosťPodľaMierky()
			 * @see #mierka()
			 */
			public double veľkosť() { return veľkosť; }

			/** <p><a class="alias"></a> Alias pre {@link #veľkosť() veľkosť}.</p> */
			public double velkost() { return veľkosť; }


			/**
			 * <p><a class="setter"></a> Nastaví novú veľkosť robota.
			 * Veľkosť robota je číslo, ktoré (v základnom stave
			 * robota) vymedzuje polomer kruhového priestoru so stredom na
			 * súradniciach robota. Chápanie údaju o veľkosti môže
			 * programátor upraviť preprogramovaním súvisiacich metód.
			 * Predvolená hodnota je {@code num10.0}. Veľkosť robota sa,
			 * okrem kreslenia predvoleného tvaru robota, používa aj pri
			 * základnom spôsobe {@linkplain #koliduje(GRobot) detekcie
			 * kolízií}, používajú ju bezparametrické verzie metód
			 * {@link #dopredu() dopredu} a {@link #vzad() vzad} a má vplyv
			 * aj na kreslenie {@linkplain #vlastnýTvar(String) vlastného
			 * obrázkového tvaru robota} (pozri aj metódu {@link #mierka()
			 * mierka}).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @param veľkosť nová veľkosť robota (mala by byť väčšia ako
			 *     nula, inak môže dôjsť k rôznym vedľajším efektom pri
			 *     používaní robota)
			 * 
			 * @see #veľkosť()
			 * @see #veľkosťDoma(Double)
			 * @see #pomerDoma(Double)
			 * @see #veľkosťPodľaMierky()
			 * @see #mierka()
			 */
			public void veľkosť(double veľkosť)
			{
				this.veľkosť = veľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #veľkosť(double) veľkosť}.</p> */
			public void velkost(double veľkosť) { veľkosť(veľkosť); }


			/**
			 * <p><a class="getter"></a> Vráti aktuálnu šírku robota.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @return aktuálna šírka robota
			 * 
			 * @see #šírka(double)
			 * @see #máŠírku(double)
			 * @see #rozmery()
			 */
			public double šírka() { return 2.0 * veľkosť * pomerVeľkosti; }

			/** <p><a class="alias"></a> Alias pre {@link #šírka() šírka}.</p> */
			public double sirka() { return šírka(); }

			/**
			 * <p><a class="getter"></a> Vráti aktuálnu výšku robota.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @return aktuálna výška robota
			 * 
			 * @see #výška(double)
			 * @see #máVýšku(double)
			 * @see #rozmery()
			 */
			public double výška() { return 2.0 * veľkosť; }

			/** <p><a class="alias"></a> Alias pre {@link #výška() výška}.</p> */
			public double vyska() { return výška(); }


			/**
			 * <p><a class="setter"></a> Nastaví novú šírku robota.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @param šírka nová šírka robota
			 * 
			 * @see #šírka()
			 * @see #máŠírku(double)
			 * @see #rozmery()
			 */
			public void šírka(double šírka)
			{
				// TODO – otestuj
				if (0 == veľkosť) pomerVeľkosti = 0;
				else pomerVeľkosti = (šírka / 2.0) / veľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #šírka(double) šírka}.</p> */
			public void sirka(double šírka) { šírka(šírka); }

			/**
			 * <p><a class="setter"></a> Nastaví novú výšku robota.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @param výška nová výška robota
			 * 
			 * @see #výška()
			 * @see #máVýšku(double)
			 * @see #rozmery()
			 */
			public void výška(double výška)
			{
				// TODO – otestuj
				double nováVeľkosť = výška / 2.0;
				if (0 == nováVeľkosť) pomerVeľkosti = 0;
				else pomerVeľkosti = (veľkosť * pomerVeľkosti) / nováVeľkosť;
				veľkosť = nováVeľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #výška(double) výška}.</p> */
			public void vyska(double výška) { výška(výška); }


			/**
			 * <p>Vráti objekt obsahujúci aktuálne hodnoty
			 * {@linkplain #šírka() šírky} a {@linkplain #výška() výšky}
			 * robota. (Ide o prepočítané hodnoty – pozri poznámku nižšie.)</p>
			 * 
			 * <hr />
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * <hr />
			 * 
			 * <p class="attention"><b>Upozornenie:</b> Do verzie 2.1
			 * programovacieho rámca bola táto metóda aliasom metódy {@link 
			 * #veľkosť() veľkosť}. (Z tohto vyjadrenia vyplýva, že
			 * toto už viac neplatí.) Od uvedenej verzie je táto metóda
			 * aliasom metódy {@link #rozmery() rozmery} (aby sa
			 * zabránilo zmätkom s podobnosťou názvov).</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Metóda pri každom volaní
			 * vytvorí novú inštanciu triedy {@link Rozmery Rozmery}. (Z toho
			 * vyplýva, že opakované a časté volanie tejto metódy je menej
			 * efektívne v porovnaní s inými metódami na zisťovanie rozmerov –
			 * znižuje výkon aplikácie.</p>
			 * 
			 * @return objekt vytvorený podľa aktuálnych rozmerov robota
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmery()
			 * @see #máŠírku(double)
			 * @see #máVýšku(double)
			 * @see #máRozmer(Rozmer)
			 * @see #máRozmer(double, double)
			 * @see #rozmer(Rozmer)
			 */
			public Rozmer rozmer()
			{
				// TODO (intro):
				// Počas vývoja padla otázka: Započítať do rozmerov aj
				// mierku? Odpoveď prišla pomaly, ale nakoniec bolo
				// rozhodnuté, že nie. Mohlo by to spôsobiť zmätok.
				// 
				// TODO (real):
				// Lepšie bude, ak bude vyrobená skupina metód typu
				// výslednáŠírka… Pozor! Nie „skutočná“ šírka. To by zase
				// mohlo spôsobovať zmätok, lebo niekto by pod „skutočnou“
				// mohol rozumieť práve tú pôvodnú.

				// šírka × výška; RegEx: (?:[Šš]írka|výška)\(
				return new Rozmery(2.0 * veľkosť * pomerVeľkosti,
					2.0 * veľkosť);
				// return veľkosť; // zastarané (deprecated)
			}

			/**
			 * <p>Nastaví nové rozmery robota podľa zadanej implementácie
			 * rozmeru.</p>
			 * 
			 * <hr />
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * <hr />
			 * 
			 * <p class="attention"><b>Upozornenie:</b> Do verzie 2.1
			 * programovacieho rámca bola táto metóda aliasom metódy {@link 
			 * #veľkosť(double) veľkosť}. (Z tohto vyjadrenia vyplýva, že
			 * toto už viac neplatí.) Od uvedenej verzie je táto metóda
			 * aliasom metódy {@link #rozmery(Rozmer) rozmery} (aby sa
			 * zabránilo zmätkom s podobnosťou názvov).</p>
			 * 
			 * @param rozmer inštancia obsahujúca nové rozmery robota
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmery()
			 * @see #máŠírku(double)
			 * @see #máVýšku(double)
			 * @see #máRozmer(Rozmer)
			 * @see #máRozmer(double, double)
			 * @see #rozmer()
			 */
			public void rozmer(Rozmer rozmer)
			{
				// TODO – otestuj
				veľkosť = rozmer.výška() / 2.0;
				if (0 == veľkosť) pomerVeľkosti = 0;
				else pomerVeľkosti = (rozmer.šírka() / 2.0) / veľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}


			/**
			 * <p>Zistí aktuálne rozmery robota.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @return objekt vytvorený podľa aktuálnych rozmerov robota
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmer()
			 * @see #rozmery()
			 * @see #máŠírku(double)
			 * @see #máVýšku(double)
			 * @see #máRozmer(Rozmer)
			 * @see #máRozmer(double, double)
			 * @see #rozmery(double, double)
			 * @see #rozmery(Rozmer)
			 */
			public Rozmery rozmery()
			{
				// TODO – otestuj
				return new Rozmery(2.0 * veľkosť * pomerVeľkosti,
					2.0 * veľkosť);
			}


			/**
			 * <p>Nastaví nové rozmery robota.</p>
			 * 
			 * <p class="attention"><b>Upozornenie:</b> {@code currRozmery}
			 * ({@linkplain #šírka() šírka} a {@linkplain #výška() výška})
			 * robota sú takpovediac „tieňové“ vlastnosti. V skutočnosti sú
			 * vnútorne tieto hodnoty premietané cez vlastnosti {@linkplain 
			 * #veľkosť() veľkosti} a {@linkplain #pomer() pomeru} robota.
			 * Pri nastavovaní rozmerov platí, že aktuálna veľkosť robota je
			 * nastavená na polovicou zadanej výšky a aktuálny pomer veľkosti
			 * robota je nastavený (vypočítaný) ako pomer (podiel) polovice
			 * zadanej šírky a novej veľkosti (ktorá bola práve vypočítaná).
			 * Podobne to platí naopak: výška je vypočítaná ako dvojnásobok
			 * aktuálnej veľkosti robota a šírka je súčinom výšky (ktorá bola
			 * práve vypočítaná) a pomeru veľkosti robota. Reálne <b>nie
			 * sú</b> hodnoty šírky a výšky robota uchovávané. (Vždy ide
			 * o prepočet.)</p>
			 * 
			 * <p><b>Vzorce prepočtov:</b></p>
			 * 
			 * <pre CLASS="example">
				{@code comm// Prepočet šírky a výšky na veľkosť a pomer veľkosti}
				{@code comm// (pozor, v druhom riadku je použitá vypočítaná}
				{@code comm// hodnota z prvého riadka):}
				veľkosť = výška / {@code num2.0};
				pomerVeľkosti = (šírka / {@code num2.0}) / veľkosť;
					{@code comm// (Poznámka: Ak je veľkosť nulová, tak je aj pomer nastavený na nulu.)}

				{@code comm// Prepočet veľkosti a pomeru veľkosti na šírku a výšku:}
				šírka = {@code num2.0} * veľkosť * pomerVeľkosti;
				výška = {@code num2.0} * veľkosť;
			 </pre>
			 * 
			 * @param šírka nová šírka robota
			 * @param výška nová výška robota
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmer()
			 * @see #máŠírku(double)
			 * @see #máVýšku(double)
			 * @see #máRozmer(Rozmer)
			 * @see #máRozmer(double, double)
			 * @see #rozmery()
			 * @see #rozmery(Rozmer)
			 */
			public void rozmery(double šírka, double výška)
			{
				// TODO – otestuj
				veľkosť = výška / 2.0;
				if (0 == veľkosť) pomerVeľkosti = 0;
				else pomerVeľkosti = (šírka / 2.0) / veľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/**
			 * <p>Nastaví nové rozmery robota podľa zadanej implementácie
			 * rozmeru.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Venujte pozornosť
			 * upozorneniu v opise metódy {@link #rozmery(double, double)
			 * rozmery}{@code (šírka, výška)}.</p>
			 * 
			 * @param rozmer inštancia obsahujúca nové rozmery robota
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmer()
			 * @see #máŠírku(double)
			 * @see #máVýšku(double)
			 * @see #máRozmer(Rozmer)
			 * @see #máRozmer(double, double)
			 * @see #rozmery()
			 * @see #rozmery(double, double)
			 */
			public void rozmery(Rozmer rozmer)
			{
				// TODO – otestuj
				veľkosť = rozmer.výška() / 2.0;
				if (0 == veľkosť) pomerVeľkosti = 0;
				else pomerVeľkosti = (rozmer.šírka() / 2.0) / veľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}


			/**
			 * <p>Zistí, či má robot zadanú šírku.</p>
			 * 
			 * @param šírka šírka, ktorá má byť porovnaná so šírkou robota
			 * @return {@code valtrue} ak sa šírka robota zhoduje so
			 *     zadanou šírkou, {@code valfalse} v opačnom prípade
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmery()
			 */
			public boolean máŠírku(double šírka)
			{ return (2.0 * veľkosť * pomerVeľkosti) == šírka; }

			/** <p><a class="alias"></a> Alias pre {@link #máŠírku(double) máŠírku}.</p> */
			public boolean maSirku(double šírka) { return máŠírku(šírka); }

			/**
			 * <p>Zistí, či má robot zadanú výšku.</p>
			 * 
			 * @param výška výška, ktorá má byť porovnaná s výškou robota
			 * @return {@code valtrue} ak sa výška robota zhoduje so
			 *     zadanou výškou, {@code valfalse} v opačnom prípade
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmery()
			 */
			public boolean máVýšku(double výška)
			{ return 2.0 * veľkosť == výška; }

			/** <p><a class="alias"></a> Alias pre {@link #máVýšku(double) máVýšku}.</p> */
			public boolean maVysku(double výška) { return máVýšku(výška); }


			/**
			 * <p>Overí, či sa rozmery robota a rozmery zadaného objektu
			 * dokonale zhodujú. Ak je zistená zhoda, tak je výsledkom
			 * {@code valtrue}, v opačnom prípade hodnota {@code valfalse}.</p>
			 * 
			 * @param rozmer iný objekt, ktorého rozmery majú byť porovnané
			 *     s rozmermi robota
			 * @return {@code valtrue} ak sa rozmery robota zhodujú s rozmermi
			 *     zadaného objektu, {@code valfalse} v opačnom prípade
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmery()
			 */
			public boolean máRozmer(Rozmer rozmer)
			{
				// TODO – otestuj – tiež máVýšku, máŠírku
				if (rozmer instanceof GRobot)
					return ((GRobot)rozmer).pomerVeľkosti == pomerVeľkosti &&
						((GRobot)rozmer).veľkosť == veľkosť;
				return rozmer.šírka() == (2.0 * veľkosť * pomerVeľkosti) &&
					rozmer.výška() == (2.0 * veľkosť);
			}

			/** <p><a class="alias"></a> Alias pre {@link #máRozmer(Rozmer) máRozmer}.</p> */
			public boolean maRozmer(Rozmer rozmer) { return máRozmer(rozmer); }


			/**
			 * <p>Overí, či sa rozmery robota dokonale zhodujú so zadanými
			 * rozmermi. Ak je zistená zhoda, tak je výsledkom
			 * {@code valtrue}, v opačnom prípade hodnota {@code valfalse}.</p>
			 * 
			 * @param šírka šírka porovnávaná so šírkou robota
			 * @param výška výška porovnávaná s výškou robota
			 * @return {@code valtrue} ak sa rozmery robota zhodujú so
			 *     zadanými rozmermi, {@code valfalse} v opačnom prípade
			 * 
			 * @see #šírka()
			 * @see #výška()
			 * @see #rozmery()
			 */
			public boolean máRozmer(double šírka, double výška)
			{
				return (2.0 * veľkosť * pomerVeľkosti) == šírka &&
					(2.0 * veľkosť) == výška;
			}

			/** <p><a class="alias"></a> Alias pre {@link #máRozmer(double, double) máRozmer}.</p> */
			public boolean maRozmer(double šírka, double výška)
			{ return máRozmer(šírka, výška); }


			/**
			 * <p>Nastaví veľkosť robota podľa aktuálnej {@linkplain 
			 * #mierka() mierky} tak, aby sa hodnota {@linkplain #mierka()
			 * mierky} vyrovnala na {@code num1.0}. (Ak bola veľkosť mierky
			 * už predtým jednotková, volanie metódy nebude mať žiadny efekt.)
			 * Ak mala {@linkplain #mierka() mierka} napríklad hodnotu
			 * {@code num2.0}, tak sa veľkosť robota zdvojnásobí
			 * (a {@linkplain #mierka() mierka} sa zresetuje na hodnotu
			 * {@code num1.0}).</p>
			 * 
			 * @see #veľkosťPodľaMierky(double)
			 * @see #veľkosť()
			 * @see #mierka()
			 */
			public void veľkosťPodľaMierky()
			{
				veľkosť = pôvodnáVeľkosť;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #veľkosťPodľaMierky() veľkosťPodľaMierky}.</p> */
			public void velkostPodlaMierky() { veľkosťPodľaMierky(); }

			// /**
			//  * <p><a class="alias"></a> Alias pre {@link #veľkosťPodľaMierky()
			//  * veľkosťPodľaMierky}.</p>
			//  * @deprecated
			//  */
			// @Deprecated public void rozmerPodľaMierky() { veľkosťPodľaMierky(); }

			// /**
			//  * <p><a class="alias"></a> Alias pre {@link #veľkosťPodľaMierky()
			//  * veľkosťPodľaMierky}.</p>
			//  * @deprecated
			//  */
			// @Deprecated public void rozmerPodlaMierky() { veľkosťPodľaMierky(); }

			/**
			 * <p>Nastaví veľkosť robota podľa aktuálnej {@linkplain 
			 * #mierka() mierky} tak, aby nová hodnota {@linkplain #mierka()
			 * mierky} nadobudla zadanú hodnotu.</p>
			 * 
			 * <p>Ak je napríklad veľkosť {@linkplain #mierka() mierky}
			 * rovná {@code num2.0}, {@linkplain #veľkosť() veľkosť robota}
			 * rovná {@code num20.0} a zadaná hodnota je rovná {@code num3.0},
			 * tak nová {@linkplain #veľkosť() veľkosť robota} bude
			 * {@code num30.0} a {@linkplain #mierka() mierka}
			 * {@code num3.0}.</p>
			 * 
			 * <p>Alebo napríklad veľkosť {@linkplain #mierka() mierky}
			 * rovná {@code num4.0}, {@linkplain #veľkosť() veľkosť robota}
			 * rovná {@code num25.0} a zadaná hodnota rovná {@code num6.0},
			 * tak nová {@linkplain #veľkosť() veľkosť robota} bude rovná
			 * {@code num37.5} (a nová hodnota {@linkplain #mierka() mierky}
			 * {@code num6.0}).</p>
			 * 
			 * @param zmena hodnota, ktorú má mať mierka po zmene veľkosti
			 *     robota
			 * 
			 * @see #veľkosťPodľaMierky()
			 * @see #veľkosť()
			 * @see #mierka()
			 */
			public void veľkosťPodľaMierky(double zmena)
			{
				// veľkosť *= veľkosť / pôvodnáVeľkosť * zmena;
				veľkosť = pôvodnáVeľkosť * zmena;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #veľkosťPodľaMierky(double) veľkosťPodľaMierky}.</p> */
			public void velkostPodlaMierky(double zmena)
			{ veľkosťPodľaMierky(zmena); }

			// /**
			//  * <p><a class="alias"></a> Alias pre {@link 
			//  * #veľkosťPodľaMierky(double) veľkosťPodľaMierky}.</p>
			//  * @deprecated
			//  */
			// @Deprecated public void rozmerPodľaMierky(double zmena)
			// { veľkosťPodľaMierky(zmena); }

			// /**
			//  * <p><a class="alias"></a> Alias pre {@link 
			//  * #veľkosťPodľaMierky(double) veľkosťPodľaMierky}.</p>
			//  * @deprecated
			//  */
			// @Deprecated public void rozmerPodlaMierky(double zmena)
			// { veľkosťPodľaMierky(zmena); }


			/**
			 * <p>Nastaví pomer veľkosti robota podľa aktuálnej {@linkplain 
			 * #mierkaPomeru() mierky pomeru} tak, aby sa hodnota {@linkplain 
			 * #mierkaPomeru() mierky pomeru} vyrovnala na {@code num1.0}. (Ak
			 * bola mierka pomeru už predtým jednotková, volanie metódy nebude
			 * mať žiadny efekt.) Ak mala {@linkplain #mierkaPomeru() mierka
			 * pomeru} napríklad hodnotu {@code num2.0}, tak sa pomer veľkosti
			 * robota zdvojnásobí (a {@linkplain #mierkaPomeru() mierka
			 * pomeru} sa zresetuje na hodnotu {@code num1.0}).</p>
			 * 
			 * @see #pomerPodľaMierky(double)
			 * @see #pomer()
			 * @see #mierkaPomeru()
			 */
			public void pomerPodľaMierky()
			{
				pomerVeľkosti = pôvodnýPomer;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #pomerPodľaMierky() pomerPodľaMierky}.</p> */
			public void pomerPodlaMierky() { pomerPodľaMierky(); }


			/**
			 * <p>Nastaví pomer veľkosti robota podľa aktuálnej {@linkplain 
			 * #mierkaPomeru() mierky pomeru} tak, aby nová hodnota
			 * {@linkplain #mierkaPomeru() mierky pomeru} nadobudla zadanú
			 * hodnotu.</p>
			 * 
			 * <p>Ak je napríklad hodnota {@linkplain #mierkaPomeru() mierky
			 * pomeru} rovná {@code num2.0}, {@linkplain #pomer() pomer
			 * veľkosti robota} sa rovná {@code num20.0} a zadaná hodnota je
			 * rovná {@code num3.0}, tak nová {@linkplain #pomer() pomeru
			 * veľkosti robota} bude {@code num30.0} a {@linkplain 
			 * #mierkaPomeru() mierka pomeru} {@code num3.0}.</p>
			 * 
			 * <p>Alebo napríklad hodnota {@linkplain #mierkaPomeru() mierky
			 * pomeru} sa rovná {@code num4.0}, {@linkplain #pomer() pomer
			 * veľkosti robota} je rovný {@code num25.0} a zadaná hodnota
			 * zmeny je {@code num6.0}, tak nová hodnota {@linkplain #pomer()
			 * pomeru veľkosti robota} bude rovná {@code num37.5} (a nová
			 * hodnota {@linkplain #mierkaPomeru() mierky pomeru}
			 * {@code num6.0}).</p>
			 * 
			 * @param zmena hodnota, ktorú má mať mierka pomeru po korekcii
			 *     pomeru veľkosti robota
			 * 
			 * @see #pomerPodľaMierky()
			 * @see #pomer()
			 * @see #mierkaPomeru()
			 */
			public void pomerPodľaMierky(double zmena)
			{
				pomerVeľkosti = pôvodnýPomer * zmena;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #pomerPodľaMierky(double) pomerPodľaMierky}.</p> */
			public void pomerPodlaMierky(double zmena)
			{ pomerPodľaMierky(zmena); }


			/**
			 * <p><a class="getter"></a> Zistí aktuálnu hodnotu mierky robota.
			 * Táto hodnota je prepočítavaná vnútorne. Na mierku má vplyv aj
			 * zmena hodnoty {@linkplain #veľkosť() veľkosti robota}
			 * (<small>pretože mierka je v skutočnosti pomerom aktuálnej
			 * veľkosti robota a veľkosti robota, ktorú mal pri svojom
			 * vytvorení, resete mierky alebo pri poslednej {@linkplain 
			 * #mierka(double) zmene mierky}</small>). Mierka sa resetuje
			 * pri zmene {@linkplain #vlastnýTvar(String) vlastného
			 * obrázkového tvaru robota}.</p>
			 * 
			 * <p>Mierka pôvodne primárne slúžila na úpravu veľkosti obrázkov
			 * pri ich kreslení robotom. Mierka má vplyv aj na
			 * kreslenie {@linkplain Oblasť oblastí} a {@linkplain Shape tvarov
			 * Javy} robotom. V tej súvislosti aj na zisťovanie prítomnosti
			 * {@linkplain #bodVTvare(double, double, Shape) bodov v tvaroch}
			 * a prípadne na ďalšie súvisiace vlastnosti/funkcie
			 * programovacieho rámca.</p>
			 * 
			 * <p>Mierka nemá vplyv na veľkosť kreslenia tvarov robota
			 * bezparametrickými verziami metód (napríklad {@link #kružnica()
			 * kružnica()}), ani na mieru pohybu robota bezparametrickými
			 * verziami metód pohybu (napríklad {@link #dopredu()
			 * dopredu()}). Má vplyv iba na {@linkplain #vlastnýTvar(String)
			 * veľkosť vlastného obrázkového tvaru robota.}</p>
			 * 
			 * @return aktuálna mierka robota
			 * 
			 * @see #mierka(double)
			 * @see #veľkosť()
			 * @see #veľkosťPodľaMierky()
			 */
			public double mierka() { return veľkosť / pôvodnáVeľkosť; }

			/**
			 * <p><a class="setter"></a> Upraví aktuálnu mierku robota. Táto
			 * hodnota je prepočítavaná vnútorne. Na mierku má vplyv aj zmena
			 * hodnoty {@linkplain #veľkosť() veľkosti robota}. Ďalšie
			 * informácie o význame a vplyve mierky sú v opise metódy
			 * {@link #mierka() mierka()}.</p>
			 * 
			 * @param mierka nová mierka robota
			 * 
			 * @see #mierka()
			 * @see #veľkosť()
			 * @see #veľkosťPodľaMierky()
			 */
			public void mierka(double mierka)
			{
				pôvodnáVeľkosť = veľkosť / mierka;
				Svet.automatickéPrekreslenie();
			}


			/**
			 * <p><a class="getter"></a> Zistí aktuálnu hodnotu mierky pomeru
			 * veľkosti robota. Táto hodnota je prepočítavaná vnútorne. Na
			 * mierku pomeru veľkosti má vplyv aj zmena hodnoty {@linkplain 
			 * #pomer() pomeru veľkosti robota} (<small>pretože mierka pomeru
			 * veľkosti je v skutočnosti pomerom aktuálneho pomeru veľkosti
			 * robota a pomeru, ktorý mal nastavený pri svojom vytvorení,
			 * resete mierky pomeru alebo pri poslednej {@linkplain 
			 * #mierkaPomeru(double) zmene mierky pomeru}</small>). Mierka sa
			 * resetuje pri zmene {@linkplain #vlastnýTvar(String) vlastného
			 * obrázkového tvaru robota}.</p>
			 * 
			 * <p>Táto mierka ovplyvňuje aj rozmery obrázkov pri ich kreslení
			 * robotom. Má vplyv aj na kreslenie {@linkplain Oblasť oblastí}
			 * a {@linkplain Shape tvarov Javy} robotom. V tej súvislosti aj
			 * na zisťovanie prítomnosti {@linkplain #bodVTvare(double,
			 * double, Shape) bodov v tvaroch}<!-- TODO – fakt? overiť…-->
			 * a prípadne na ďalšie súvisiace vlastnosti/funkcie
			 * programovacieho rámca.</p>
			 * 
			 * <p>Táto mierka nemá vplyv na rozmery kreslenia tvarov robota
			 * bezparametrickými verziami metód (napríklad {@link #kružnica()
			 * kružnica()}), ani na mieru pohybu robota bezparametrickými
			 * verziami metód pohybu (napríklad {@link #dopredu()
			 * dopredu()}). Má vplyv iba na {@linkplain #vlastnýTvar(String)
			 * rozmer vlastného obrázkového tvaru robota.}</p>
			 * 
			 * @return aktuálna mierka pomeru veľkosti robota
			 * 
			 * @see #mierkaPomeru(double)
			 * @see #pomer()
			 * @see #pomerPodľaMierky()
			 */
			public double mierkaPomeru()
			{ return pomerVeľkosti / pôvodnýPomer; }

			/**
			 * <p><a class="setter"></a> Upraví aktuálnu mierku pomeru
			 * veľkosti tohto robota. Táto hodnota je prepočítavaná vnútorne.
			 * Má na ňu vplyv aj zmena hodnoty {@linkplain #pomer() pomeru
			 * veľkosti robota}. Ďalšie informácie o význame a vplyve tejto
			 * mierky sú v opise metódy {@link #mierkaPomeru()
			 * mierkaPomeru()}.</p>
			 * 
			 * @param mierka nová mierka pomeru veľkosti robota
			 * 
			 * @see #mierkaPomeru()
			 * @see #pomer()
			 * @see #pomerPodľaMierky()
			 */
			public void mierkaPomeru(double mierka)
			{
				pôvodnýPomer = pomerVeľkosti / mierka;
				Svet.automatickéPrekreslenie();
			}


			/**
			 * <p><a class="getter"></a> Zistí aktuálnu hodnotu pomeru
			 * rozmerov (šírky a výšky) robota. Táto hodnota ovplyvňyje aj
			 * pomer šírky a výšky tých tvarov, pri ktorých nemusia byť ich
			 * rozmery (šírky a výšky) zhodné, čiže napríklad 
			 * {@linkplain #elipsa() elipsy} a {@linkplain #obdĺžnik()
			 * obdĺžnika}.</p>
			 * 
			 * <p><b>Pomer má vplyv len na tie metódy generovania tvarov,
			 * ktoré neprijímajú žiadny argument.</b> Výška tvaru je určená
			 * {@linkplain #veľkosť() veľkosťou robota} a šírka je od nej
			 * odvodená (vypočítaná podľa hodnoty pomeru). Predvolená hodnota
			 * pomeru je {@code num1.0}, čiže generované tvary majú predvolene
			 * rovnakú šírku a výšku. Ak sa hodnota pomeru zmení (napríklad)
			 * na {@code num2.0}, tak tvary budú mať dvojnásobnú šírku, ak na
			 * {@code num0.5}, tak polovičnú a tak ďalej.
			 * <br /> <br />
			 * V tejto súvislosti <b>venujte pozornosť upozorneniu v opise
			 * metódy {@link #rozmery(double, double) rozmery}{@code (šírka,
			 * výška)}.</b></p>
			 * 
			 * <p><image>pomery.png<alt/>Ukážy pomerov veľkostí.</image>Ukážky
			 * pomerov veľkostí: vľavo „obdĺžnik“ s predvoleným pomerom
			 * veľkostí (1; čiže štvorec, ibaže nakreslený metódou {@link 
			 * #obdĺžnik() obdĺžnik}), v strede obdĺžnik s pomerom 0,8 a vpravo
			 * s pomerom 1,2.</p>
			 * 
			 * <!-- super(600, 200);\n\nveľkosť(60);\nhrúbkaČiary(1.5);\nskry
			 * ();\n\npomer(0.8);\nobdĺžnik();\n\npomer(1.2);\npreskočVpravo
			 * (200);\nobdĺžnik();\n\npomer(1);\npreskočVľavo(400);\nobdĺžnik
			 * ();\n\nSvet.zbaľ();\npodlaha.uložObrázok("pomery.png"); -->
			 * 
			 * @return aktuálny pomer rozmerov robota
			 * 
			 * @see #pomer(double)
			 * @see #elipsa()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 */
			public double pomer() { return pomerVeľkosti; }

			/**
			 * <p><a class="setter"></a> Upraví aktuálny pomer rozmeru
			 * robota, čo má priamy vplyv na generovanie niektorých tvarov
			 * robotom.
			 * <!--   -->
			 * Ide o pomer šírky a výšky robota a v tej súvislosti tých
			 * tvarov, pri ktorých nemusia byť obidva ich rozmery (šírka
			 * a výška) zhodné, čiže napríklad {@linkplain #elipsa() elipsa}
			 * a {@linkplain #obdĺžnik() obdĺžnik}.
			 * <!--   -->
			 * <b>Pomer má vplyv len na tie metódy generovania tvarov, ktoré
			 * neprijímajú žiadny argument.</b> Rozmer dotknutých tvarov je,
			 * okrem tohto čísla, určený {@linkplain #veľkosť() veľkosťou
			 * robota}. Ďalšie informácie o význame a vplyve pomeru sú v opise
			 * metódy {@link #pomer() pomer()}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Od verzie 2.1 je pomer
			 * využívaný aj pri implementácii rozhrania {@link Rozmer Rozmer}.
			 * V tejto súvislosti <b>venujte pozornosť upozorneniu v opise
			 * metódy {@link #rozmery(double, double) rozmery}{@code (šírka,
			 * výška)}.</b></p>
			 * 
			 * @param pomer nový pomer rozmerov robota
			 * 
			 * @see #pomer()
			 * @see #elipsa()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 */
			public void pomer(double pomer)
			{
				pomerVeľkosti = pomer;
				if (viditeľný) Svet.automatickéPrekreslenie();
			}


			/**
			 * <p>Zistí aktuálne hodnoty šírky a výšky zaoblenia rohov
			 * pravouhlých útvarov generovaných robotom (štvorca
			 * a obdĺžnika).</p>
			 * 
			 * <p><image>zaoblenia.png<alt/>Ukážky
			 * zaoblenia.</image>Ukážky zaoblenia: vľavo obdĺžnik bez
			 * zaoblenia rohov, v strede nerovnomerné zaoblenie rohov (15 bodov
			 * horizontálne a 45 bodov vertikálne) a vpravo rovnomerné zaoblenie
			 * rohov (50 bodov).</p>
			 * 
			 * <!-- super(600, 200);\n\nveľkosť(60);\npomer(1.2);\nhrúbkaČiary
			 * (1.5);\nzaoblenie(15, 45);\nobdĺžnik();\nskry();\n\nzaoblenie
			 * (50);\npreskočVpravo(200);\nobdĺžnik();\n\npreskočVľavo(400);\n
			 * zaoblenie(0);\nobdĺžnik();\n\nSvet.zbaľ();\npodlaha.uložObrázok
			 * ("zaoblenia.png"); -->
			 * 
			 * @return reálnočíselné pole s hodnotami šírky a výšky zaoblenia
			 * 
			 * @see #zaoblenie(double)
			 * @see #zaoblenie(double, double)
			 * @see #zaoblenieX()
			 * @see #zaoblenieX(double)
			 * @see #zaoblenieY()
			 * @see #zaoblenieY(double)
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public double[] zaoblenie() { return new double[]
				{zaoblenieX, zaoblenieY}; }

			/**
			 * <p>Nastaví hodnoty zaoblenia rohov pravouhlých útvarov
			 * generovaných robotom (štvorca a obdĺžnika).</p>
			 * 
			 * @param zaoblenie nová hodnota zaoblenia (platí na šírku
			 *     aj výšku zároveň)
			 * 
			 * @see #zaoblenie()
			 * @see #zaoblenie(double, double)
			 * @see #zaoblenieX()
			 * @see #zaoblenieX(double)
			 * @see #zaoblenieY()
			 * @see #zaoblenieY(double)
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public void zaoblenie(double zaoblenie)
			{
				this.zaoblenieX = zaoblenie;
				this.zaoblenieY = zaoblenie;
			}

			/**
			 * <p>Nastaví šírku a výšku zaoblenia rohov pravouhlých útvarov
			 * generovaných robotom (štvorca a obdĺžnika).</p>
			 * 
			 * @param zaoblenieX nová šírka zaoblenia
			 * @param zaoblenieY nová výška zaoblenia
			 * 
			 * @see #zaoblenie()
			 * @see #zaoblenie(double)
			 * @see #zaoblenieX()
			 * @see #zaoblenieX(double)
			 * @see #zaoblenieY()
			 * @see #zaoblenieY(double)
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public void zaoblenie(double zaoblenieX, double zaoblenieY)
			{
				this.zaoblenieX = zaoblenieX;
				this.zaoblenieY = zaoblenieY;
			}

			/**
			 * <p><a class="getter"></a> Zistí aktuálnu hodnotu šírky
			 * zaoblenia rohov pravouhlých útvarov generovaných robotom
			 * (štvorca a obdĺžnika).</p>
			 * 
			 * @return šírka zaoblenia
			 * 
			 * @see #zaoblenie()
			 * @see #zaoblenie(double)
			 * @see #zaoblenie(double, double)
			 * @see #zaoblenieX(double)
			 * @see #zaoblenieY()
			 * @see #zaoblenieY(double)
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public double zaoblenieX() { return zaoblenieX; }

			/**
			 * <p><a class="setter"></a> Upraví šírku zaoblenia rohov
			 * pravouhlých útvarov generovaných robotom (štvorca
			 * a obdĺžnika).</p>
			 * 
			 * @param zaoblenieX nová šírka zaoblenia
			 * 
			 * @see #zaoblenie()
			 * @see #zaoblenie(double)
			 * @see #zaoblenie(double, double)
			 * @see #zaoblenieX()
			 * @see #zaoblenieY()
			 * @see #zaoblenieY(double)
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public void zaoblenieX(double zaoblenieX)
			{ this.zaoblenieX = zaoblenieX; }

			/**
			 * <p><a class="getter"></a> Zistí aktuálnu hodnotu výšky
			 * zaoblenia rohov pravouhlých útvarov generovaných robotom
			 * (štvorca a obdĺžnika).</p>
			 * 
			 * @return výška zaoblenia
			 * 
			 * @see #zaoblenie()
			 * @see #zaoblenie(double)
			 * @see #zaoblenie(double, double)
			 * @see #zaoblenieX()
			 * @see #zaoblenieX(double)
			 * @see #zaoblenieY(double)
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public double zaoblenieY() { return zaoblenieY; }

			/**
			 * <p><a class="setter"></a> Upraví výšku zaoblenia rohov
			 * pravouhlých útvarov generovaných robotom (štvorca
			 * a obdĺžnika).</p>
			 * 
			 * @param zaoblenieX nová výška zaoblenia
			 * 
			 * @see #zaoblenie()
			 * @see #zaoblenie(double)
			 * @see #zaoblenie(double, double)
			 * @see #zaoblenieX()
			 * @see #zaoblenieX(double)
			 * @see #zaoblenieY()
			 * @see #štvorec()
			 * @see #obdĺžnik()
			 * @see #veľkosť()
			 * @see #pomer()
			 */
			public void zaoblenieY(double zaoblenieY)
			{ this.zaoblenieY = zaoblenieY; }


			/**
			 * <p><a class="getter"></a> Vráti objekt aktívnej kolíznej oblasti
			 * tohto robota alebo {@code valnull}, ak oblasť nebola definovaná.
			 * Pre viac informácií pozrite setter vlastnosti {@link 
			 * #kolíznaOblasť(Shape) kolíznaOblasť}.</p>
			 * 
			 * @return objekt typu {@link Oblasť Oblasť} alebo
			 *     {@code valnull}
			 */
			public Oblasť kolíznaOblasť() { return kolíznaOblasť; }

			/** <p><a class="alias"></a> Alias pre {@link #kolíznaOblasť() kolíznaOblasť}.</p> */
			public Oblast koliznaOblast() { return new Oblast(kolíznaOblasť); }

			/* cancelled – zbytočné po zovšeobecnení; Area je tiež Shape… *
			 * 
			 * <p><a class="setter"></a> Definuje kolíznu oblasť, ktorú bude od tohto okamihu
			 * využívať robot na detekciu kolízií s pomocou metódy {@link 
			 * #koliduje(GRobot) koliduje}. Použitie kolíznej oblasti je
			 * v rozpoznávaní kolízií presnejšie, ale značne pomalšie než
			 * predvolený spôsob detekcie kolízií (kružnicami; pozri metódu
			 * {@link #koliduje(GRobot) koliduje}). Ak chcete kolíznu oblasť
			 * zrušiť, tak buď zadajte namiesto argumentu tejto metódy hodnotu
			 * {@code (Oblasť)}{@code valnull}, alebo zavolajte metódu
			 * {@link #zrušKolíznuOblasť() zrušKolíznuOblasť}.
			 * 
			 * <p>Podrobnosti o spôsobe detekcie kolízií a význame kolíznej
			 * oblasti nájdete v opise metódy {@link #koliduje(GRobot)
			 * koliduje}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Hodnota {@code valnull}
			 * nemá žiadny údajový typ. Je akoby „spoločná pre všetky
			 * údajové typy.“ Táto hodnota vyjadruje neprítomnosť
			 * žiadneho objektu, neprítomnosť žiadnej inštancie.
			 * V skutočnosti nie je a nikdy nebude možné určiť jej typ.
			 * Pri volaní metódy musí byť pretypovanie prítomné preto,
			 * aby kompilátor dokázal určiť, ktorú verziu z preťažených
			 * metód má volať.</p>
			 * 
			 * @param kolíznaOblasť objekt typu {@link Area Area} (resp.
			 *     odvodeného typu {@link Oblasť Oblasť}) alebo pretypovaná
			 *     hodnota {@code (Area)}{@code valnull} (resp. {@code 
			 *     (Oblasť)}{@code valnull})
			 * /
			public void kolíznaOblasť(Area kolíznaOblasť)
			{
				if (null == kolíznaOblasť)
				{
					this.kolíznaOblasť = null;
				}
				else if (kolíznaOblasť instanceof Oblasť)
				{
					this.kolíznaOblasť = (Oblasť)kolíznaOblasť;
				}
				else
				{
					this.kolíznaOblasť = new Oblasť(kolíznaOblasť);
				}
			}

			/* * <p><a class="alias"></a> Alias pre {@link #kolíznaOblasť(Oblasť) kolíznaOblasť}.</p> * /
			public void koliznaOblast(Area kolíznaOblasť)
			{ kolíznaOblasť(kolíznaOblasť); }*/


			/**
			 * <p><a class="setter"></a> S pomocou zadaného tvaru definuje
			 * novú kolíznu oblasť, ktorú bude od tohto okamihu využívať
			 * robot na detekciu kolízií s pomocou metódy {@link 
			 * #koliduje(GRobot) koliduje}.
			 * Použitie kolíznej oblasti je v rozpoznávaní kolízií presnejšie,
			 * ale značne pomalšie než predvolený spôsob detekcie kolízií
			 * (kružnicami; pozri metódu {@link #koliduje(GRobot) koliduje}).
			 * Ak chcete kolíznu oblasť zrušiť, tak buď zadajte namiesto
			 * argumentu tejto metódy hodnotu {@code valnull},
			 * alebo zavolajte metódu {@link #zrušKolíznuOblasť()
			 * zrušKolíznuOblasť}.</p>
			 * 
			 * <p>Podrobnosti o spôsobe detekcie kolízií a význame kolíznej
			 * oblasti nájdete v opise metódy {@link #koliduje(GRobot)
			 * koliduje}.</p>
			 * 
			 * @param podľaTvaru objekt typu {@link Shape Shape} (resp.
			 *     {@link Area Area} alebo {@link Oblasť Oblasť}) alebo
			 *     hodnota {@code valnull}
			 */
			public void kolíznaOblasť(Shape podľaTvaru)
			{
				if (null == podľaTvaru)
				{
					kolíznaOblasť = null;
				}
				else if (podľaTvaru instanceof Oblasť)
				{
					kolíznaOblasť = (Oblasť)podľaTvaru;
				}
				else
				{
					kolíznaOblasť = new Oblasť(podľaTvaru);
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #kolíznaOblasť(Shape) kolíznaOblasť}.</p> */
			public void koliznaOblast(Shape podľaTvaru)
			{ kolíznaOblasť(podľaTvaru); }

			/**
			 * <p><a class="setter"></a> Zruší kolíznu oblasť. Od tohto okamihu
			 * budú kolízie vyhodnocované predvoleným spôsobom – pozri opisy
			 * metód {@link #kolíznaOblasť(Shape) kolíznaOblasť}
			 * a {@link #koliduje(GRobot) koliduje}.</p>
			 */
			public void zrušKolíznuOblasť() { kolíznaOblasť = null; }

			/** <p><a class="alias"></a> Alias pre {@link #zrušKolíznuOblasť() zrušKolíznuOblasť}.</p> */
			public void zrusKoliznuOblast() { kolíznaOblasť = null; }

			/**
			 * <p>Zistí, či tento a zadaný robot vzájomne „kolidujú,“ t. j. či
			 * nastala ich vzájomná „zrážka“ alebo nie. Overenie tejto
			 * situácie nie je jednoduchá a priamočiara záležitosť.
			 * Najjednoduchší (a výpočtovo najrýchlejší) spôsob je zistiť
			 * ich vzájomnú vzdialenosť, ktorá ak klesne pod určitú hranicu
			 * (v tomto prípade sa berie do úvahy súčet
			 * {@linkplain #veľkosť(double) veľkostí} oboch robotov), tak to
			 * bude vyhodnotené ako kolízia. V praxi tento prístup vytvorí
			 * efekt „neviditeľných kruhových bublín“ okolo stredov obidvoch
			 * robotov, ktorých „stret“ (čiatočné prekrytie) znamená kolíziu:</p>
			 * 
			 * <p><image>kolizia-1.png<alt/>Znázornenie aktívnych oblastí
			 * robotov pri základnej detekcii kolízií.</image>Dva roboty na
			 * kolíznom kurze a pri kolízii<br /><small>(šedé kružnice sú
			 * ilustračné – v podstate označujú<br />neviditeľné bubliny,
			 * o ktorých sa píše vyššie)</small>.</p>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>V nasledujúcom príklade sú inicializovaní modrý a tyrkysový
			 * robot, v rámci čoho sú nasmerovaní na kolízny kurz zo svojej
			 * (novej) domovskej pozície. Po zrážke sa vrátia späť na domovskú
			 * pozíciu a celý cyklus sa zopakuje.</p>
			 * 
			 * <pre CLASS="example">
				{@code comm// Inicializácia modrého robota}
				{@code kwdprivate} {@code kwdfinal} {@code kwdstatic} {@link GRobot GRobot} modrý = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
				{{
					{@link #zdvihniPero() zdvihniPero}();
					{@link #farba(Color) farba}({@link Farebnosť#modrá modrá});
					{@link #veľkosť(double) veľkosť}({@code num20});
					{@link #domov(double, double, double) domov}({@code num40}, {@code num35}, {@code num200});
					{@link #rýchlosť(double) rýchlosť}({@code num10});
				}};

				{@code comm// Inicializácia tyrkysového robota}
				{@code kwdprivate} {@code kwdfinal} {@code kwdstatic} {@link GRobot GRobot} tyrkysový = {@code kwdnew} {@link GRobot#GRobot() GRobot}()
				{{
					{@link #zdvihniPero() zdvihniPero}();
					{@link #farba(Color) farba}({@link Farebnosť#tyrkysová tyrkysová});
					{@link #veľkosť(double) veľkosť}({@code num15});
					{@link #domov(double, double, double) domov}(&#45;{@code num40}, &#45;{@code num35}, {@code num80});
					{@link #rýchlosť(double) rýchlosť}({@code num10});
				}};

				{@code comm// Konštruktor hlavnej triedy}
				{@code kwdprivate} HlavnáTrieda()
				{
					{@link #skry() skry}();
					{@link #aktivuj() aktivuj}();
				}

				{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@link #aktivita() aktivita}()
				{
					{@code comm// Detekcia kolízií modrého a tyrkysového robota}
					{@code comm// v reakcii na aktivitu v hlavnej triede}
					{@code kwdif} (modrý.{@code currkoliduje}(tyrkysový))
					{
						{@link Svet Svet}.{@link Svet#pípni() pípni}();
						modrý.{@link #domov() domov}();
						tyrkysový.{@link #domov() domov}();
					}
				}
				</pre>
			 * 
			 * <p><b>Výsledok:</b></p>
			 * 
			 * <p><image>kolizia-1.gif<alt/>Animácia základného spôsobu
			 * detekcie kolízie.</image>Animácia príkladu.</p>
			 * 
			 * <p> </p>
			 * 
			 * <p>Tento základný prístup však nemusí vždy vyhovovať. Ak chceme
			 * dosiahnuť presné zistenie kolízie, musíme zvoliť iný spôsob.
			 * Roboty podporujú určenie {@linkplain #kolíznaOblasť(Shape)
			 * kolíznej oblasti}. Zistenie stretu dvoch robotov s pomocou
			 * {@linkplain Oblasť oblastí} je <em>presné, ale náročnejšie na
			 * výpočet,</em> takže je zároveň aj pomalšie. Použitie kolíznych
			 * oblastí je potrebné vopred dobre zvážiť. Odporúčame ich
			 * používať veľmi obozretne – v menšej miere. Rozhodne nie pre
			 * veľké množstvo naraz jestvujúcich potenciálne kolidujúcich
			 * robotov.</p>
			 * 
			 * <p>Ďalším spôsobom zistenia kolízie môže byť overenie, či sa
			 * určitý bod (napríklad robot, resp. jeho poloha) nachádza
			 * v sledovanom útvare –
			 * {@linkplain #bodVKruhu(Poloha, double) kruhu},
			 * {@linkplain #bodVElipse(Poloha, double, double) elipse},
			 * {@linkplain #bodVoŠtvorci(Poloha, double) štvorci},
			 * {@linkplain #bodVObdĺžniku(Poloha, double, double) obdĺžniku},
			 * {@linkplain #bodVCeste(Poloha) ceste},
			 * {@linkplain #bodVOblasti(Poloha, Area) oblasti},
			 * {@linkplain #bodVTvare(Poloha, Shape) tvare}…</p>
			 * 
			 * <p class="attention"><b>Upozornenie:</b> Ak má aspoň jeden
			 * robot definovanú {@linkplain #kolíznaOblasť(Shape) kolíznu
			 * oblasť}, tak je braná do úvahy aj {@linkplain #mierka()
			 * mierka} robotov. V opačnom prípade nemá {@linkplain #mierka()
			 * mierka} na funkciu tejto metódy vplyv.</p>
			 * 
			 * @param iný iný robot, ktorého vzájomnú kolíziu s týmto robotom
			 *     chceme otestovať
			 */
			public boolean koliduje(GRobot iný)
			{
				if (null == kolíznaOblasť && null == iný.kolíznaOblasť)
				{
					final double Σr = veľkosť + iný.veľkosť;
					final double Δx = iný.aktuálneX - aktuálneX;
					final double Δy = iný.aktuálneY - aktuálneY;
					return Σr * Σr >= (Δx * Δx + Δy * Δy);
				}

				Area a, b;

				if (aktuálnyUhol == 90 && aktuálneX == 0 &&
					aktuálneY == 0 && pôvodnáVeľkosť == veľkosť &&
					pôvodnýPomer == pomerVeľkosti)
				{
					a = (null == kolíznaOblasť) ?
						new Area(new Ellipse2D.Double(
							Svet.prepočítajX(aktuálneX) - veľkosť,
							Svet.prepočítajY(aktuálneY) - veľkosť,
							2 * veľkosť, 2 * veľkosť)) :
								(Area)kolíznaOblasť.clone();
				}
				else
				{
					AffineTransform at = new AffineTransform();

					double prepočítanéX = Svet.prepočítajX(aktuálneX);
					double prepočítanéY = Svet.prepočítajY(aktuálneY);

					at.rotate(toRadians(90 - aktuálnyUhol),
						prepočítanéX, prepočítanéY);

					if (pôvodnáVeľkosť != veľkosť ||
						pôvodnýPomer != pomerVeľkosti)
					{
						double mierka = veľkosť / pôvodnáVeľkosť;
						double mierkaX = mierka * (pomerVeľkosti /
							pôvodnýPomer);
						at.translate(prepočítanéX, prepočítanéY);
						at.scale(mierkaX, mierka);
						at.translate(-prepočítanéX, -prepočítanéY);
					}

					at.translate(aktuálneX, -aktuálneY);
					a = kolíznaOblasť.createTransformedArea(at);
				}

				if (iný.aktuálnyUhol == 90 && iný.aktuálneX == 0 &&
					iný.aktuálneY == 0)
				{
					b = (null == iný.kolíznaOblasť) ?
						new Area(new Ellipse2D.Double(
							Svet.prepočítajX(iný.aktuálneX) - iný.veľkosť,
							Svet.prepočítajY(iný.aktuálneY) - iný.veľkosť,
							2 * iný.veľkosť, 2 * iný.veľkosť)) :
								iný.kolíznaOblasť;
				}
				else
				{
					AffineTransform at = new AffineTransform();
					at.rotate(toRadians(90 - iný.aktuálnyUhol),
						Svet.prepočítajX(iný.aktuálneX), Svet.prepočítajY(iný.aktuálneY));
					at.translate(iný.aktuálneX, -iný.aktuálneY);
					b = iný.kolíznaOblasť.createTransformedArea(at);
				}

				if (a.getBounds().intersects(b.getBounds()))
				{
					a.intersect(b);
					return !a.isEmpty();
				}

				return false;
			}


		// Meranie vzdialeností

			/**
			 * <p>Zistí, aká je vzdialenosť tohto robota od stredu
			 * súradnicovej sústavy.</p>
			 * 
			 * @return vzdialenosť robota od stredu súradnicovej sústavy
			 * 
			 * @see #vzdialenosťOd(double, double)
			 * @see #vzdialenosťOd(Poloha)
			 * @see #vzdialenosťOd(Shape)
			 * @see #vzdialenosťOdMyši()
			 * @see Svet#vzdialenosť(Poloha)
			 */
			public double vzdialenosť()
			{
				// return sqrt(pow(aktuálneX, 2) + pow(aktuálneY, 2));
				/*!!!
				return sqrt(aktuálneX * aktuálneX + aktuálneY * aktuálneY);
				*/
				return hypot(aktuálneX, aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosť() vzdialenosť}.</p> */
			public double vzdialenost() { return vzdialenosť(); }

			/**
			 * <p>Zistí vzdialenosť medzi týmto robotom a zadanými súradnicami na
			 * podlahe (strope).</p>
			 * 
			 * @param súradnicaBoduX x-ová súradnica bodu
			 * @param súradnicaBoduY y-ová súradnica bodu
			 * @return vzdialenosť medzi týmto robotom a zadaným bodom
			 * 
			 * @see #vzdialenosť()
			 * @see #vzdialenosťOd(Poloha)
			 * @see #vzdialenosťOdMyši()
			 */
			public double vzdialenosťOd(double súradnicaBoduX, double súradnicaBoduY)
			{
				/*!!!
				return sqrt(pow(súradnicaBoduX - aktuálneX, 2) +
					pow(súradnicaBoduY - aktuálneY, 2));
				*/
				return hypot(súradnicaBoduX - aktuálneX,
					súradnicaBoduY - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(double, double) vzdialenosťOd}.</p> */
			public double vzdialenostOd(double súradnicaBoduX, double súradnicaBoduY)
			{ return vzdialenosťOd(súradnicaBoduX, súradnicaBoduY); }

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(double, double) vzdialenosťOd}.</p> */
			public double vzdialenosťK(double súradnicaBoduX, double súradnicaBoduY)
			{
				/*!!!
				return sqrt(pow(súradnicaBoduX - aktuálneX, 2) +
					pow(súradnicaBoduY - aktuálneY, 2));
				*/
				return hypot(súradnicaBoduX - aktuálneX,
					súradnicaBoduY - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(double, double) vzdialenosťOd}.</p> */
			public double vzdialenostK(double súradnicaBoduX, double súradnicaBoduY)
			{ return vzdialenosťK(súradnicaBoduX, súradnicaBoduY); }

			/**
			 * <p>Zistí vzdialenosť medzi týmto a zadaným objektom.</p>
			 * 
			 * @param objekt objekt od ktorého zisťujeme vzdialenosť
			 * @return vzdialenosť medzi týmto robotom a zadaným objektom
			 * 
			 * @see #vzdialenosť()
			 * @see #vzdialenosťOd(double, double)
			 * @see #vzdialenosťOd(Poloha)
			 * @see #vzdialenosťOd(Shape)
			 * @see #vzdialenosťOdMyši()
			 * @see Svet#vzdialenosť(Poloha)
			 */
			public double vzdialenosťOd(Poloha objekt)
			{
				/*!!!
				return sqrt(pow(iný.aktuálneX - aktuálneX, 2) +
					pow(iný.aktuálneY - aktuálneY, 2));
				*/
				return hypot(objekt.polohaX() - aktuálneX,
					objekt.polohaY() - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(Poloha) vzdialenosťOd}.</p> */
			public double vzdialenostOd(Poloha objekt) { return vzdialenosťOd(objekt); }

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(Poloha) vzdialenosťOd}.</p> */
			public double vzdialenosťK(Poloha objekt)
			{
				/*!!!
				return sqrt(pow(iný.aktuálneX - aktuálneX, 2) +
					pow(iný.aktuálneY - aktuálneY, 2));
				*/
				return hypot(objekt.polohaX() - aktuálneX,
					objekt.polohaY() - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(Poloha) vzdialenosťOd}.</p> */
			public double vzdialenostK(Poloha objekt) { return vzdialenosťK(objekt); }

			/**
			 * <p>Zistí vzdialenosť medzi týmto robotom a stredom
			 * hraníc<sup>[1]</sup> zadaného tvaru.</p>
			 * 
			 * <p><small>[1] – nejde presne o stred útvaru; je použitý
			 * najrýchlejší a najjednoduchší spôsob zistenia približného
			 * stredu: vezme sa obdĺžnik tesne ohraničujúci útvar a určí sa
			 * jeho stred – čiže „stred hraníc.“</small></p>
			 * 
			 * @param tvar tvar Javy ({@link Shape Shape}), od stredu hraníc
			 *     ktorého zisťujeme vzdialenosť
			 * @return vzdialenosť medzi robotom a stredom hraníc zadaného
			 *     tvaru
			 * 
			 * @see #vzdialenosť()
			 * @see #vzdialenosťOd(Poloha)
			 * @see #vzdialenosťOdMyši()
			 */
			public double vzdialenosťOd(Shape tvar)
			{
				Rectangle2D hranice = tvar.getBounds2D();

				/*!!!
				return sqrt(pow((Svet.prepočítajSpäťX(hranice.getX()) +
					hranice.getWidth() / 2) - aktuálneX, 2) +
					pow((Svet.prepočítajSpäťY(hranice.getY()) -
					hranice.getHeight() / 2) - aktuálneY, 2));
				*/
				return hypot(
					(Svet.prepočítajSpäťX(hranice.getX()) +
						hranice.getWidth() / 2) - aktuálneX,
					(Svet.prepočítajSpäťY(hranice.getY()) -
						hranice.getHeight() / 2) - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(Shape) vzdialenosťOd}.</p> */
			public double vzdialenostOd(Shape tvar) { return vzdialenosťOd(tvar); }

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(Shape) vzdialenosťOd}.</p> */
			public double vzdialenosťK(Shape tvar)
			{
				Rectangle2D hranice = tvar.getBounds2D();

				/*!!!
				return sqrt(pow((Svet.prepočítajSpäťX(hranice.getX()) +
					hranice.getWidth() / 2) - aktuálneX, 2) +
					pow((Svet.prepočítajSpäťY(hranice.getY()) -
					hranice.getHeight() / 2) - aktuálneY, 2));
				*/
				return hypot(
					(Svet.prepočítajSpäťX(hranice.getX()) +
						hranice.getWidth() / 2) - aktuálneX,
					(Svet.prepočítajSpäťY(hranice.getY()) -
						hranice.getHeight() / 2) - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOd(Shape) vzdialenosťOd}.</p> */
			public double vzdialenostK(Shape tvar) { return vzdialenosťK(tvar); }

			/**
			 * <p>Zistí vzdialenosť medzi týmto robotom a aktuálnymi súradnicami
			 * myši.</p>
			 * 
			 * @return vzdialenosť medzi týmto robotom a súradnicami myši
			 * 
			 * @see #vzdialenosť()
			 * @see #vzdialenosťOd(Poloha)
			 * @see Svet#vzdialenosť(Poloha)
			 */
			public double vzdialenosťOdMyši()
			{
				return hypot(ÚdajeUdalostí.súradnicaMyšiX - aktuálneX,
					ÚdajeUdalostí.súradnicaMyšiY - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOdMyši() vzdialenosťOdMyši}.</p> */
			public double vzdialenostOdMysi() { return vzdialenosťOdMyši(); }

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOdMyši() vzdialenosťOdMyši}.</p> */
			public double vzdialenosťKMyši()
			{
				return hypot(ÚdajeUdalostí.súradnicaMyšiX - aktuálneX,
					ÚdajeUdalostí.súradnicaMyšiY - aktuálneY);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vzdialenosťOdMyši() vzdialenosťOdMyši}.</p> */
			public double vzdialenostKMysi() { return vzdialenosťKMyši(); }


		// Vlastný tvar robota

			/**
			 * <p>Táto metóda je predvolene prázdna. Jej prekrytím dokážeme
			 * upraviť predvolený tvar robota. Kreslenie v tele prekrytej
			 * metódy {@code currkresliTvar} podlieha rovnakým pravidlám ako
			 * kreslenie v tele metódy
			 * {@link KreslenieTvaru KreslenieTvaru}{@code .}{@link 
			 * KreslenieTvaru#kresli(GRobot) kresli}{@code (}{@link GRobot
			 * GRobot}{@code  r)}. Prekrytie tejto metódy ({@code 
			 * currkresliTvar}) je síce najjednoduchší spôsob zmeny tvaru
			 * robota, ale <em>je menej efektívny.</em></p>
			 * 
			 * <div class="remark"><p><b>Poznámka:</b> Táto metóda v skrytosti
			 * využíva rovnaký mechanizmus ako definovanie {@linkplain 
			 * KreslenieTvaru vlastného tvaru}. Pre väčšie množstvá inštancií
			 * jednej triedy odporúčame:</p>
			 * <ol>
			 * <li>implementovať rozhranie {@link KreslenieTvaru
			 * KreslenieTvaru}, ktoré obsahuje metódu
			 * {@link KreslenieTvaru#kresli(GRobot) kresli},</li>
			 * <li>staticky vytvoriť jednu inštanciu z tejto
			 * implementácie</li>
			 * <li>a tú vzápätí využiť (napríklad v konštruktore triedy)
			 * vo volaní metódy {@link #vlastnýTvar(KreslenieTvaru)
			 * vlastnýTvar(tvar)}. Príklad je v opise rozhrania
			 * {@link KreslenieTvaru KreslenieTvaru}.)</li>
			 * </ol></div>
			 * 
			 * <p><b>Príklad:</b></p>
			 * 
			 * <p>Robot s metódou {@code currkresliTvar} prekrytou
			 * nasledujúcim spôsobom bude mať tvar kružnice:</p>
			 * 
			 * <pre CLASS="example">
				{@code kwd@}Override {@code kwdpublic} {@code typevoid} {@code currkresliTvar}()
				{
					{@link #kružnica() kružnica}();
				}
				</pre>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Ak potrebujete vytlačiť
			 * na aktuálne plátno pečiatku aktuálneho tvaru, volajte metódu
			 * {@link #pečiatka() pečiatka}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy koliduje
			 * s názvom novších metód {@link #kresliTvar(Shape)
			 * kresliTvar(tvar)} a {@link #kresliTvar(Shape, boolean)
			 * kresliTvar(tvar, upravRobotom)} určených na kreslenie obrysov
			 * tvarov Javy, ktoré mohli byť napríklad importované z SVG
			 * súboru. Okrem toho je definovaná metóda {@link #kresliTvary()
			 * kresliTvary()}, ktorá slúži na opätovné povolenie kreslenia
			 * tvarov a písania textov robotom po ich vypnutí metódou
			 * {@link #nekresliTvary() nekresliTvary()}.</p>
			 * 
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #pečiatka()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void kresliTvar() {}

			/**
			 * <p>Nastaví predvolený tvar robota. Predvoleným tvarom robota
			 * je buď trojzubec (vyplnený alebo dutý, podľa toho, či je
			 * zapnuté alebo vypnuté {@linkplain #vypĺňajTvary(boolean)
			 * vypĺňanie tvarov robotom}), alebo tvar kreslený prekrytou
			 * metódou {@link #kresliTvar() kresliTvar}.</p>
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void predvolenýTvar()
			{
				vlastnýTvarObrázok = null;

				try // Nie vždy je metóda kresliTvar() zaručene pôvodná
				{
					if (getClass().getMethod("kresliTvar").getDeclaringClass().
						equals(GRobot.class)) vlastnýTvarKreslenie = null;
					else
						vlastnýTvarKreslenie = použiPrekrytúMetóduKresli;
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				this.vyplnený = vypĺňajTvary;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #predvolenýTvar() predvolenýTvar}.</p> */
			public void predvolenyTvar() { predvolenýTvar(); }

			/**
			 * <p>Nastaví predvolený vyplnený tvar robota. Predvoleným tvarom
			 * robota je buď trojzubec (v tomto prípade vyplnený), alebo tvar
			 * kreslený prekrytou metódou {@link #kresliTvar() kresliTvar}.</p>
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void predvolenýVyplnenýTvar()
			{
				vlastnýTvarObrázok = null;

				try // Nie vždy je metóda kresliTvar() zaručene pôvodná
				{
					if (getClass().getMethod("kresliTvar").getDeclaringClass().
						equals(GRobot.class)) vlastnýTvarKreslenie = null;
					else
						vlastnýTvarKreslenie = použiPrekrytúMetóduKresli;
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				this.vyplnený = true;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #predvolenýVyplnenýTvar() predvolenýVyplnenýTvar}.</p> */
			public void predvolenyVyplnenyTvar() { predvolenýVyplnenýTvar(); }

			/**
			 * <p>Nastaví predvolený dutý tvar robota. Predvoleným tvarom
			 * robota je buď trojzubec (v tomto prípade dutý), alebo tvar
			 * kreslený prekrytou metódou {@link #kresliTvar() kresliTvar}.</p>
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void predvolenýDutýTvar()
			{
				vlastnýTvarObrázok = null;

				try // Nie vždy je metóda kresliTvar() zaručene pôvodná
				{
					if (getClass().getMethod("kresliTvar").getDeclaringClass().
						equals(GRobot.class)) vlastnýTvarKreslenie = null;
					else
						vlastnýTvarKreslenie = použiPrekrytúMetóduKresli;
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				this.vyplnený = false;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #predvolenýDutýTvar() predvolenýDutýTvar}.</p> */
			public void predvolenyDutyTvar() { predvolenýDutýTvar(); }

			/**
			 * <p>Nastaví predvolený tvar robota. Predvoleným tvarom robota je
			 * buď trojzubec (vyplnený alebo dutý – v tomto prípade to závisí
			 * od hodnoty zadanej do parametra), alebo tvar kreslený prekrytou
			 * metódou {@link #kresliTvar() kresliTvar}. Argument
			 * {@code vyplnený} má význam len ak nebola prekrytá metóda
			 * {@link #kresliTvar() kresliTvar}. Vtedy zostáva predvoleným
			 * tvarom trojzubec a hodnota tohto argumentu umožňuje určiť, či
			 * má byť vyplnený alebo kreslený obrysom (dutý).</p>
			 * 
			 * @param vyplnený ak je {@code valtrue} a aktuálna inštancia
			 *     nemá prekrytú metódu {@link #kresliTvar() kresliTvar},
			 *     kreslí vyplnený trujzubec, inak jeho obrys
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void predvolenýTvar(boolean vyplnený)
			{
				vlastnýTvarObrázok = null;

				try // Nie vždy je metóda kresliTvar() zaručene pôvodná
				{
					if (getClass().getMethod("kresliTvar").getDeclaringClass().
						equals(GRobot.class)) vlastnýTvarKreslenie = null;
					else
						vlastnýTvarKreslenie = použiPrekrytúMetóduKresli;
				}
				catch (Exception e)
				{ GRobotException.vypíšChybovéHlásenia(e); }

				this.vyplnený = vyplnený;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #predvolenýTvar(boolean) predvolenýTvar}.</p> */
			public void predvolenyTvar(boolean vyplnený)
			{ predvolenýTvar(vyplnený); }

			/**
			 * <p>Overí spôsob kreslenia predvoleného tvaru trojzubca. Ak je
			 * robot v stave, kedy je jeho predvoleným tvarom trojzubec
			 * (pozri opis metódy {@link #predvolenýTvar(boolean)
			 * predvolenýTvar(vyplnený)} alebo jej príbuzných), tak táto metóda
			 * overí, či má byť vyplnený alebo dutý.</p>
			 * 
			 * @return {@code valtrue} ak má byť predvolený tvar trojzubca
			 *     vyplnený, {@code valfalse} ak má byť dutý
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public boolean jePredvolenýTvarVyplnený() { return vyplnený; }

			/** <p><a class="alias"></a> Alias pre {@link #jePredvolenýTvarVyplnený() jePredvolenýTvarVyplnený}.</p> */
			public boolean jePredvolenyTvarVyplneny() { return vyplnený; }

			/**
			 * <p>Zmení tvar robota z klasického tvaru na zadaný obrázok.
			 * Ak bola predtým volaná metóda
			 * {@link #vlastnýTvar(KreslenieTvaru) vlastnýTvar(KreslenieTvaru
			 * tvar)}, tak ňou definované vlastné kreslenie bude zrušené.</p>
			 * 
			 * <p>Nastavenie vlastného tvaru obrázka zresetuje {@linkplain 
			 * #mierka() mierku robota}. Ak chcete, aby veľkosť robota (aspoň
			 * približne) korešpondovala s veľkosťou obrázka, tak nastavte
			 * veľkosť robota na vhodnú hodnotu ešte <b>pred</b> nastavením
			 * vlastného tvaru obrázka alebo volajte metódu
			 * {@link #vlastnýTvar(String, boolean) vlastnýTvar("názov",
			 * upravVeľkosťRobota)} s druhým argumentom {@code valtrue}.</p>
			 * 
			 * <p class="tip"><b>Tipy:</b> Vhodná hodnota by mohla byť
			 * napríklad priemerná hodnota vypočítaná zo šírky a výšky
			 * obrázka. Presne túto hodnotu používa metóda
			 * {@link #vlastnýTvar(String, boolean) vlastnýTvar("názov",
			 * upravVeľkosťRobota)}.
			 * Ak chcete kombinovať vlastné kreslenie tvaru s obrázkami,
			 * použite iba {@linkplain #vlastnýTvar(KreslenieTvaru) vlastné
			 * kreslenie tvaru robota používajúce rozhranie}
			 * {@link KreslenieTvaru KreslenieTvaru} a v tele metódy
			 * {@link KreslenieTvaru#kresli(GRobot) kresli} uvedeného
			 * rozhrania volajte metódu robota {@link #obrázok(String)
			 * r.obrázok("názov súboru")}.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť použitý
			 *     namiesto predvoleného tvaru robota
			 * 
			 * @throws GRobotException ak súbor s obrázkom nebol nájdený
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 * @see Svet#priečinokObrázkov(String)
			 */
			public void vlastnýTvar(String súbor)
			{
				if (null != vlastnýTvarKreslenie)
					vlastnýTvarKreslenie = null;
				vlastnýTvarObrázok = Obrázok.súborNaObrázok(súbor);
				pôvodnáVeľkosť = veľkosť;
				pôvodnýPomer = pomerVeľkosti;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vlastnýTvar(String) vlastnýTvar}.</p> */
			public void vlastnyTvar(String súbor) { vlastnýTvar(súbor); }

			/**
			 * <p>Zmení tvar robota z klasického tvaru na zadaný obrázok.
			 * Ak bola predtým volaná metóda
			 * {@link #vlastnýTvar(KreslenieTvaru) vlastnýTvar(KreslenieTvaru
			 * tvar)}, tak ňou definované vlastné kreslenie bude zrušené.</p>
			 * 
			 * <p>Nastavenie vlastného tvaru obrázka zresetuje {@linkplain 
			 * #mierka() mierku robota}. Ak chcete, aby veľkosť robota (aspoň
			 * približne) korešpondovala s veľkosťou obrázka, tak nastavte
			 * veľkosť robota na vhodnú hodnotu ešte <b>pred</b> nastavením
			 * vlastného tvaru obrázka alebo volajte metódu
			 * {@link #vlastnýTvar(Image, boolean) vlastnýTvar(obrázok,
			 * upravVeľkosťRobota)} s druhým argumentom {@code valtrue}.</p>
			 * 
			 * <p class="tip"><b>Tipy:</b> Vhodná hodnota by mohla byť
			 * napríklad priemerná hodnota vypočítaná zo šírky a výšky
			 * obrázka. Presne túto hodnotu používa metóda
			 * {@link #vlastnýTvar(Image, boolean) vlastnýTvar(obrázok,
			 * upravVeľkosťRobota)}.
			 * Ak chcete kombinovať vlastné kreslenie tvaru s obrázkami,
			 * použite iba {@linkplain #vlastnýTvar(KreslenieTvaru) vlastné
			 * kreslenie tvaru robota používajúce rozhranie}
			 * {@link KreslenieTvaru KreslenieTvaru} a v tele metódy
			 * {@link KreslenieTvaru#kresli(GRobot) kresli} uvedeného
			 * rozhrania volajte metódu robota {@link #obrázok(Image)
			 * r.obrázok(obrázok)}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť použitý namiesto
			 *     predvoleného tvaru robota
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void vlastnýTvar(Image obrázok)
			{
				if (null != vlastnýTvarKreslenie)
					vlastnýTvarKreslenie = null;
				vlastnýTvarObrázok = obrázok;
				pôvodnáVeľkosť = veľkosť;
				pôvodnýPomer = pomerVeľkosti;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vlastnýTvar(Image) vlastnýTvar}.</p> */
			public void vlastnyTvar(Image obrázok) { vlastnýTvar(obrázok); }

			/**
			 * <p>Zmení tvar robota z klasického tvaru na zadaný obrázok.
			 * Ak bola predtým volaná metóda
			 * {@link #vlastnýTvar(KreslenieTvaru) vlastnýTvar(KreslenieTvaru
			 * tvar)}, tak ňou definované vlastné kreslenie bude zrušené.
			 * Ak je parameter {@code upravVeľkosťRobota} rovný
			 * {@code valtrue}, tak bude zároveň upravená
			 * {@link #veľkosť(double) veľkosť} robota a to tak, aby
			 * zodpovedala priemeru šírky a výšky obrázka.</p>
			 * 
			 * <p class="tip"><b>Tip:</b> Ak chcete kombinovať vlastné
			 * kreslenie tvaru s obrázkami, použite iba {@linkplain 
			 * #vlastnýTvar(KreslenieTvaru) vlastné kreslenie tvaru
			 * robota používajúce rozhranie} {@link KreslenieTvaru
			 * KreslenieTvaru} a v tele metódy
			 * {@link KreslenieTvaru#kresli(GRobot) kresli} uvedeného
			 * rozhrania volajte metódu robota {@link #obrázok(String)
			 * r.obrázok("názov súboru")}.</p>
			 * 
			 * <p>Obrázok prečítaný zo súboru je chápaný ako zdroj a po
			 * prečítaní zostane uložený vo vnútornej pamäti sveta. Z nej
			 * môže byť v prípade potreby (napríklad ak sa obsah súboru na
			 * disku zmenil) odstránený metódou {@link Svet#uvoľni(String)
			 * Svet.uvoľni(názovZdroja)}. (Táto informácia je platná pre
			 * všetky metódy pracujúce s obrázkami alebo zvukmi, ktoré
			 * prijímajú názov súboru ako parameter.)</p>
			 * 
			 * @param súbor názov súboru s obrázkom, ktorý má byť použitý
			 *     namiesto predvoleného tvaru robota
			 * @param upravVeľkosťRobota hodnota {@code valtrue} určuje, že
			 *     pred nastavením vlastného tvaru obrázka robota má byť
			 *     upravená jeho veľkosť tak, aby zodpovedala priemeru šírky
			 *     a výšky obrázka
			 * 
			 * @throws GRobotException ak súbor s obrázkom nebol nájdený
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(Image, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 * @see Svet#priečinokObrázkov(String)
			 */
			public void vlastnýTvar(String súbor, boolean upravVeľkosťRobota)
			{
				if (null != vlastnýTvarKreslenie)
					vlastnýTvarKreslenie = null;
				vlastnýTvarObrázok = Obrázok.súborNaObrázok(súbor);
				if (upravVeľkosťRobota)
				{
					// veľkosť = (vlastnýTvarObrázok.getWidth(null) +
					// 	vlastnýTvarObrázok.getHeight(null)) / 4;
					// toto už nie takto, treba upraviť výšku a šírku

					// ‼TODO‼ otestovať
					veľkosť = vlastnýTvarObrázok.getHeight(null) / 2.0;
					if (0 == veľkosť) pomerVeľkosti = 0;
					else pomerVeľkosti = (vlastnýTvarObrázok.getWidth(null) /
						2.0) / veľkosť;
				}

				// System.out.println(vlastnýTvarObrázok.getWidth(null));
				// System.out.println(vlastnýTvarObrázok.getHeight(null));
				// System.out.println(veľkosť);

				pôvodnáVeľkosť = veľkosť;
				pôvodnýPomer = pomerVeľkosti;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vlastnýTvar(String, boolean) vlastnýTvar}.</p> */
			public void vlastnyTvar(String súbor, boolean upravVeľkosťRobota)
			{ vlastnýTvar(súbor, upravVeľkosťRobota); }

			/**
			 * <p>Zmení tvar robota z klasického tvaru na zadaný obrázok.
			 * Ak bola predtým volaná metóda
			 * {@link #vlastnýTvar(KreslenieTvaru) vlastnýTvar(KreslenieTvaru
			 * tvar)}, tak ňou definované vlastné kreslenie bude zrušené.
			 * Ak je parameter {@code upravVeľkosťRobota} rovný
			 * {@code valtrue}, tak bude zároveň upravená
			 * {@link #veľkosť(double) veľkosť} robota a to tak, aby
			 * zodpovedala priemeru šírky a výšky obrázka.</p>
			 * 
			 * <p class="tip"><b>Tip:</b> Ak chcete kombinovať vlastné
			 * kreslenie tvaru s obrázkami, použite iba {@linkplain 
			 * #vlastnýTvar(KreslenieTvaru) vlastné kreslenie tvaru
			 * robota používajúce rozhranie} {@link KreslenieTvaru
			 * KreslenieTvaru} a v tele metódy
			 * {@link KreslenieTvaru#kresli(GRobot) kresli} uvedeného
			 * rozhrania volajte metódu robota {@link #obrázok(Image)
			 * r.obrázok(obrázok)}.</p>
			 * 
			 * @param obrázok obrázok, ktorý má byť použitý namiesto
			 *     predvoleného tvaru robota
			 * @param upravVeľkosťRobota hodnota {@code valtrue} určuje, že
			 *     pred nastavením vlastného tvaru obrázka robota má byť
			 *     upravená jeho veľkosť tak, aby zodpovedala priemeru šírky
			 *     a výšky obrázka
			 * 
			 * @see #kresliTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(KreslenieTvaru)
			 */
			public void vlastnýTvar(Image obrázok, boolean upravVeľkosťRobota)
			{
				if (null != vlastnýTvarKreslenie)
					vlastnýTvarKreslenie = null;
				vlastnýTvarObrázok = obrázok;
				if (upravVeľkosťRobota)
				{
					// Zastaraný spôsob (teraz treba použiť aj pomerVeľkosti):
					// 
					// veľkosť = (obrázok.getWidth(null) +
					// 	obrázok.getHeight(null)) / 4;

					// ‼TODO‼ otestovať
					veľkosť = (double)obrázok.getHeight(null) / 2.0;
					if (0 == veľkosť) pomerVeľkosti = 0;
					else pomerVeľkosti = ((double)obrázok.getWidth(null) /
						2.0) / veľkosť;
				}
				pôvodnáVeľkosť = veľkosť;
				pôvodnýPomer = pomerVeľkosti;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vlastnýTvar(Image, boolean) vlastnýTvar}.</p> */
			public void vlastnyTvar(Image obrázok, boolean upravVeľkosťRobota)
			{ vlastnýTvar(obrázok, upravVeľkosťRobota); }

			/**
			 * <p>Umožní kresliť vlastný tvar robota namiesto klasického tvaru.
			 * Metóda vyžaduje implementované rozhranie {@link KreslenieTvaru
			 * KreslenieTvaru}. Ak bola predtým volaná metóda
			 * {@link #vlastnýTvar(String) vlastnýTvar(String súbor)} alebo
			 * {@link #vlastnýTvar(Image) vlastnýTvar(Image obrázok)}, tak
			 * nimi definovaný obrázkový tvar bude zrušený.</p>
			 * 
			 * <p class="tip"><b>Tip:</b> Ak chcete kombinovať vlastné
			 * kreslenie tvaru s obrázkami, použite iba {@linkplain 
			 * #vlastnýTvar(KreslenieTvaru) vlastné kreslenie tvaru
			 * robota používajúce rozhranie} {@link KreslenieTvaru
			 * KreslenieTvaru} a v tele metódy
			 * {@link KreslenieTvaru#kresli(GRobot) kresli} uvedeného
			 * rozhrania volajte prislúchajúcu metódu robota:
			 * {@link #obrázok(String) r.obrázok("názov súboru")} alebo
			 * {@link #obrázok(Image) r.obrázok(obrázok)}.</p>
			 * 
			 * @param tvar implementácia rozhrania {@link KreslenieTvaru
			 *     KreslenieTvaru}
			 * 
			 * @see KreslenieTvaru
			 * @see #kresliTvar()
			 * @see #predvolenýVyplnenýTvar()
			 * @see #predvolenýDutýTvar()
			 * @see #predvolenýTvar()
			 * @see #predvolenýTvar(boolean)
			 * @see #jePredvolenýTvarVyplnený()
			 * @see #vlastnýTvar(String)
			 * @see #vlastnýTvar(Image)
			 * @see #vlastnýTvar(String, boolean)
			 * @see #vlastnýTvar(Image, boolean)
			 */
			public void vlastnýTvar(KreslenieTvaru tvar)
			{
				if (null != vlastnýTvarObrázok)
					vlastnýTvarObrázok = null;
				vlastnýTvarKreslenie = tvar;
				Svet.automatickéPrekreslenie();
			}

			/** <p><a class="alias"></a> Alias pre {@link #vlastnýTvar(KreslenieTvaru) vlastnýTvar}.</p> */
			public void vlastnyTvar(KreslenieTvaru tvar) { vlastnýTvar(tvar); }


		// Obmedzenie kreslenia

			/**
			 * <p>Povolí kreslenie tvarov a písanie textov robotom (predvolený
			 * stav). Metóda je opakom metódy {@link #nekresliTvary()
			 * nekresliTvary}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda spôsobí
			 * automatické {@linkplain #uvoľni() prepustenie} robota zo
			 * služieb kreslenia a tvorby {@linkplain Oblasť oblasti}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Názov tejto metódy je podobný
			 * názvom metód v singulári {@code kresliTvar}. Avšak tie slúžia
			 * na úplne iné účely. Metóda {@link #kresliTvar() kresliTvar()}
			 * je určená na prekrytie a kreslenie vlastného tvaru robota.
			 * A novšie metódy {@link #kresliTvar(Shape) kresliTvar(tvar)}
			 * a {@link #kresliTvar(Shape, boolean) kresliTvar(tvar,
			 * upravRobotom)} sú určené na kreslenie obrysov tvarov Javy,
			 * ktoré mohli byť napríklad importované z SVG súboru.</p>
			 * 
			 * @see #nekresliTvary()
			 * @see #kreslenieTvarovPovolené()
			 * @see #kružnica() kružnica
			 * @see #kresliElipsu(double) kresliElipsu
			 * @see #kresliŠtvorec() kresliŠtvorec
			 * @see #kresliObdĺžnik(double) kresliObdĺžnik
			 * @see #kresliHviezdu() kresliHviezdu
			 * @see #text(String, int) text
			 * @see #cesta() cesta
			 * @see #položPero() položPero
			 */
			public void kresliTvary()
			{
				uvoľni();
				kresliTvary = true;
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliTvary() kresliTvary}.</p> */
			public void kresliÚtvary() { kresliTvary(); }

			/** <p><a class="alias"></a> Alias pre {@link #kresliTvary() kresliTvary}.</p> */
			public void kresliUtvary() { kresliTvary(); }

			/**
			 * <p>Zakáže kreslenie tvarov ({@linkplain #kružnica(double)
			 * kružnice}, {@linkplain #kresliElipsu(double, double) elipsy},
			 * {@linkplain #kresliŠtvorec(double) štvorca}, {@linkplain 
			 * #kresliObdĺžnik(double, double) obdĺžnika}…) a {@linkplain 
			 * #text(String) písanie textu} robotom, aby prislúchajúce metódy
			 * mohli byť využité na iné účely, napríklad na {@linkplain 
			 * #nekresliDo(Shape) obmedzenie kreslenia}. Znamená to, že metódy
			 * na kreslenie útvarov a písanie textu robotom budú generovať
			 * tvary Javy ({@link Shape Shape}) bez ich vykreslenia na aktívne
			 * plátno robota. Kreslenie opäť povolíme metódou {@link 
			 * #kresliTvary() kresliTvary}.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Táto metóda spôsobí
			 * automatické {@linkplain #uvoľni() prepustenie} robota zo
			 * služieb kreslenia a tvorby {@linkplain Oblasť oblasti}.</p>
			 * 
			 * @see #kresliTvary()
			 * @see #kreslenieTvarovPovolené()
			 * @see #kružnica() kružnica
			 * @see #kresliElipsu(double) kresliElipsu
			 * @see #kresliŠtvorec() kresliŠtvorec
			 * @see #kresliObdĺžnik(double) kresliObdĺžnik
			 * @see #kresliHviezdu() kresliHviezdu
			 * @see #text(String, int) text
			 * @see #cesta() cesta
			 * @see #zdvihniPero() zdvihniPero
			 */
			public void nekresliTvary()
			{
				uvoľni();
				kresliTvary = false;
			}

			/** <p><a class="alias"></a> Alias pre {@link #nekresliTvary() nekresliTvary}.</p> */
			public void nekresliÚtvary() { nekresliTvary(); }

			/** <p><a class="alias"></a> Alias pre {@link #nekresliTvary() nekresliTvary}.</p> */
			public void nekresliUtvary() { nekresliTvary(); }

			/**
			 * <p>Zistí, či je kreslenie tvarov povolené alebo zakázané.
			 * Kreslenie mohlo byť povolené alebo zakázané metódami {@link 
			 * #kresliTvary() kresliTvary}, resp. {@link #nekresliTvary()
			 * nekresliTvary}, prípadne iným mechanizmom).</p>
			 * 
			 * @return {@code valtrue} – kreslenie tvarov je povolené;
			 *     {@code valfalse} – kreslenie tvarov je zakázané
			 * 
			 * @see #kresliTvary()
			 * @see #nekresliTvary()
			 * @see #kružnica() kružnica
			 * @see #kresliElipsu(double) kresliElipsu
			 * @see #kresliŠtvorec() kresliŠtvorec
			 * @see #kresliObdĺžnik(double) kresliObdĺžnik
			 * @see #kresliHviezdu() kresliHviezdu
			 * @see #text(String, int) text
			 * @see #cesta() cesta
			 * @see #polohaPera() polohaPera
			 */
			public boolean kreslenieTvarovPovolené() { return kresliTvary; }

			/** <p><a class="alias"></a> Alias pre {@link #kreslenieTvarovPovolené() kreslenieTvarovPovolené}.</p> */
			public boolean kreslenieTvarovPovolene() { return kresliTvary; }

			/**
			 * <p>Zruší oblasť na obmedzenie kreslenia na aktívne plátno
			 * (podlahu, strop alebo obrázok, do ktorého má robot
			 * presmerované kreslenie).</p>
			 * 
			 * @see Plátno#kresliVšade()
			 * @see Obrázok#kresliVšade()
			 * @see #kresliDo(Shape)
			 * @see #nekresliDo(Shape)
			 */
			public void kresliVšade()
			{
				if (obrázokAktívnehoPlátna instanceof Obrázok)
					((Obrázok)obrázokAktívnehoPlátna).kresliVšade();
				else
					grafikaAktívnehoPlátna.setClip(null);
			}

			/** <p><a class="alias"></a> Alias pre {@link #kresliVšade() kresliVšade}.</p> */
			public void kresliVsade() { kresliVšade(); }

			/**
			 * <p>Obmedzí akékoľvek kreslenie na aktívne plátno robota (podlahu
			 * alebo strop) na plochu zadaného útvaru ({@link Shape Shape}).</p>
			 * 
			 * <p>Robot disponuje množinou metód na kreslenie tvarov
			 * ({@link #kružnica(double) kružnica}, {@link #elipsa(double,
			 * double) elipsa}, {@link #štvorec(double) štvorec}…), ktoré
			 * zároveň generujú tvary. Na ich použitie s touto metódou je
			 * dobré predtým kreslenie tvarov {@linkplain #nekresliTvary()
			 * zakázať} a neskôr opäť {@linkplain #kresliTvary() povoliť}.
			 * Metóda {@link #text(String) text} dokonca zákaz kreslenia
			 * tvarov požaduje, aby mohla vygenerovať tvar (bez zákazu má
			 * návratovú hodnotu {@code valnull}). Tvar je možné vytvoriť aj
			 * z {@linkplain #cesta() cesty}…</p>
			 * 
			 * <p>Obmedzenie zužuje aktuálny priestor kreslenia, to znamená,
			 * že sa priebežne vytvára oblasť, ktorá je prienikom všetkých
			 * obmedzení. Ak chceme vytvoriť obmedzenie pre tvar, ktorý je
			 * možné vytvoriť inou množinovou operáciou, môžeme na
			 * obmedzenie kreslenia použiť {@link Oblasť Oblasť} (zadanú
			 * namiesto parametra {@code tvar}). Je nevyhnutné podotknúť, že
			 * obmedzenie je viazané na plátno a je platné pre všetky
			 * roboty.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Pri takomto orezávaní nie
			 * je na všetkých platformách a/alebo implementáciách virtuálneho
			 * stroja Javy dostupná funkcia anti-aliasingu, čo zjednodušene
			 * povedané znamená, že okraje orezanej kresby budú „zúbkaté.“
			 * Ak sa chcete tejto nedokonalosti vyhnúť, použite radšej funkciu
			 * {@linkplain Plátno#použiMasku masky}. Tá dovoľuje ovplyvňovať
			 * úroveň priehľadnosti s jemnosťou na jednotlivé body rastra.</p>
			 * 
			 * @param tvar tvar ({@link Shape Shape}) alebo {@link Oblasť
			 *     Oblasť}
			 * 
			 * @see Plátno#kresliDo(Shape)
			 * @see Obrázok#kresliDo(Shape)
			 * @see #kresliVšade()
			 * @see #nekresliDo(Shape)
			 */
			public void kresliDo(Shape tvar)
			{
				if (obrázokAktívnehoPlátna instanceof Obrázok)
					((Obrázok)obrázokAktívnehoPlátna).kresliDo(tvar);
				else if (null != tvar)
					grafikaAktívnehoPlátna.clip(tvar);
			}

			// <stroke>Pomocná súkromná metóda na vytvorenie
			// negatívneho orezania oblasti</stroke>

			/**
			 * <p>Vytvára obmedzenie na kreslenie na aktívne plátno robota
			 * (podlahu, strop alebo obrázok, do ktorého má robot
			 * presmerované kreslenie). Funguje rovnako ako metóda {@link 
			 * #kresliDo(Shape) kresliDo}, ibaže obrátene – kreslenie je
			 * možné všade, okrem zadaného tvaru alebo {@linkplain Oblasť
			 * oblasti}.</p>
			 * 
			 * <p>Rovnako ako pri metóde {@link #kresliDo(Shape) kresliDo},
			 * sa aj toto obmedzenie kombinuje s aktuálnymi obmedzeniami na
			 * kreslenie a je platné pre všetky roboty.</p>
			 * 
			 * <p class="remark"><b>Poznámka:</b> Pri takomto orezávaní nie
			 * je na všetkých platformách a/alebo implementáciách virtuálneho
			 * stroja Javy dostupná funkcia anti-aliasingu, čo zjednodušene
			 * povedané znamená, že okraje orezanej kresby budú „zúbkaté.“
			 * Ak sa chcete tejto nedokonalosti vyhnúť, použite radšej funkciu
			 * {@linkplain Plátno#použiMasku masky}. Tá dovoľuje ovplyvňovať
			 * úroveň priehľadnosti s jemnosťou na jednotlivé body rastra.</p>
			 * 
			 * @param tvar tvar ({@link Shape Shape}) alebo {@link Oblasť
			 *     Oblasť}
			 * 
			 * @see Plátno#nekresliDo(Shape)
			 * @see Obrázok#nekresliDo(Shape)
			 * @see #kresliDo(Shape)
			 * @see #kresliVšade()
			 */
			public void nekresliDo(Shape tvar)
			{
				if (obrázokAktívnehoPlátna instanceof Obrázok)
					((Obrázok)obrázokAktívnehoPlátna).nekresliDo(tvar);
				else if (null != tvar)
				{
					Shape clip = grafikaAktívnehoPlátna.getClip();
					if (null == clip) clip = new Rectangle.
						Double(0, 0, Plátno.šírkaPlátna, Plátno.výškaPlátna);
					Area oblasťA = new Area(clip);
					Area oblasťB = new Area(tvar);
					oblasťA.subtract(oblasťB);
					grafikaAktívnehoPlátna.setClip(oblasťA);
				}
			}


		// Interaktívny režim

			/**
			 * <p>Táto metóda má rovnaké jadro ako mechanizmus vykonávania
			 * príkazov v {@linkplain Svet#interaktívnyRežim(boolean)
			 * interaktívnom režime} a umožňuje používať príkazy, ktoré sú
			 * dostupné v tomto režime aj za jeho hranicami (t. j. bez
			 * nevyhnutnosti jeho aktivácie).</p>
			 * 
			 * @param príkaz príkazový riadok spĺňajúci pravidlá uvedené
			 *     v opise metódy {@link Svet#interaktívnyRežim(boolean)
			 *     interaktívnyRežim}
			 * @return {@code valtrue} ak bol príkaz nájdený a podarilo
			 *     sa ho vykonať
			 * 
			 * @see Svet#vykonajPríkaz(String)
			 * @see Plátno#vykonajPríkaz(String)
			 * @see GRobot#interaktívnyRežim(boolean)
			 * @see Svet#interaktívnyRežim(boolean)
			 * @see Plátno#interaktívnyRežim(boolean)
			 * @see Svet#režimLadenia(boolean)
			 * 
			 * @throws GRobotException ak bolo vykonávanie príkazu zrušené
			 * @throws IllegalAccessException ak metóda, s ktorou súvisí
			 *     vykonávanie príkazu nie je dostupná (verejná)
			 * @throws IllegalArgumentException ak niektorý z argumentov
			 *     metódy, s ktorou súvisí vykonávanie príkazu nie je
			 *     požadovaného typu, ani ho na neho nie je možné previesť
			 * @throws InvocationTargetException ak pri vykonávní metódy,
			 *     s ktorou súvisí vykonávanie príkazu vznikla výnimka
			 */
			public boolean vykonajPríkaz(String príkaz)
			{
				Class<? extends GRobot> tátoTrieda = this.getClass();
				// Táto metóda síce volá súkromnú metódu sveta, ale zadaný
				// príkaz je vykonaný pre túto triedu a inštanciu:
				if (Skript.vykonajPríkaz(príkaz, tátoTrieda, this)) return true;
				// Pre statické členy tejto triedy:
				if (Skript.vykonajPríkaz(príkaz, tátoTrieda, null)) return true;
				// A pre inštanciu súboru robota:
				if (Skript.vykonajPríkaz(príkaz, Súbor.class, súbor)) return true;
				return Skript.vykonajPríkaz(príkaz, Súbor.class, null);
			}

			/** <p><a class="alias"></a> Alias pre {@link #vykonajPríkaz(String) vykonajPríkaz}.</p> */
			public boolean vykonajPrikaz(String príkaz)
			{ return vykonajPríkaz(príkaz); }

			/**
			 * <p>Zapne alebo vypne interaktívny režim pre tento robot.
			 * Pozri: {@link Svet#interaktívnyRežim(boolean)
			 * Svet.interaktívnyRežim(zapni)}.</p>
			 * 
			 * @param zapni ak je {@code valtrue}, režim bude pre tento robot
			 *     zapnutý, inak bude vypnutý
			 * 
			 * @see Svet#interaktívnyRežim(boolean)
			 * @see Plátno#interaktívnyRežim(boolean)
			 * @see Svet#režimLadenia(boolean)
			 */
			public void interaktívnyRežim(boolean zapni)
			{
				if (zapni)
				{
					if (!interaktívnyRežim)
					{
						interaktívnyRežim = true;
						if (0 == Svet.početVInteraktívnomRežime)
							Svet.neskrývajVstupnýRiadok(true);
						++Svet.početVInteraktívnomRežime;
					}
				}
				else
				{
					if (interaktívnyRežim)
					{
						interaktívnyRežim = false;
						--Svet.početVInteraktívnomRežime;
						if (0 == Svet.početVInteraktívnomRežime)
							Svet.skrývajVstupnýRiadok(true);
					}
				}
			}

			/** <p><a class="alias"></a> Alias pre {@link #interaktívnyRežim(boolean) interaktívnyRežim}.</p> */
			public void interaktivnyRezim(boolean zapni)
			{ interaktívnyRežim(zapni); }

			/**
			 * <p>Zistí stav interaktívneho režimu pre tento robot.
			 * Pozri: {@link Svet#interaktívnyRežim(boolean)
			 * Svet.interaktívnyRežim(zapni)}.</p>
			 * 
			 * @return stav režimu pre tento robot
			 */
			public boolean interaktívnyRežim() { return interaktívnyRežim; }

			/** <p><a class="alias"></a> Alias pre {@link #interaktívnyRežim() interaktívnyRežim}.</p> */
			public boolean interaktivnyRezim() { return interaktívnyRežim; }


	/**
	 * <p>Rámec hlavného okna aplikácie. Má využitie pri programovaní vlastného
	 * používateľského rozhrania aplikácie, úprave hlavnej ponuky, ikony
	 * a podobne…</p>
	 * 
	 * <p class="remark"><b>Poznámka:</b> Na prístup k statickým prvkom triedy
	 * {@link Svet Svet} by ste mali používať syntax:
	 * <code>Svet.</code><em>«prvok triedy»</em></p>
	 */
	public final static Svet svet = Svet.dajSvet();


	/**
	 * <p>Reprezentácia podlahy tohto sveta. Umožňuje vykonávať s podlahou
	 * rôzne akcie, napríklad zálohovanie do a obnovu zo záložnej pamäte,
	 * čo sa dá využiť na rýchle kreslenie podkladu a podobne. (Podrobnosti
	 * sú v opise triedy {@link Plátno Plátno}.)</p>
	 */
	public final static Plátno podlaha = new Plátno();

	/**
	 * <p>Reprezentácia stropu tohto sveta. Umožňuje vykonávať so stropom
	 * rôzne akcie, napríklad zálohovanie do a obnovu zo záložnej pamäte,
	 * čo sa dá využiť napríklad na rýchle nakreslenie kulís objektov
	 * permanentne prítomných v popredí a podobne. (Podrobnosti sú v opise
	 * triedy {@link Plátno Plátno}.)</p>
	 */
	public final static Plátno strop = new Plátno();


	/**
	 * <p>Každý robot smie otvoriť jeden textový (prípadne konfiguračný)
	 * súbor na čítanie alebo zápis. Podrobnosti o používaní tejto inštancie
	 * obsahuje opis triedy {@link Súbor Súbor}.</p>
	 */
	public final Súbor súbor = new Súbor();

	/** <p><a class="alias"></a> Alias pre {@link GRobot#súbor súbor}.</p> */
	public final Súbor subor = súbor;


	/**
	 * <p>Statická inštancia triedy {@link Schránka Schránka}, ktorá
	 * umožňuje pracovať so schránkou operačného systému.</p>
	 */
	public final static Schránka schránka = new Schránka();

	/** <p><a class="alias"></a> Alias pre {@link #schránka schránka}.</p> */
	public final static Schránka schranka = schránka;


	/**
	 * <p>Statická inštancia triedy {@link SVGPodpora SVGPodpora}, ktorá
	 * zastrešuje podporu importu a exportu vektorových tvarov vo formáte
	 * SVG.</p>
	 */
	public final static SVGPodpora svgPodpora = new SVGPodpora();
}

// :wrap=none:
